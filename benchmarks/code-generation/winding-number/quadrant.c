// This file is automatically generated by PRECiSA 

#include<stdio.h>
#include<stdlib.h>
#include<math.h>
#include<string.h>
#include<stdbool.h>
#include"precisa_prelude.c"




/*@
axiomatic real_function_quadrant {
logic integer quadrant (real X, real Y) =
((0 <= X) && (0 <= Y))
? 1 :
((X <= 0) && (0 <= Y))
? 2 :
(X <= 0)
? 3 :
4;
}
*/


/*@ axiomatic quadrant_trans {
predicate quadrant_trans_value(double double_X, double double_Y, double double_E_0, double double_E_1, double result)
= (((double_E_0 <= double_X) && (double_E_1 <= double_Y)))
  ? result ==  1.0 :
  (((double_X <= Dneg(double_E_0)) && (double_E_1 <= double_Y)) && ((double_X < Dneg(double_E_0)) || (double_Y < Dneg(double_E_1))))
  ? result ==  2.0 :
  (((double_X <= Dneg(double_E_0)) && ((double_E_0 < double_X) || (double_Y < Dneg(double_E_1)))) && ((double_X < Dneg(double_E_0)) || (double_Y < Dneg(double_E_1))))
  ? result ==  3.0 :
  result ==  4.0 ;

predicate quadrant_stable_paths(real X, real Y, double double_X, double double_Y)
= (((X <= 0) && (0 <= Y)) && (! ((0 <= X) && (0 <= Y))) && (((double_X <= 0.0) && (0.0 <= double_Y)) && !(((0.0 <= double_X) && (0.0 <= double_Y))))) || ((! (X <= 0)) && ((! ((X <= 0) && (0 <= Y))) && (! ((0 <= X) && (0 <= Y)))) && (!((double_X <= 0.0)) && (!(((double_X <= 0.0) && (0.0 <= double_Y))) && !(((0.0 <= double_X) && (0.0 <= double_Y)))))) || ((0 <= X) && (0 <= Y) && ((0.0 <= double_X) && (0.0 <= double_Y))) || ((X <= 0) && ((! ((X <= 0) && (0 <= Y))) && (! ((0 <= X) && (0 <= Y)))) && ((double_X <= 0.0) && (!(((double_X <= 0.0) && (0.0 <= double_Y))) && !(((0.0 <= double_X) && (0.0 <= double_Y)))))) ;
}
*/


/*@requires 0 <= double_E_0 && 0 <= double_E_1;
assigns \nothing;

behavior structure:
ensures \result.isValid ==> quadrant_trans_value(double_X, double_Y, double_E_0, double_E_1, \result.value);

behavior stable_paths:
ensures \result.isValid
  ==> \forall real X, real Y;
  (
  \abs(double_X - X) <= double_E_0 &&
  \abs(double_Y - Y) <= double_E_1)
    ==>quadrant_stable_paths(X, Y, double_X, double_Y);

behavior symbolic:
ensures \forall real X, real Y , E_X, E_Y ;
\abs(X - double_X) <= E_X && \abs(Y - double_Y) <= E_Y &&
(
\abs(double_X - X) <= double_E_0 &&
\abs(double_Y - Y) <= double_E_1) &&
\result.isValid
==> \abs(\result.value - quadrant(X, Y)) <= \max(\max(\max(0 % 1 , 0 % 1) , 0 % 1) , 0 % 1) ;
*/
struct maybeInt quadrant_int (double double_X, double double_Y, double double_E_0, double double_E_1) {
  struct maybeInt res;
  if ((double_E_0 <= double_X) && (double_E_1 <= double_Y))
  { res =  some(1);
  } else if (((double_X <= - (double_E_0)) && (double_E_1 <= double_Y)) && ((double_X < - (double_E_0)) || (double_Y < - (double_E_1))))
    { res =  some(2); }
    else if (((double_X <= - (double_E_0)) && ((double_E_0 < double_X) || (double_Y < - (double_E_1)))) && ((double_X < - (double_E_0)) || (double_Y < - (double_E_1))))
    { res =  some(3); }
    else if (((double_E_0 < double_X) && ((double_E_0 < double_X) || (double_Y < - (double_E_1)))) && ((double_X < - (double_E_0)) || (double_Y < - (double_E_1))))
    { res =  some(4); } else { res = none() ;
  }
return res;
}


/*@
ensures ( -60000 <= X <= 60000 && -10000 <= Y <= 10000) &&
\result.isValid
==> \abs(\result.value - quadrant(X, Y)) <= 0x0p+0;
*/
struct maybeInt quadrant_num (X, Y) {
return quadrant_int (X, Y,0x1p-38, 0x1p-40);
}


int main () { return 0; }