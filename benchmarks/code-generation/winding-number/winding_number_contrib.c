// This file is automatically generated by PRECiSA 

#include<stdio.h>
#include<stdlib.h>
#include<math.h>
#include<string.h>
#include<stdbool.h>
#include"precisa_prelude.c"




/*@
axiomatic real_function_quadrant {
logic integer quadrant (real X, real Y) =
((0 <= X) && (0 <= Y))
? 1 :
((X <= 0) && (0 <= Y))
? 2 :
(X <= 0)
? 3 :
4;
}
*/


/*@ axiomatic quadrant_trans {
predicate quadrant_trans_value(double double_X, double double_Y, double double_E_0, double double_E_1, double result)
= (((double_E_0 <= double_X) && (double_E_1 <= double_Y)))
  ? result ==  1.0 :
  (((double_X <= Dneg(double_E_0)) && (double_E_1 <= double_Y)) && ((double_X < Dneg(double_E_0)) || (double_Y < Dneg(double_E_1))))
  ? result ==  2.0 :
  (((double_X <= Dneg(double_E_0)) && ((double_E_0 < double_X) || (double_Y < Dneg(double_E_1)))) && ((double_X < Dneg(double_E_0)) || (double_Y < Dneg(double_E_1))))
  ? result ==  3.0 :
  result ==  4.0 ;

predicate quadrant_stable_paths(real X, real Y, double double_X, double double_Y)
= (((X <= 0) && (0 <= Y)) && (! ((0 <= X) && (0 <= Y))) && (((double_X <= 0.0) && (0.0 <= double_Y)) && !(((0.0 <= double_X) && (0.0 <= double_Y))))) || ((! (X <= 0)) && ((! ((X <= 0) && (0 <= Y))) && (! ((0 <= X) && (0 <= Y)))) && (!((double_X <= 0.0)) && (!(((double_X <= 0.0) && (0.0 <= double_Y))) && !(((0.0 <= double_X) && (0.0 <= double_Y)))))) || ((0 <= X) && (0 <= Y) && ((0.0 <= double_X) && (0.0 <= double_Y))) || ((X <= 0) && ((! ((X <= 0) && (0 <= Y))) && (! ((0 <= X) && (0 <= Y)))) && ((double_X <= 0.0) && (!(((double_X <= 0.0) && (0.0 <= double_Y))) && !(((0.0 <= double_X) && (0.0 <= double_Y)))))) ;
}
*/


/*@
requires 0 <= double_E_0 && 0 <= double_E_1;
assigns \nothing;

behavior structure:
ensures \result.isValid ==> quadrant_trans_value(double_X, double_Y, double_E_0, double_E_1, \result.value);

behavior stable_paths:
ensures \result.isValid
  ==> \forall real X, real Y;
  (
  \abs(double_X - X) <= double_E_0 &&
  \abs(double_Y - Y) <= double_E_1)
    ==> quadrant_stable_paths(X, Y, double_X, double_Y);

behavior symbolic:
ensures \forall real X, real Y , E_X, E_Y ;
\abs(X - double_X) <= E_X && \abs(Y - double_Y) <= E_Y &&
(
\abs(double_X - X) <= double_E_0 &&
\abs(double_Y - Y) <= double_E_1) &&
\result.isValid
==> \abs(\result.value - quadrant(X, Y)) <= \max(\max(\max(0 % 1 , 0 % 1) , 0 % 1) , 0 % 1) ;
*/
struct maybeInt quadrant_int (double double_X, double double_Y, double double_E_0, double double_E_1) {
  struct maybeInt res;
  if ((double_E_0 <= double_X) && (double_E_1 <= double_Y))
  { res =  some(1);
  } else if (((double_X <= - (double_E_0)) && (double_E_1 <= double_Y)) && ((double_X < - (double_E_0)) || (double_Y < - (double_E_1))))
    { res =  some(2); }
    else if (((double_X <= - (double_E_0)) && ((double_E_0 < double_X) || (double_Y < - (double_E_1)))) && ((double_X < - (double_E_0)) || (double_Y < - (double_E_1))))
    { res =  some(3); }
    else if (((double_E_0 < double_X) && ((double_E_0 < double_X) || (double_Y < - (double_E_1)))) && ((double_X < - (double_E_0)) || (double_Y < - (double_E_1))))
    { res =  some(4); } else { res = none() ;
  }
return res;
}


/*@
ensures ( -60000 <= X <= 60000 && -10000 <= Y <= 10000) &&
\result.isValid
==> \abs(\result.value - quadrant(X, Y)) <= 0x0p+0;
*/
struct maybeInt quadrant_num (X, Y) {
return quadrant_int (X, Y,0x1p-38, 0x1p-40);
}


/*@
axiomatic real_function_winding_number_contrib {
logic integer winding_number_contrib (real P_V1_x, real P_V1_y, real P_V2_x, real P_V2_y, real S_x, real S_y) =
\let THIS_x = (P_V1_x - S_x) ;
(\let THIS_y = (P_V1_y - S_y) ;
 (\let NEXT_x = (P_V2_x - S_x) ;
  (\let NEXT_y = (P_V2_y - S_y) ;
   (\let DISTANCE_x = (NEXT_x - THIS_x) ;
    (\let DISTANCE_y = (NEXT_y - THIS_y) ;
     (\let DET = ((DISTANCE_x * THIS_y) - (DISTANCE_y * THIS_x)) ;
      (\let K = quadrant(THIS_x, THIS_y) ;
       (\let P = quadrant(NEXT_x, NEXT_y) ;
        ((K == P)
         ? 0 :
         ((P - 1) == (K % 4))
         ? 1 :
         ((K - 1) == (P % 4))
         ? -(1) :
         (DET <= 0)
         ? 2 :
         -(2))))))))));
}
*/


/*@ axiomatic winding_number_contrib_trans {
predicate winding_number_contrib_trans_value(double double_P_V1_x, double double_P_V1_y, double double_P_V2_x, double double_P_V2_y, double double_S_x, double double_S_y, double double_E_0, double double_E_1, double double_E_2, double double_E_3, double double_E_4, double result)
= \exists double res1, double res0; quadrant_trans_value(double_THIS_x, double_THIS_y, double_E_3, double_E_4, res1) && quadrant_trans_value(double_NEXT_x, double_NEXT_y, double_E_1, double_E_2, res0) &&
  \let THIS_x = Dsub(double_P_V1_x, double_S_x) ;
  (\let THIS_y = Dsub(double_P_V1_y, double_S_y) ;
   (\let NEXT_x = Dsub(double_P_V2_x, double_S_x) ;
    (\let NEXT_y = Dsub(double_P_V2_y, double_S_y) ;
     (\let DISTANCE_x = Dsub(double_NEXT_x, double_THIS_x) ;
      (\let DISTANCE_y = Dsub(double_NEXT_y, double_THIS_y) ;
       (\let DET = Dsub(Dmul(double_DISTANCE_x, double_THIS_y), Dmul(double_DISTANCE_y, double_THIS_x)) ;
        ((\let K = res1 ;
          ((\let P = res0 ;
            (((K = P))
             ? result ==  0.0 :
             (Isub(P, 1.0) = Imod(K, 4.0))
             ? result ==  1.0 :
             (Isub(K, 1.0) = Imod(P, 4.0))
             ? result ==  Dneg(1.0) :
             (double_DET <= Dneg(double_E_0))
             ? result ==  2.0 :
             result ==  Dneg(2.0)))))))))))) ;

predicate winding_number_contrib_stable_paths(real P_V1_x, real P_V1_y, real P_V2_x, real P_V2_y, real S_x, real S_y, double double_P_V1_x, double double_P_V1_y, double double_P_V2_x, double double_P_V2_y, double double_S_x, double double_S_y)
= ((! (((((P_V2_x - S_x) - (P_V1_x - S_x)) * (P_V1_y - S_y)) - (((P_V2_y - S_y) - (P_V1_y - S_y)) * (P_V1_x - S_x))) <= 0)) && ((! ((quadrant((P_V1_x - S_x), (P_V1_y - S_y)) - 1) == (quadrant((P_V2_x - S_x), (P_V2_y - S_y)) % 4))) && ((! ((quadrant((P_V2_x - S_x), (P_V2_y - S_y)) - 1) == (quadrant((P_V1_x - S_x), (P_V1_y - S_y)) % 4))) && (! (quadrant((P_V1_x - S_x), (P_V1_y - S_y)) == quadrant((P_V2_x - S_x), (P_V2_y - S_y)))))) && (!((Dsub(Dmul(Dsub(Dsub(double_P_V2_x, double_S_x), Dsub(double_P_V1_x, double_S_x)), Dsub(double_P_V1_y, double_S_y)), Dmul(Dsub(Dsub(double_P_V2_y, double_S_y), Dsub(double_P_V1_y, double_S_y)), Dsub(double_P_V1_x, double_S_x))) <= 0.0)) && (!((Isub(quadrant(Dsub(double_P_V1_x, double_S_x), Dsub(double_P_V1_y, double_S_y)), 1.0) = Imod(quadrant(Dsub(double_P_V2_x, double_S_x), Dsub(double_P_V2_y, double_S_y)), 4.0))) && (!((Isub(quadrant(Dsub(double_P_V2_x, double_S_x), Dsub(double_P_V2_y, double_S_y)), 1.0) = Imod(quadrant(Dsub(double_P_V1_x, double_S_x), Dsub(double_P_V1_y, double_S_y)), 4.0))) && !((quadrant(Dsub(double_P_V1_x, double_S_x), Dsub(double_P_V1_y, double_S_y)) = quadrant(Dsub(double_P_V2_x, double_S_x), Dsub(double_P_V2_y, double_S_y)))))))) || (((quadrant((P_V1_x - S_x), (P_V1_y - S_y)) - 1) == (quadrant((P_V2_x - S_x), (P_V2_y - S_y)) % 4)) && ((! ((quadrant((P_V2_x - S_x), (P_V2_y - S_y)) - 1) == (quadrant((P_V1_x - S_x), (P_V1_y - S_y)) % 4))) && (! (quadrant((P_V1_x - S_x), (P_V1_y - S_y)) == quadrant((P_V2_x - S_x), (P_V2_y - S_y))))) && ((Isub(quadrant(Dsub(double_P_V1_x, double_S_x), Dsub(double_P_V1_y, double_S_y)), 1.0) = Imod(quadrant(Dsub(double_P_V2_x, double_S_x), Dsub(double_P_V2_y, double_S_y)), 4.0)) && (!((Isub(quadrant(Dsub(double_P_V2_x, double_S_x), Dsub(double_P_V2_y, double_S_y)), 1.0) = Imod(quadrant(Dsub(double_P_V1_x, double_S_x), Dsub(double_P_V1_y, double_S_y)), 4.0))) && !((quadrant(Dsub(double_P_V1_x, double_S_x), Dsub(double_P_V1_y, double_S_y)) = quadrant(Dsub(double_P_V2_x, double_S_x), Dsub(double_P_V2_y, double_S_y))))))) || (((quadrant((P_V2_x - S_x), (P_V2_y - S_y)) - 1) == (quadrant((P_V1_x - S_x), (P_V1_y - S_y)) % 4)) && (! (quadrant((P_V1_x - S_x), (P_V1_y - S_y)) == quadrant((P_V2_x - S_x), (P_V2_y - S_y)))) && ((Isub(quadrant(Dsub(double_P_V2_x, double_S_x), Dsub(double_P_V2_y, double_S_y)), 1.0) = Imod(quadrant(Dsub(double_P_V1_x, double_S_x), Dsub(double_P_V1_y, double_S_y)), 4.0)) && !((quadrant(Dsub(double_P_V1_x, double_S_x), Dsub(double_P_V1_y, double_S_y)) = quadrant(Dsub(double_P_V2_x, double_S_x), Dsub(double_P_V2_y, double_S_y)))))) || ((((((P_V2_x - S_x) - (P_V1_x - S_x)) * (P_V1_y - S_y)) - (((P_V2_y - S_y) - (P_V1_y - S_y)) * (P_V1_x - S_x))) <= 0) && ((! ((quadrant((P_V1_x - S_x), (P_V1_y - S_y)) - 1) == (quadrant((P_V2_x - S_x), (P_V2_y - S_y)) % 4))) && ((! ((quadrant((P_V2_x - S_x), (P_V2_y - S_y)) - 1) == (quadrant((P_V1_x - S_x), (P_V1_y - S_y)) % 4))) && (! (quadrant((P_V1_x - S_x), (P_V1_y - S_y)) == quadrant((P_V2_x - S_x), (P_V2_y - S_y)))))) && ((Dsub(Dmul(Dsub(Dsub(double_P_V2_x, double_S_x), Dsub(double_P_V1_x, double_S_x)), Dsub(double_P_V1_y, double_S_y)), Dmul(Dsub(Dsub(double_P_V2_y, double_S_y), Dsub(double_P_V1_y, double_S_y)), Dsub(double_P_V1_x, double_S_x))) <= 0.0) && (!((Isub(quadrant(Dsub(double_P_V1_x, double_S_x), Dsub(double_P_V1_y, double_S_y)), 1.0) = Imod(quadrant(Dsub(double_P_V2_x, double_S_x), Dsub(double_P_V2_y, double_S_y)), 4.0))) && (!((Isub(quadrant(Dsub(double_P_V2_x, double_S_x), Dsub(double_P_V2_y, double_S_y)), 1.0) = Imod(quadrant(Dsub(double_P_V1_x, double_S_x), Dsub(double_P_V1_y, double_S_y)), 4.0))) && !((quadrant(Dsub(double_P_V1_x, double_S_x), Dsub(double_P_V1_y, double_S_y)) = quadrant(Dsub(double_P_V2_x, double_S_x), Dsub(double_P_V2_y, double_S_y)))))))) || (quadrant((P_V1_x - S_x), (P_V1_y - S_y)) == quadrant((P_V2_x - S_x), (P_V2_y - S_y)) && (quadrant(Dsub(double_P_V1_x, double_S_x), Dsub(double_P_V1_y, double_S_y)) = quadrant(Dsub(double_P_V2_x, double_S_x), Dsub(double_P_V2_y, double_S_y)))) ;
}
*/


/*@
requires 0 <= double_E_0 && 0 <= double_E_1 && 0 <= double_E_2 && 0 <= double_E_3 && 0 <= double_E_4;
assigns \nothing;

behavior structure:
ensures \result.isValid ==> winding_number_contrib_trans_value(double_P_V1_x, double_P_V1_y, double_P_V2_x, double_P_V2_y, double_S_x, double_S_y, double_E_0, double_E_1, double_E_2, double_E_3, double_E_4, \result.value);

behavior stable_paths:
ensures \result.isValid
  ==> \forall real P_V1_x, real P_V1_y, real P_V2_x, real P_V2_y, real S_x, real S_y;
  \let double_THIS_y = Dsub(P_V1_y, S_y);
  \let THIS_y = (P_V1_y - S_y);
  \let double_THIS_x = Dsub(P_V1_x, S_x);
  \let THIS_x = (P_V1_x - S_x);
  \let double_NEXT_y = Dsub(P_V2_y, S_y);
  \let NEXT_y = (P_V2_y - S_y);
  \let double_NEXT_x = Dsub(P_V2_x, S_x);
  \let NEXT_x = (P_V2_x - S_x);
  \let double_DISTANCE_y = Dsub(NEXT_y, THIS_y);
  \let DISTANCE_y = (NEXT_y - THIS_y);
  \let double_DISTANCE_x = Dsub(NEXT_x, THIS_x);
  \let DISTANCE_x = (NEXT_x - THIS_x);
  \let double_DET = Dsub(Dmul(DISTANCE_x, THIS_y), Dmul(DISTANCE_y, THIS_x));
  \let DET = ((DISTANCE_x * THIS_y) - (DISTANCE_y * THIS_x));
  (
  \abs(double_DET - DET) <= double_E_0 &&
  \abs(double_NEXT_x - NEXT_x) <= double_E_1 &&
  \abs(double_NEXT_y - NEXT_y) <= double_E_2 &&
  \abs(double_THIS_x - THIS_x) <= double_E_3 &&
  \abs(double_THIS_y - THIS_y) <= double_E_4)
    ==> winding_number_contrib_stable_paths(P_V1_x, P_V1_y, P_V2_x, P_V2_y, S_x, S_y, double_P_V1_x, double_P_V1_y, double_P_V2_x, double_P_V2_y, double_S_x, double_S_y);

behavior symbolic:
ensures \forall real P_V1_x, real P_V1_y, real P_V2_x, real P_V2_y, real S_x, real S_y , E_P_V1_x, E_P_V1_y, E_P_V2_x, E_P_V2_y, E_S_x, E_S_y ;
\abs(P_V1_x - double_P_V1_x) <= E_P_V1_x && \abs(P_V1_y - double_P_V1_y) <= E_P_V1_y && \abs(P_V2_x - double_P_V2_x) <= E_P_V2_x && \abs(P_V2_y - double_P_V2_y) <= E_P_V2_y && \abs(S_x - double_S_x) <= E_S_x && \abs(S_y - double_S_y) <= E_S_y &&
\let double_THIS_y = Dsub(P_V1_y, S_y);
\let THIS_y = (P_V1_y - S_y);
\let double_THIS_x = Dsub(P_V1_x, S_x);
\let THIS_x = (P_V1_x - S_x);
\let double_NEXT_y = Dsub(P_V2_y, S_y);
\let NEXT_y = (P_V2_y - S_y);
\let double_NEXT_x = Dsub(P_V2_x, S_x);
\let NEXT_x = (P_V2_x - S_x);
\let double_DISTANCE_y = Dsub(NEXT_y, THIS_y);
\let DISTANCE_y = (NEXT_y - THIS_y);
\let double_DISTANCE_x = Dsub(NEXT_x, THIS_x);
\let DISTANCE_x = (NEXT_x - THIS_x);
\let double_DET = Dsub(Dmul(DISTANCE_x, THIS_y), Dmul(DISTANCE_y, THIS_x));
\let DET = ((DISTANCE_x * THIS_y) - (DISTANCE_y * THIS_x));
(
\abs(double_DET - DET) <= double_E_0 &&
\abs(double_NEXT_x - NEXT_x) <= double_E_1 &&
\abs(double_NEXT_y - NEXT_y) <= double_E_2 &&
\abs(double_THIS_x - THIS_x) <= double_E_3 &&
\abs(double_THIS_y - THIS_y) <= double_E_4) &&
\result.isValid
==> \abs(\result.value - winding_number_contrib(P_V1_x, P_V1_y, P_V2_x, P_V2_y, S_x, S_y)) <= \max(\max(\max(\max(0 % 1 , 0 % 1) , 0 % 1) , 0 % 1) , 0 % 1) ;
*/
struct maybeInt winding_number_contrib_int (double double_P_V1_x, double double_P_V1_y, double double_P_V2_x, double double_P_V2_y, double double_S_x, double double_S_y, double double_E_0, double double_E_1, double double_E_2, double double_E_3, double double_E_4) {
  struct maybeInt res;
  double double_THIS_x = (double_P_V1_x - double_S_x) ;
  double double_THIS_y = (double_P_V1_y - double_S_y) ;
  double double_NEXT_x = (double_P_V2_x - double_S_x) ;
  double double_NEXT_y = (double_P_V2_y - double_S_y) ;
  double double_DISTANCE_x = (double_NEXT_x - double_THIS_x) ;
  double double_DISTANCE_y = (double_NEXT_y - double_THIS_y) ;
  double double_DET = ((double_DISTANCE_x * double_THIS_y) - (double_DISTANCE_y * double_THIS_x)) ;
  struct maybeInt aux_0 = quadrant_int (double_THIS_x, double_THIS_y, double_E_3, double_E_4) ;
  if (aux_0.isValid)
  { int K = aux_0.value ;
    struct maybeInt aux_1 = quadrant_int (double_NEXT_x, double_NEXT_y, double_E_1, double_E_2) ;
    if (aux_1.isValid)
    { int P = aux_1.value ;
      if (K == P)
      { res =  some(0);
      } else if ((P - 1) == (K % 4))
        { res =  some(1); }
        else if ((K - 1) == (P % 4))
        { res =  some(- (1)); }
        else if (double_DET <= - (double_E_0))
        { res =  some(2); }
        else if (double_E_0 < double_DET)
        { res =  some(- (2)); } else { res = none() ;
      }
    } else { res = none() ;
    }
  } else { res = none() ;
  }
return res;
}


/*@
ensures ( -60000 <= P_V1_x <= 60000 && -60000 <= P_V1_y <= 60000 && -60000 <= P_V2_x <= 60000 && -60000 <= P_V2_y <= 60000 && -60000 <= S_x <= 60000 && -60000 <= S_y <= 60000) &&
\result.isValid
==> \abs(\result.value - winding_number_contrib(P_V1_x, P_V1_y, P_V2_x, P_V2_y, S_x, S_y)) <= 0x0p+0;
*/
struct maybeInt winding_number_contrib_num (P_V1_x, P_V1_y, P_V2_x, P_V2_y, S_x, S_y) {
return winding_number_contrib_int (P_V1_x, P_V1_y, P_V2_x, P_V2_y, S_x, S_y,0x1.0d14000000001p-16, 0x1p-36, 0x1p-36, 0x1p-36, 0x1p-36);
}


int main () { return 0; }