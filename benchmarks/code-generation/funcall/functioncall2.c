// This file is automatically generated by PRECiSA 

#include<stdio.h>
#include<stdlib.h>
#include<math.h>
#include<string.h>
#include<stdbool.h>
#include"precisa_prelude.c"




/*@
axiomatic real_function_f {
logic real f (real X) =
(X + (X * 2));
}
*/


/*@ axiomatic f_trans {
predicate f_trans_value(double double_X, double result)
= result ==  Dadd(double_X, Dmul(double_X, 2.0)) ;

predicate f_stable_paths(real X, double double_X)
= (\true && \true) ;
}
*/


/*@
assigns \nothing;

behavior structure:
ensures \result.isValid ==> f_trans_value(double_X, \result.value);

behavior stable_paths:
ensures \result.isValid
  ==> \forall real X;
  f_stable_paths(X, double_X);

behavior symbolic:
ensures \forall real X , E_X ;
\abs(X - double_X) <= E_X &&
\result.isValid
==> \abs(\result.value - f(X)) <= errAdd_dp(X, E_X, (X * 2), errMul_dp(X, E_X, 2, 0 % 1)) ;
*/
struct maybeDouble f_double (double double_X) {
  struct maybeDouble res;
  res =  someDouble((double_X + (double_X * 2)));
return res;
}


/*@
ensures ( 0 <= X <= 100) &&
\result.isValid
==> \abs(\result.value - f(X)) <= 0x1.2p-44;
*/
struct maybeDouble f_num (double X) {
return f_double (X);
}


/*@
axiomatic real_function_g {
logic real g (real X) =
0 < X ? (f(X)) : (f((X - 1)));
}
*/


/*@ axiomatic g_trans {
predicate g_trans_value(double double_X, double double_E_0, double result)
= \exists double res1, double res0; f_trans_value(Dsub(double_X, 1.0), res1) && f_trans_value(double_X, res0) &&
  (double_E_0 < double_X)
  ? ((result ==  res0))
  : ((double_X <= Dneg(double_E_0)) && ((result ==  res1))) ;

predicate g_stable_paths(real X, double double_X)
= (! (0 < X) && !((0.0 < double_X))) || (0 < X && (0.0 < double_X)) ;
}
*/


/*@
requires 0 <= double_E_0;
assigns \nothing;

behavior structure:
ensures \result.isValid ==> g_trans_value(double_X, double_E_0, \result.value);

behavior stable_paths:
ensures \result.isValid
  ==> \forall real X;
  (
  \abs(double_X - X) <= double_E_0)
    ==> g_stable_paths(X, double_X);

behavior symbolic:
ensures \forall real X , E_X ;
\abs(X - double_X) <= E_X &&
(
\abs(double_X - X) <= double_E_0) &&
\result.isValid
==> \abs(\result.value - g(X)) <= \max(errAdd_dp(X, E_X, (X * 2), errMul_dp(X, E_X, 2, 0 % 1)) , errAdd_dp((X - 1), errSub_dp(X, E_X, 1, 0 % 1), ((X - 1) * 2), errMul_dp((X - 1), errSub_dp(X, E_X, 1, 0 % 1), 2, 0 % 1))) ;
*/
struct maybeDouble g_double (double double_X, double double_E_0) {
  struct maybeDouble res;
  if (double_E_0 < double_X)
  { struct maybeDouble aux_0 = f_double (double_X) ;
    if (aux_0.isValid)
    { res =  someDouble(aux_0.value);
    } else { res = noneDouble() ;
    }
  } else { if (double_X <= - (double_E_0))
           { struct maybeDouble aux_1 = f_double ((double_X - 1)) ;
             if (aux_1.isValid)
             { res =  someDouble(aux_1.value);
             } else { res = noneDouble() ;
             }
           } else { res = noneDouble() ;
           }
  }
return res;
}


/*@
ensures ( 0 <= X <= 100) &&
\result.isValid
==> \abs(\result.value - g(X)) <= 0x1.8p-44;
*/
struct maybeDouble g_num (double X) {
return g_double (X,0x1p-47);
}


int main () { return 0; }