// This file is automatically generated by PRECiSA 

#include<stdio.h>
#include<stdlib.h>
#include<math.h>
#include<string.h>
#include<stdbool.h>
#include"precisa_prelude.c"




/*@
axiomatic real_function_f {
logic real f (real X) =
0 < ((X * X) - 2) ? ((X + X)) : ((X - X));
}
*/


/*@ axiomatic f_trans {
predicate f_trans_value(double double_X, double double_E_0, double result)
= (double_E_0 < Dsub(Dmul(double_X, double_X), 2.0))
  ? (result ==  Dadd(double_X, double_X))
  : ((Dsub(Dmul(double_X, double_X), 2.0) <= Dneg(double_E_0)) && (result ==  Dsub(double_X, double_X))) ;

predicate f_stable_paths(real X, double double_X)
= (! (0 < ((X * X) - 2)) && !((0.0 < Dsub(Dmul(double_X, double_X), 2.0)))) || (0 < ((X * X) - 2) && (0.0 < Dsub(Dmul(double_X, double_X), 2.0))) ;
}
*/


/*@
requires 0 <= double_E_0;
assigns \nothing;

behavior structure:
ensures \result.isValid ==> f_trans_value(double_X, double_E_0, \result.value);

behavior stable_paths:
ensures \result.isValid
  ==> \forall real X;
  (
  \abs(Dsub(Dmul(double_X, double_X), 2.0) - ((X * X) - 2)) <= double_E_0)
    ==> f_stable_paths(X, double_X);

behavior symbolic:
ensures \forall real X , E_X ;
\abs(X - double_X) <= E_X &&
(
\abs(Dsub(Dmul(double_X, double_X), 2.0) - ((X * X) - 2)) <= double_E_0) &&
\result.isValid
==> \abs(\result.value - f(X)) <= \max(errAdd_dp(X, E_X, X, E_X) , errSub_dp(X, E_X, X, E_X)) ;
*/
struct maybeDouble f_double (double double_X, double double_E_0) {
  struct maybeDouble res;
  if (double_E_0 < ((double_X * double_X) - 2))
  { res =  someDouble((double_X + double_X));
  } else { if (((double_X * double_X) - 2) <= - (double_E_0))
           { res =  someDouble((double_X - double_X));
           } else { res = noneDouble() ;
           }
  }
return res;
}


/*@
ensures ( 0 <= X <= 100) &&
\result.isValid
==> \abs(\result.value - f(X)) <= 0x1p-45;
*/
struct maybeDouble f_num (double X) {
return f_double (X,0x1.c800000000001p-39);
}


/*@
axiomatic real_function_g {
logic real g (real X) =
0 < (X * X) ? (-(1)) : (f((X * X)));
}
*/


/*@ axiomatic g_trans {
predicate g_trans_value(double double_X, double double_E_0, double double_E_1, double result)
= \exists double res0; f_trans_value(Dmul(double_X, double_X), double_E_0, res0) &&
  (double_E_1 < Dmul(double_X, double_X))
  ? (result ==  Dneg(1.0))
  : ((Dmul(double_X, double_X) <= Dneg(double_E_1)) && ((result ==  res0))) ;

predicate g_stable_paths(real X, double double_X)
= ((! (0 < (((X * X) * (X * X)) - 2))) && (! (0 < (X * X))) && (!((0.0 < Dsub(Dmul(Dmul(double_X, double_X), Dmul(double_X, double_X)), 2.0))) && !((0.0 < Dmul(double_X, double_X))))) || ((0 < (((X * X) * (X * X)) - 2)) && (! (0 < (X * X))) && ((0.0 < Dsub(Dmul(Dmul(double_X, double_X), Dmul(double_X, double_X)), 2.0)) && !((0.0 < Dmul(double_X, double_X))))) || (0 < (X * X) && (0.0 < Dmul(double_X, double_X))) ;
}
*/


/*@
requires 0 <= double_E_0 && 0 <= double_E_1;
assigns \nothing;

behavior structure:
ensures \result.isValid ==> g_trans_value(double_X, double_E_0, double_E_1, \result.value);

behavior stable_paths:
ensures \result.isValid
  ==> \forall real X;
  (
  (!(0 < (double_X * double_X))
   ==>
   \abs(Dsub(Dmul(Dmul(double_X, double_X), Dmul(double_X, double_X)), 2.0) - (((X * X) * (X * X)) - 2)) <= double_E_0) &&
  \abs(Dmul(double_X, double_X) - (X * X)) <= double_E_1)
    ==> g_stable_paths(X, double_X);

behavior symbolic:
ensures \forall real X , E_X ;
\abs(X - double_X) <= E_X &&
(
(!(0 < (double_X * double_X))
 ==>
 \abs(Dsub(Dmul(Dmul(double_X, double_X), Dmul(double_X, double_X)), 2.0) - (((X * X) * (X * X)) - 2)) <= double_E_0) &&
\abs(Dmul(double_X, double_X) - (X * X)) <= double_E_1) &&
\result.isValid
==> \abs(\result.value - g(X)) <= \max(errNeg_dp(1, 0 % 1) , \max(errAdd_dp((X * X), errMul_dp(X, E_X, X, E_X), (X * X), errMul_dp(X, E_X, X, E_X)) , errSub_dp((X * X), errMul_dp(X, E_X, X, E_X), (X * X), errMul_dp(X, E_X, X, E_X)))) ;
*/
struct maybeDouble g_double (double double_X, double double_E_0, double double_E_1) {
  struct maybeDouble res;
  if (double_E_1 < (double_X * double_X))
  { res =  someDouble(- (1));
  } else { if ((double_X * double_X) <= - (double_E_1))
           { struct maybeDouble aux_0 = f_double ((double_X * double_X), double_E_0) ;
             if (aux_0.isValid)
             { res =  someDouble(aux_0.value);
             } else { res = noneDouble() ;
             }
           } else { res = noneDouble() ;
           }
  }
return res;
}


/*@
ensures ( 0 <= X <= 100) &&
\result.isValid
==> \abs(\result.value - g(X)) <= 0x1.c800000000001p-38;
*/
struct maybeDouble g_num (double X) {
return g_double (X,0x1.0832000000002p-24, 0x1.4800000000001p-39);
}


int main () { return 0; }