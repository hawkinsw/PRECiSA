// This file is automatically generated by PRECiSA 

#include<stdio.h>
#include<stdlib.h>
#include<math.h>
#include<string.h>
#include<stdbool.h>
#include"precisa_prelude.c"




/*@
axiomatic real_function_tcoa {
logic real tcoa (real S, real V) =
(S * V) < 0 ? (-((S / V))) : (0);
}
*/


/*@ axiomatic tcoa_trans {
predicate tcoa_trans_value(double double_S, double double_V, double double_E_0, double result)
= (Dmul(double_S, double_V) < Dneg(double_E_0))
  ? (result ==  Dneg(Ddiv(double_S, double_V)))
  : ((double_E_0 <= Dmul(double_S, double_V)) && (result ==  0.0)) ;

predicate tcoa_stable_paths(real S, real V, double double_S, double double_V)
= ((V != 0) && ((S * V) < 0) && ((double_V != 0) && (Dmul(double_S, double_V) < 0.0))) || (! ((S * V) < 0) && !((Dmul(double_S, double_V) < 0.0))) ;
}
*/


/*@
requires 0 <= double_E_0;
assigns \nothing;

behavior structure:
ensures \result.isValid ==> tcoa_trans_value(double_S, double_V, double_E_0, \result.value);

behavior stable_paths:
ensures \result.isValid
  ==> \forall real S, real V;
  (
  \abs(Dmul(double_S, double_V) - (S * V)) <= double_E_0)
    ==> tcoa_stable_paths(S, V, double_S, double_V);

behavior symbolic:
ensures \forall real S, real V , E_S, E_V ;
\abs(S - double_S) <= E_S && \abs(V - double_V) <= E_V &&
(
\abs(Dmul(double_S, double_V) - (S * V)) <= double_E_0) &&
\result.isValid
==> \abs(\result.value - tcoa(S, V)) <= \max(errNeg_dp((S / V), errDiv_dp(S, E_S, V, E_V)) , 0 % 1) ;
*/
struct maybeDouble tcoa_double (double double_S, double double_V, double double_E_0) {
  struct maybeDouble res;
  if ((double_S * double_V) < - (double_E_0))
  { res =  someDouble(- ((double_S / double_V)));
  } else { if (double_E_0 <= (double_S * double_V))
           { res =  someDouble(0);
           } else { res = noneDouble() ;
           }
  }
return res;
}


/*@
ensures ( 0 <= S <= 1000 && 1 <= V <= 200) &&
\result.isValid
==> \abs(\result.value - tcoa(S, V)) <= 0x1.9d8000000000dp-41;
*/
struct maybeDouble tcoa_num (double S, double V) {
return tcoa_double (S, V,0x1.6100000000001p-35);
}


/*@
axiomatic real_function_vmd {
logic real vmd (real S, real V) =
(S + (tcoa(S, V) * V));
}
*/


/*@ axiomatic vmd_trans {
predicate vmd_trans_value(double double_S, double double_V, double double_E_0, double result)
= \exists double res0; tcoa_trans_value(double_S, double_V, double_E_0, res0) &&
  (result ==  Dadd(double_S, Dmul(res0, double_V))) ;

predicate vmd_stable_paths(real S, real V, double double_S, double double_V)
= ((V != 0) && ((S * V) < 0) && ((double_V != 0) && (Dmul(double_S, double_V) < 0.0))) || (! ((S * V) < 0) && !((Dmul(double_S, double_V) < 0.0))) ;
}
*/


/*@
requires 0 <= double_E_0;
assigns \nothing;

behavior structure:
ensures \result.isValid ==> vmd_trans_value(double_S, double_V, double_E_0, \result.value);

behavior stable_paths:
ensures \result.isValid
  ==> \forall real S, real V;
  (
  \abs(Dmul(double_S, double_V) - (S * V)) <= double_E_0)
    ==> vmd_stable_paths(S, V, double_S, double_V);

behavior symbolic:
ensures \forall real S, real V , E_S, E_V ;
\abs(S - double_S) <= E_S && \abs(V - double_V) <= E_V &&
(
\abs(Dmul(double_S, double_V) - (S * V)) <= double_E_0) &&
\result.isValid
==> \abs(\result.value - vmd(S, V)) <= \max(errAdd_dp(S, E_S, (-((S / V)) * V), \max(errMul_dp(-((S / V)), \max(errNeg_dp((S / V), errDiv_dp(S, E_S, V, E_V)) , 0 % 1), V, E_V) , errMul_dp(0, \max(errNeg_dp((S / V), errDiv_dp(S, E_S, V, E_V)) , 0 % 1), V, E_V))) , errAdd_dp(S, E_S, (0 * V), \max(errMul_dp(-((S / V)), \max(errNeg_dp((S / V), errDiv_dp(S, E_S, V, E_V)) , 0 % 1), V, E_V) , errMul_dp(0, \max(errNeg_dp((S / V), errDiv_dp(S, E_S, V, E_V)) , 0 % 1), V, E_V)))) ;
*/
struct maybeDouble vmd_double (double double_S, double double_V, double double_E_0) {
  struct maybeDouble res;
  struct maybeDouble aux_0 = tcoa_double (double_S, double_V, double_E_0) ;
  if (aux_0.isValid)
  { res =  someDouble((double_S + (aux_0.value * double_V)));
  } else { res = noneDouble() ;
  }
return res;
}


/*@
ensures ( 0 <= S <= 1000 && 1 <= V <= 200) &&
\result.isValid
==> \abs(\result.value - vmd(S, V)) <= 0x1.37a7400000008p-38;
*/
struct maybeDouble vmd_num (double S, double V) {
return vmd_double (S, V,0x1.6100000000001p-35);
}


int main () { return 0; }