entrypoints Program;comment "%" ;token VarId       ( (upper) (letter | digit | '_' | '?')* ) ;token NonVarId    ( (lower) (letter | digit | '_' | '?' | '@')* ) ;{- Arithmetic Expressions -}separator nonempty AExpr "," ;coercions   AExpr 10 ;Add.        AExpr ::= AExpr "+" AExpr1 ;Sub.        AExpr ::= AExpr "-" AExpr1 ;Mul.        AExpr1 ::= AExpr1 "*" AExpr2 ;Div.        AExpr1 ::= AExpr1 "/" AExpr2 ;Pow.        AExpr2 ::= AExpr3 "^" AExpr2 ;Neg.        AExpr3 ::= "-" AExpr4 ;Floor.	    AExpr4 ::= "floor"  "(" AExpr ")" ;Sqrt.	    AExpr4 ::= "sqrt"   "(" AExpr ")" ;Abs.        AExpr4 ::= "abs"    "(" AExpr ")" ;Sin.        AExpr4 ::= "sin"    "(" AExpr ")" ;Cos.        AExpr4 ::= "cos"    "(" AExpr ")" ; Tan.        AExpr4 ::= "tan"    "(" AExpr ")" ; ASin.       AExpr4 ::= "asin"   "(" AExpr ")" ;ACos.       AExpr4 ::= "acos"   "(" AExpr ")" ;ATan.       AExpr4 ::= "atan"   "(" AExpr ")" ;Ln.         AExpr4 ::= "ln"     "(" AExpr ")" ;Exp.        AExpr4 ::= "exp"    "(" AExpr ")" ;Mod1.       AExpr4 ::= "mod"     "(" AExpr "," AExpr ")" ;Mod2.       AExpr4 ::= "mod.mod" "(" AExpr "," AExpr ")" ;ArrayElem.  AExpr5 ::= VarId "(" AExpr ")" ;FCallN.     AExpr6 ::= NonVarId "(" [AExpr] ")" ;FCall0.     AExpr6 ::= NonVarId ;RtoS.       AExpr7 ::= "RtoS" "(" AExpr8 ")" ;RtoD.       AExpr7 ::= "RtoD" "(" AExpr8 ")" ;ItoS.       AExpr8 ::= "ItoS" "(" AExpr8 ")" ;ItoD.       AExpr8 ::= "ItoD" "(" AExpr8 ")" ;Pi1.        AExpr9 ::= "pi" ;Pi2.        AExpr9 ::= "PI" ;Int.        AExpr9 ::= Integer ;Rat.        AExpr9 ::= Double ;Var.        AExpr9 ::= VarId ;{- Boolean Expression (on FP expressions) -}coercions   BExpr 5 ;Or.         BExpr ::= BExpr "OR" BExpr1 ;And.        BExpr1 ::= BExpr1 "AND" BExpr2 ;Not.        BExpr2 ::= "NOT" BExpr3 ;Eq.         BExpr3 ::= AExpr "="  AExpr ;Neq.        BExpr3 ::= AExpr "/=" AExpr ;Lt.         BExpr3 ::= AExpr "<"  AExpr ;LtE.        BExpr3 ::= AExpr "<=" AExpr ;Gt.         BExpr3 ::= AExpr ">"  AExpr ;GtE.        BExpr3 ::= AExpr ">=" AExpr ;BTrue.      BExpr4 ::= "TRUE" ;BFalse.     BExpr4 ::= "FALSE" ;{- PVS Program -}TypeReal.         Type ::= "real";TypeInt.          Type ::= "int" ;TypeInteger.      Type ::= "integer" ;TypePosNat.       Type ::= "posnat" ;TypeBelow.        Type ::= "below" "(" Integer ")" ;TypeArrayInteger. Type ::= "ARRAY" "[" "integer" "->" Type "]" ;TypeArrayInt.     Type ::= "ARRAY" "[" "int" "->" Type "]" ;TypeArrayBelow.   Type ::= "ARRAY" "[" "below" "(" AExpr ")" "->" Type "]" ;SubrageType.   Subrange ::= "subrange" "(" Integer "," Integer ")" ;separator nonempty Arg "," ;FArg.         Arg ::= [VarId] ":" Type ;FArgSubrange. Arg ::= [VarId] ":" Subrange ;FArgGuard.    Arg ::= [VarId] ":" Type "|" BExpr  ;FArgNoType.   Arg ::= VarId ;FArgs. Args ::= [Arg] ;separator nonempty VarId "," ;ElsIf.      ElsIf ::= "ELSIF" BExpr "THEN" Stm ;separator nonempty ElsIf "" ;coercions   Stm 5 ;LetWithType. Stm  ::= "LET" VarId ":" Type "=" AExpr "IN" Stm ;Let.         Stm  ::= "LET" VarId "=" AExpr "IN" Stm ;If.          Stm1 ::= "IF" BExpr "THEN" Stm "ELSE" Stm "ENDIF" ;ListIf.      Stm2 ::= "IF" BExpr "THEN" Stm [ElsIf] "ELSE" Stm "ENDIF" ;For.         Stm3 ::= "for" "[" Type "]" "(" AExpr "," AExpr "," AExpr ","  "LAMBDA" "("  VarId ":" "subrange" "(" AExpr "," AExpr ")"  "," VarId ":"  Type ")" ":" Stm ")" ;Expr.        Stm4 ::= AExpr ;UnstWarning. Stm5 ::= "warning" ;separator nonempty Decl "" ;DeclN.    Decl ::= NonVarId "(" Args ")" ":" Type "=" Stm ;DeclRec.  Decl ::= NonVarId "(" Args ")" ":" "RECURSIVE" Type "=" Stm ;Decl0.    Decl ::= NonVarId ":" Type "=" Stm  ;separator nonempty NonVarId "," ;LibImp.   Imp ::= "IMPORTING" [NonVarId] ;VarDeclaration. VarDecl ::= VarId ":" "VAR" Type ;separator VarDecl "" ;Prog.    Program ::= NonVarId ":" "THEORY" "BEGIN" Imp [VarDecl] [Decl] "END" NonVarId ; ProgImp. Program ::= NonVarId ":" "THEORY" "BEGIN" [VarDecl] [Decl] "END" NonVarId;