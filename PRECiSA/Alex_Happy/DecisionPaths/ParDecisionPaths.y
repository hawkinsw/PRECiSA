-- This Happy file was machine-generated by the BNF converter
{
{-# OPTIONS_GHC -fno-warn-incomplete-patterns -fno-warn-overlapping-patterns #-}
module ParDecisionPaths where
import AbsPVSLang (VarId(..), NonVarId(..))
import Common.DecisionPath
import LexDecisionPaths
import ErrM

}

%name pTargetDPs TargetDPs
-- no lexer declaration
%monad { Err } { thenM } { returnM }
%tokentype {Token}
%token
  '(' { PT _ (TS _ 1) }
  ')' { PT _ (TS _ 2) }
  ',' { PT _ (TS _ 3) }
  ':' { PT _ (TS _ 4) }
  'All' { PT _ (TS _ 5) }
  'None' { PT _ (TS _ 6) }
  '[' { PT _ (TS _ 7) }
  ']' { PT _ (TS _ 8) }

L_integ  { PT _ (TI $$) }
L_VarId { PT _ (T_VarId $$) }
L_NonVarId { PT _ (T_NonVarId $$) }


%%

Integer :: { Integer } : L_integ  { (read ( $1)) :: Integer }
VarId    :: { VarId} : L_VarId { VarId ($1)}
NonVarId    :: { NonVarId} : L_NonVarId { NonVarId ($1)}

Decision :: { Integer }
Decision : Integer { $1 }

ListDecision :: { [Integer] }
ListDecision : {- empty -} { [] }
             | Decision { (:[]) $1 }
             | Decision ',' ListDecision { $3 ++ ($1:[]) }

DecisionPath :: { LDecisionPath }
DecisionPath : '[' ListDecision ']' { LDP $2 }

ListDecisionPath :: { [LDecisionPath] }
ListDecisionPath : {- empty -} { [] }
                 | DecisionPath { (:[]) $1 }
                 | DecisionPath ',' ListDecisionPath { (:) $1 $3 }

DecisionPaths :: { [LDecisionPath] }
DecisionPaths : ListDecisionPath { $1 }
              | 'All' { [LDP []] }
              | 'None' { [] }

ListVarId :: { [VarId] }
ListVarId : VarId { (:[]) $1 } | VarId ',' ListVarId { (:) $1 $3 }

DecPathBind :: { (String, [LDecisionPath]) }
DecPathBind : NonVarId '(' ListVarId ')' ':' DecisionPaths { buildDecisionPaths $1 $6 }
            | NonVarId ':' DecisionPaths { buildDecisionPaths $1 $3 }

ListDecPathBind :: { [(String, [LDecisionPath])] }
ListDecPathBind : DecPathBind { (:[]) $1 }
                | DecPathBind ListDecPathBind { (:) $1 $2 }

TargetDPs :: { TargetDPs }
TargetDPs : ListDecPathBind { $1 }

{
buildDecisionPaths  :: NonVarId -> [LDecisionPath] -> (String, [LDecisionPath])
buildDecisionPaths (NonVarId fun) dps = (fun, dps)

rawparserTargetDPs :: String -> Err TargetDPs
rawparserTargetDPs = pTargetDPs . tokens

returnM :: a -> Err a
returnM = return

thenM :: Err a -> (a -> Err b) -> Err b
thenM = (>>=)

happyError :: [Token] -> Err a
happyError ts =
  Bad $ "syntax error at " ++ tokenPos ts ++ 
  case ts of
    [] -> []
    [Err _] -> " due to lexer error"
    _ -> " before " ++ unwords (map (id . prToken) (take 4 ts))

myLexer = tokens
}

