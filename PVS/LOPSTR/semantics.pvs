semantics[
  Operator            : TYPE+,
  RealNumber          : TYPE+,
  lt_r                : (strict_total_order?[RealNumber]),
  applyFun_r          : [[Operator,RealNumber,RealNumber]->RealNumber],
  FloatingPointNumber : TYPE+,
  lt_fp               : (strict_total_order?[FloatingPointNumber]),
  applyFun_fp         : [[Operator,FloatingPointNumber,FloatingPointNumber]->FloatingPointNumber],
  FtoR 		      : [FloatingPointNumber -> RealNumber]
]: THEORY BEGIN

  ASSUMING
  
    X,Y: VAR FloatingPointNumber
    rX,rY: VAR RealNumber
  
    lt_fp_lt_r
    : ASSUMPTION
      lt_fp(X,Y) = lt_r(FtoR(X),FtoR(Y))
      
  ENDASSUMING

  IMPORTING expressions_semantics[Operator,RealNumber,lt_r,applyFun_r,FloatingPointNumber,lt_fp,applyFun_fp,FtoR]
  IMPORTING program[Operator,RealNumber,FloatingPointNumber,FtoR]
  IMPORTING domain[Operator,RealNumber,lt_r,applyFun_r,FloatingPointNumber,lt_fp,applyFun_fp,FtoR]

  IMPORTING structures@more_list_props
  IMPORTING structures@listn
  IMPORTING sets_aux@more_set_props

  local               : VAR (FPVariable?)
  fpParamEnv          : VAR FPEnvironment
  fpLocalEnv,fpLocalEnv1,fpLocalEnv2 : VAR FPLocalEnvironment
  rLocalEnv           : VAR RLocalEnvironment
  stmt                : VAR FPStmt
  rform               : VAR RBExpr
  rexpr,rexpr1,rexpr2 : VAR RAExpr

  % A statement can be evaluated using a local environment, if every arithmetic
  % and boolean expression appearing in the statement can be evaluated on the
  % given environment.

  bounded_by?(fpLocalEnv : FPLocalEnvironment)(stmt: FPStmt)
  : bool
  = EXISTS(n: nat): wellFormed?(stmt,n,size(fpLocalEnv))

  % evaluable properties on statements

  evaluable_in_stmt_wellformed_eq: LEMMA
  FORALL (env: FPLocalEnvironment)(stmt: FPStmt)
  : bounded_by?(env)(stmt) = (EXISTS(n:nat): wellFormed?(stmt,n,size(env)))

  fp_evaluable_in_stmt_evaluable_letin_expr
  : LEMMA
    FORALL(fpLocalEnv : FPLocalEnvironment,aexpr: FPAExpr, body: FPStmt)
    : bounded_by?(fpLocalEnv)(LETIN(aexpr, body))
      IMPLIES bounded_by?(fpLocalEnv)(aexpr)

  body : VAR FPStmt

  fp_evaluable_in_stmt_evaluable_letin_body: LEMMA
    FORALL(fpLocalEnv,(aexpr: (fp_local_env.bounded_by?(fpLocalEnv))), body):
      bounded_by?(fpLocalEnv)(LETIN(aexpr, body))
      IMPLIES bounded_by?(cons(aexpr,fpLocalEnv))(body)

  fp_evaluable_in_stmt_evaluable_ite: LEMMA
    FORALL(fpLocalEnv : FPLocalEnvironment,ite:(IfThenElse?)):
      bounded_by?(fpLocalEnv)(ite)
      IMPLIES bounded_by?(fpLocalEnv)(guard(ite))

  r_evaluable_in_stmt_evaluable_ite: LEMMA
    FORALL( fpLocalEnv : FPLocalEnvironment,
    	    rLocalEnv  : RLocalEnvironment |
	                   consistentLocalEnvironments?(fpLocalEnv,rLocalEnv),
    	    ite:(IfThenElse?)):
      bounded_by?(fpLocalEnv)(ite)
      IMPLIES bounded_by?(rLocalEnv)(FtoR(guard(ite)))

  fp_evaluable_in_stmt_evaluable_ite_then: LEMMA
    FORALL(fpLocalEnv : FPLocalEnvironment,ite:(IfThenElse?)):
      bounded_by?(fpLocalEnv)(ite)
      IMPLIES bounded_by?(fpLocalEnv)(thenBranch(ite))

  fp_evaluable_in_stmt_evaluable_ite_else: LEMMA
    FORALL(fpLocalEnv : FPLocalEnvironment,ite:(IfThenElse?)):
      bounded_by?(fpLocalEnv)(ite)
      IMPLIES bounded_by?(fpLocalEnv)(elseBranch(ite))
		
  pgm_is_evaluable_in_empty_eng: LEMMA
    FORALL(pgm: (wellFormedProgram?)): bounded_by?(FPEmptyLocalEnv)(body(pgm))

  %------------------------------------------------------------%
  %                                                            %
  % Basic types for defining the semantics                     %
  %                                                            %
  %------------------------------------------------------------%

  Environment : TYPE+ = list[Domain]

  env  : VAR Environment
  dom  : VAR Domain
  
  get_from_semantic_environment_monotonocity
  : LEMMA
    FORALL(idx: below(length(env)))
    : nth(cons(dom, env), length(cons(dom,env)) - (idx+1)) = nth(env,length(env)-(idx+1))

  appears?(env)(local): bool
  = EXISTS(dom: Domain | member(dom,env))
    : appears?(dom)(local)

  appears?_env_int_def
  : LEMMA
    appears?(env)(local) = EXISTS(dom: Domain | member(dom,env)) : appears?(dom)(local)

  %

  PairCEB     : TYPE+ = listn[CEB](2)
  TripleCEB   : TYPE+ = listn[CEB](3)

  makePairCEB(c1,c2: CEB): PairCEB = (: c1, c2 :)

  nargs, nlocals: VAR nat
  index : VAR nat

  JUDGEMENT length[CEB](p: PairCEB) HAS_TYPE above(1)

  wellFormed?(env:Environment, nargs, localsCount:nat)
  : RECURSIVE bool
  = null?(env)
    OR ( wellFormed?(car(env),nargs,localsCount) AND
       	 wellFormed?(cdr(env),nargs,localsCount) )
  MEASURE env BY <<

  wellFormed?_env_ext: LEMMA
    wellFormed?(env, nargs, nlocals) AND
    wellFormed?(dom, nargs, nlocals)
    IMPLIES wellFormed?(cons(dom,env),nargs,nlocals)

  wellFormed?_decl: LEMMA
  FORALL(env:Environment, nargs, localsCount:nat)
  : wellFormed?(env, nargs, localsCount)
    IFF FORALL(i: below(length(env))): wellFormed?(nth(env,i), nargs, localsCount)

  wellFormed?_env_monotonocity: LEMMA
    wellFormed?(env, nargs, nlocals)
    IMPLIES FORALL(n: upfrom(nargs), m: upfrom(nlocals)): wellFormed?(env, n, m)

  emptyEnv : Environment = (::)

  %------------------------------------------------------------%
  %                                                            %
  % Auxiliary predicates                                       %
  %                                                            %
  %------------------------------------------------------------%

  ceb  : VAR CEB
  expr : VAR FPAExpr
  
  maxFreeLocalIndex(env)
  : RECURSIVE upfrom(-1)
  = CASES env OF
      null: -1,
      cons(dom,rest): max(maxFreeLocalIndex(dom),maxFreeLocalIndex(rest))
    ENDCASES
  MEASURE env BY <<

  max_local_index_env_ge_dom
  : LEMMA
    FORALL(dom)
    : member(dom,env) IMPLIES maxFreeLocalIndex(dom) <= maxFreeLocalIndex(env)

  max_local_index_ceb_leq_max_local_index_env
  : LEMMA
    FORALL(dom|member(dom,env), ceb : (dom))
    : maxFreeLocalIndex(env) >= maxFreeLocalIndex(ceb)

  max_local_index_env_def
  : LEMMA
    maxFreeLocalIndex(cons(dom,env)) = max(maxFreeLocalIndex(dom),maxFreeLocalIndex(env))

  %

  maxParamIndex(env)
  : RECURSIVE upfrom(-1)
  = CASES env OF
      null: -1,
      cons(dom,rest): max(maxParamIndex(dom),maxParamIndex(rest))
    ENDCASES
  MEASURE env BY <<

  max_local_index_env_well_formed_eq
  : LEMMA
    ( maxFreeLocalIndex(env) < nlocals AND maxParamIndex(env) < nargs )
    = wellFormed?(env,nargs,nlocals)

  %
  %
  %
  
  stableConsistent?(ceb: CEB): bool =
      stable?(ceb)
    IMPLIES
      FORALL(
        fpParamEnv: FPEnvironment,
        rParamEnv : REnvironment | FtoR(fpParamEnv) = rParamEnv,
        fpLocalEnv: FPLocalEnvironment | bounded_by?(fpLocalEnv)(fpconds(ceb)),
        rLocalEnv : RLocalEnvironment
	| FtoR(fpLocalEnv) = rLocalEnv AND bounded_by?(rLocalEnv)(rconds(ceb))
      ):
        val(rParamEnv,rLocalEnv)(rconds(ceb)) = val(fpParamEnv,fpLocalEnv)(fpconds(ceb))

  stableConsistent?(dom: Domain): bool =
    FORALL(ceb: (dom)): stableConsistent?(ceb)

  stableConsistent?(env: Environment): bool =
    FORALL(dom: Domain | member(dom,env)): stableConsistent?(dom)


  bottomLess?(ceb:         CEB) : bool = rresult(ceb) /= RBottom AND fpresult(ceb) /= FPBottom
  bottomLess?(dom:      Domain) : bool = FORALL(ceb: (dom)): bottomLess?(ceb)
  bottomLess?(env: Environment) : bool = FORALL(dom: Domain | member(dom,env)): bottomLess?(dom)

  stable?(ceb:         CEB) : bool = stable?(ceb)
  stable?(dom:      Domain) : bool = FORALL(ceb: (dom)): stable?(ceb)
  stable?(env: Environment) : bool = FORALL(dom: Domain | member(dom,env)): stable?(dom)

  %------------------------------------------------------------%
  %                                                            %
  % Auxiliary semantic functions                               %
  %                                                            %
  %------------------------------------------------------------%

  fne: VAR (finite_nonempty?[PairCEB])

  cartesian_product_elem_set(ceb,dom)
  : RECURSIVE { fne | fne = { p : PairCEB | nth(p,0)=ceb AND member(nth(p,1),dom) } }
  = IF empty?(rest(dom)) THEN singleton(makePairCEB(ceb,choose(dom)))
    ELSE add(makePairCEB(ceb,choose(dom)),cartesian_product_elem_set(ceb,rest(dom))) ENDIF
  MEASURE card(dom)

  cartesian_product(dom1,dom2:Domain)
  : RECURSIVE { fne | fne = { p : PairCEB | member(nth(p,0),dom1) AND member(nth(p,1),dom2) } }
  = IF empty?(rest(dom1)) THEN cartesian_product_elem_set(choose(dom1),dom2)
    ELSE union( cartesian_product_elem_set(choose(dom1),dom2) ,
    	 	cartesian_product(rest(dom1),dom2) ) ENDIF
  MEASURE card(dom1)

  dom1,dom2: VAR Domain

  cartesian_product_intensional_def
  : LEMMA
    cartesian_product(dom1,dom2) = { p : PairCEB | member(nth(p,0),dom1) AND member(nth(p,1),dom2) }

  create_new_CEB(op:Operator)(ceb1,ceb2:CEB): CEB
  = LET newRealCondition = RAnd(rconds(ceb1),rconds(ceb2)) ,
        newFPCondition   = FPAnd(fpconds(ceb1),fpconds(ceb2)),
      	newRealResult    :
	RAExprDomain
	= CASES rresult(ceb1) OF
            RAExpr(result1): CASES rresult(ceb2) OF
                               RAExpr(result2): RAExpr(ROperator(op,result1,result2))
                               ELSE RBottom
                             ENDCASES
	    ELSE RBottom
	  ENDCASES,
        newFPResult: FPAExprDomain
	= CASES fpresult(ceb1) OF
            FPAExpr(result1): CASES fpresult(ceb2) OF
                                FPAExpr(result2): FPAExpr(FPOperator(op,result1,result2))
                                ELSE FPBottom
                              ENDCASES
            ELSE FPBottom
          ENDCASES
    IN make_ceb( newRealCondition, newFPCondition,
        	 newRealResult,	   newFPResult,
        	 TRUE )

  %------------------------------------------------------------%
  %                                                            %
  % Arithmetic expression semantic function                    %
  %                                                            %
  %------------------------------------------------------------%

  conditionsHold?(ceb: CEB) : bool =
   FORALL( fpParamEnv : FPEnvironment,
	   fpLocalEnv : FPLocalEnvironment | bounded_by?(fpLocalEnv)(fpconds(ceb)),
   	   rLocalEnv  : RLocalEnvironment |
	     consistentLocalEnvironments?(fpLocalEnv,rLocalEnv) AND
	     bounded_by?(rLocalEnv)(rconds(ceb))):
    val(fpParamEnv,fpLocalEnv)(fpconds(ceb)) AND val(FtoR(fpParamEnv),rLocalEnv)(rconds(ceb))
    
  conditionsHold?(dom:      Domain) : bool =
    FORALL(ceb: (dom)): conditionsHold?(ceb)
    
  conditionsHold?(env: Environment) : bool =
    FORALL(dom: Domain | member(dom,env)): conditionsHold?(dom)

  %

  NoFreeVars?(dom): MACRO bool
  = FORALL(local: (FPVariable?)): NOT appears?(dom)(local)

  % A Domain is considered "valid" when all its elements (CEB) fulfill
  % - conditionsHold?
  % - bottomLess?, and
  % - stable?

  validDomain(dom:Domain): bool
  =  bottomLess?(dom)        AND
     stable?(dom)     	     AND
     conditionsHold?(dom) AND
     NoFreeVars?(dom)

  valid_domain_assures_conditions_hold: LEMMA
    FORALL(dom: (validDomain)): conditionsHold?(dom)

  valid_domain_assures_bottomless: LEMMA
    FORALL(dom: (validDomain)): bottomLess?(dom)

  valid_domain_assures_stable: LEMMA
    FORALL(dom: (validDomain)): stable?(dom)

  belongsToDom(dom:Domain)(ceb:CEB): MACRO bool
  = dom(ceb)

  valid_domain__ceb_stable: LEMMA
    FORALL(dom: (validDomain), ceb: (belongsToDom(dom))):
      stable?(ceb)

  valid_domain__ceb_bottomless: LEMMA
    FORALL(dom: (validDomain), ceb: (belongsToDom(dom))):
      bottomLess?(ceb)

  valid_domain__ceb_conditions_hold: LEMMA
    FORALL(dom: (validDomain), ceb: (belongsToDom(dom))):
      conditionsHold?(ceb)

  %

  NoFreeVars?(env): MACRO bool
  = FORALL(local: (FPVariable?)): NOT appears?(env)(local)

  %
  % validEnvironmentForStmt
  %
  
  validEnvironmentForStmt(env:Environment): bool
  =  bottomLess?(env)        AND
     stable?(env)     	     AND
     conditionsHold?(env) AND
     NoFreeVars?(env)        

  % Domains could have free variables, but if they are semantic counterparts of arithmetic
  % expressions from a valid program, they can not have any free variable.
  validEnvironmentForStmt_no_free_var
  : LEMMA
    FORALL(env: (validEnvironmentForStmt)): NOT appears?(env)(local)

  valid_environment_assures_conditions_hold: LEMMA
    FORALL(env: (validEnvironmentForStmt)): conditionsHold?(env)

  valid_environment_assures_stable: LEMMA
    FORALL(env: (validEnvironmentForStmt)): stable?(env)

  valid_environment_assures_bottomless: LEMMA
    FORALL(env: (validEnvironmentForStmt)): bottomLess?(env)
 
  empty_env_is_valid: LEMMA
    validEnvironmentForStmt(emptyEnv)
  AUTO_REWRITE+ empty_env_is_valid

  empty_env_is_wellFormed?: LEMMA
    wellFormed?(emptyEnv,nargs,nlocals)
  AUTO_REWRITE+ empty_env_is_wellFormed?

  %
  % Semantic function
  %

  sem(aexpr: FPAExpr,
      nargs:nat,
      env: (validEnvironmentForStmt) | wellFormed?(aexpr,nargs,length(env)))
  : RECURSIVE (validDomain)
  = CASES aexpr OF
      FPConstant(fpConstant): singleton(make_ceb( RTrue,
	                                	  FPTrue,
                                          	  FtoR(FPAExpr(aexpr)),
                                          	  FPAExpr(aexpr),
                                          	  true )),
      FPVariable(v)         : nth(env,v),
      FPParameter(v)        : singleton(make_ceb( RTrue,
            		      			  FPTrue,
						  FtoR(FPAExpr(aexpr)),
            					  FPAExpr(aexpr),
            					  true )),
      FPOperator(op,arg1,arg2):
        LET sem_arg1 = sem(arg1,nargs,env),
            sem_arg2 = sem(arg2,nargs,env),
            combinations = cartesian_product(sem_arg1, sem_arg2)
        IN map[PairCEB,CEB]
	    (LAMBDA(p:PairCEB): create_new_CEB(op)(nth(p,0),nth(p,1)))
	    (combinations)
    ENDCASES
  MEASURE aexpr BY <<

  fpnum : VAR FPNumber
  i_var : VAR DeBruijnIndex
  i     : VAR nat
  op    : VAR Operator
  expr1,
  expr2 : VAR FPAExpr

  % Intensional definition lemmas

  sem_expr_var_fpconds: LEMMA
  FORALL(env: (validEnvironmentForStmt) | wellFormed?(FPVariable(i_var),nargs,length(env)))
  : sem(FPVariable(i_var), nargs, env)(ceb) IFF nth(env,i_var)(ceb)

  sem_expr_cnt_fpconds: LEMMA
  FORALL(env: (validEnvironmentForStmt) | wellFormed?(FPConstant(fpnum),nargs,length(env)))
  : sem(FPConstant(fpnum), nargs, env)(ceb) IMPLIES fpconds(ceb) = FPTrue

  sem_expr_par_fpconds: LEMMA
  FORALL(env: (validEnvironmentForStmt) | wellFormed?(FPParameter(i),nargs,length(env)))
  : sem(FPParameter(i), nargs, env)(ceb) IMPLIES fpconds(ceb) = FPTrue

  sem_expr_opr_fpconds
  : LEMMA
    FORALL( env: (validEnvironmentForStmt) |
    	   wellFormed?(FPOperator(op,expr1,expr2),nargs,length(env)) )
    : sem(FPOperator(op,expr1,expr2), nargs, env)(ceb)
      IMPLIES EXISTS(ceb1:(sem(expr1,nargs,env)),ceb2:(sem(expr2,nargs,env)))
      	    : fpconds(ceb) = FPAnd(fpconds(ceb1),fpconds(ceb2))

  sem_expr_opr_rconds
  : LEMMA
    FORALL( env: (validEnvironmentForStmt) |
    	     wellFormed?(FPOperator(op,expr1,expr2),nargs,length(env)) )
    : sem(FPOperator(op,expr1,expr2), nargs, env)(ceb)
      IMPLIES EXISTS(ceb1:(sem(expr1,nargs,env)),ceb2:(sem(expr2,nargs,env)))
      	    : rconds(ceb) = RAnd(rconds(ceb1),rconds(ceb2))

  %

  sem_expr_does_not_add_vars_to_ceb
  : LEMMA
    FORALL(env    : (validEnvironmentForStmt),
           expr   | wellFormed?(expr,nargs,length(env)))
    : appears?(sem(expr,nargs,env))(local) IMPLIES appears?(env)(local)

  %

  max_local_index_aexpr: LEMMA
  FORALL(env: (validEnvironmentForStmt) | wellFormed?(expr,nargs,length(env)))
  : maxFreeLocalIndex(sem(expr,nargs,env)) <= maxFreeLocalIndex(env)

  well_formed_env_implies_well_formed_sem_aexpr: LEMMA
  FORALL(env: (validEnvironmentForStmt)):
    wellFormed?(expr,nargs,length(env)) AND
    wellFormed?(env, nargs, nlocals)
    IMPLIES wellFormed?(sem(expr,nargs,env), nargs, nlocals)

  IMPORTING structures@more_list_props

  max_local_index_ceb_aexpr_cond: LEMMA
  FORALL(env: (validEnvironmentForStmt) | wellFormed?(expr,nargs,length(env)))
  : sem(expr, nargs, env)(ceb)
    IMPLIES maxFreeLocalIndex(fpconds(ceb)) <= max(maxFreeLocalIndex(expr), maxFreeLocalIndex(env))

  valid_environment_extension: LEMMA
    FORALL(nargs:nat, env:Environment, dom: Domain):
      validEnvironmentForStmt(env) AND
      validDomain(dom)
      IMPLIES validEnvironmentForStmt(cons(dom,env))

  valid_environment_shortening
  : LEMMA
    FORALL(n: nat)
    : validEnvironmentForStmt(env)
      IMPLIES validEnvironmentForStmt(takeFromRight(env,n))

  % specific version of the previous lemma used in several proofs
  valid_environment_ext: COROLLARY
    FORALL( env   : (validEnvironmentForStmt),
    	    nargs : nat,
	    aexpr : FPAExpr | wellFormed?(aexpr,nargs,length(env)) ):
      validEnvironmentForStmt(cons(sem(aexpr, nargs, env),env))

  sem_fpaexpr_is_stable : LEMMA
    FORALL( nargs : nat,
            expr  : FPAExpr,
            env   : (validEnvironmentForStmt) | wellFormed?(expr,nargs,length(env)),
            ceb   : (sem(expr,nargs,env))):
     stable?(ceb)

  sem_fpaexpr_is_bottomless : LEMMA
    FORALL( nargs : nat,
            expr  : FPAExpr,
            env   : (validEnvironmentForStmt) | wellFormed?(expr,nargs,length(env)),
            ceb   : (sem(expr,nargs,env))):
     bottomLess?(ceb)

  sem_fpaexpr_conditions_hold : LEMMA
    FORALL( nargs : nat,
            expr  : FPAExpr,
            env	  : (validEnvironmentForStmt) | wellFormed?(expr,nargs,length(env)),
            ceb	  : (sem(expr,nargs,env))):
     conditionsHold?(ceb)

  sem_fpaexpr_is_valid_domain: LEMMA
    FORALL(expr  : FPAExpr,
           nargs : nat,
      	   env   : (validEnvironmentForStmt) | wellFormed?(expr,nargs,length(env))):
      validDomain(sem(expr, nargs, env))

  %------------------------------------------------------------%
  %                                                            %
  % Program Semantics					       %
  %                                                            %
  %------------------------------------------------------------%

  belongsToEnv(env:Environment)(ceb:CEB): bool
  = EXISTS (i: below(length(env))): nth(env, i)(ceb)

  valid_env_for_stmt__stable: LEMMA
    FORALL(st: FPStmt, nargs:nat, env:Environment):
      validEnvironmentForStmt(env)
      IMPLIES FORALL(ceb: (belongsToEnv(env))): stable?(ceb)

  valid_env_for_stmt__conditions_hold: LEMMA
    FORALL(st: FPStmt, nargs:nat, env:Environment):
      validEnvironmentForStmt(env)
      IMPLIES FORALL(ceb: (belongsToEnv(env))): conditionsHold?(ceb)

  IMPORTING expressions_props[Operator,RealNumber,FloatingPointNumber,FtoR] % needed to prove TCCs

  %
  % 
  %

  form,form1,form2  : VAR FPBExpr

  replace_local_var(expr: FPAExpr)(replacement: FPAExpr)
  : RECURSIVE FPAExpr
  = CASES expr OF
      FPVariable(idx)           : IF idx=0 THEN replacement ELSE FPVariable(idx-1) ENDIF,
      FPOperator(op,expr1,expr2): FPOperator( op,
      				  	      replace_local_var(expr1)(replacement),
      			  		      replace_local_var(expr2)(replacement) )
      ELSE expr
    ENDCASES
  MEASURE expr BY <<

  replace_local_var(expr: RAExpr)(replacement: RAExpr)
  : RECURSIVE RAExpr
  = CASES expr OF
      RVariable(idx)           : IF idx=0 THEN replacement ELSE RVariable(idx-1) ENDIF,
      ROperator(op,expr1,expr2): ROperator( op,
      				  	      replace_local_var(expr1)(replacement),
      			  		      replace_local_var(expr2)(replacement) )
      ELSE expr
    ENDCASES
  MEASURE expr BY <<

  % Properties

  max_local_index_expr_replaced_var
  : LEMMA
    maxFreeLocalIndex(replace_local_var(expr1)(expr2)) <=
      max(maxFreeLocalIndex(expr2), maxFreeLocalIndex(expr1)-1)

  replace_local_var_in_fpexpr_evaluable_in
  : LEMMA
    FORALL( fpLocalEnv : FPLocalEnvironment,
    	    expr1      : FPAExpr | bounded_by?(fpLocalEnv)(expr1) )
    : bounded_by?(cons(expr1, fpLocalEnv))(expr2)
      = bounded_by?(fpLocalEnv)(replace_local_var(expr2)(expr1))

  replace_local_var_in_rexpr_evaluable_in
  : LEMMA
    FORALL( expr2     : RAExpr,
    	    rLocalEnv : RLocalEnvironment,
    	    expr1     : FPAExpr | bounded_by?(rLocalEnv)(FtoR(expr1)))
    : bounded_by?(cons(FtoR(expr1), rLocalEnv))(expr2)
      = bounded_by?(rLocalEnv)(replace_local_var(expr2)(FtoR(expr1)))

  replace_local_var_in_fpexpr_val
  : LEMMA
    FORALL( fpLocalEnv : FPLocalEnvironment,
	    expr1      : FPAExpr | bounded_by?(fpLocalEnv)(expr1),
	    expr2 | bounded_by?(cons(expr1,fpLocalEnv))(expr2)  )
    : eval(fpParamEnv, cons(expr1, fpLocalEnv))(expr2)
      = eval(fpParamEnv, fpLocalEnv)(replace_local_var(expr2)(expr1))

  rParamEnv: VAR REnvironment

  replace_local_var_in_rexpr_val
  : LEMMA
    FORALL( rLocalEnv : RLocalEnvironment,
	    expr1     : FPAExpr | bounded_by?(rLocalEnv)(FtoR(expr1)),
	    expr2     : RAExpr | bounded_by?(cons(FtoR(expr1),rLocalEnv))(expr2)  )
    : eval(rParamEnv, cons(FtoR(expr1), rLocalEnv))(expr2)
      = eval(rParamEnv, rLocalEnv)(replace_local_var(expr2)(FtoR(expr1)))

  var_appears_in_replaced_expr_dec_var_appears_in_orig_expr
  : LEMMA
    appears?(replace_local_var(expr2)(expr1))(FPVariable(i_var))
    IMPLIES ( appears?(expr2)(FPVariable(i_var+1)) OR appears?(expr1)(FPVariable(i_var)) )

  var_appears_in_replaced_rexpr_dec_var_appears_in_orig_rexpr
  : LEMMA
    appears?(replace_local_var(rexpr2)(rexpr1))(RVariable(i_var))
    IMPLIES ( appears?(rexpr2)(RVariable(i_var+1)) OR appears?(rexpr1)(RVariable(i_var)) )

  %
  % Replace all locals
  %

  eld_post_eval_ftor( fpLocalEnv,
   		      (expr | bounded_by?(fpLocalEnv)(expr)),
		      (res: FPAExpr | NoLocalVars?(res)) )
  : bool
  = ( FORALL(fpParamEnv, fpLocalEnv2)
			         : eval(FtoR(fpParamEnv),FtoR(fpLocalEnv))(FtoR(expr))
			           = eval(FtoR(fpParamEnv),FtoR(fpLocalEnv2))(FtoR(res)) )

  expandLocalDefs(fpLocalEnv,(expr | bounded_by?(fpLocalEnv)(expr)))
  : RECURSIVE { res: FPAExpr | NoLocalVars?(res) AND
    	      	     	       ( FORALL(fpParamEnv, fpLocalEnv2)
			         : eval(fpParamEnv,fpLocalEnv)(expr)
			           = eval(fpParamEnv,fpLocalEnv2)(res) ) AND
    	      	     	       eld_post_eval_ftor(fpLocalEnv,expr,res) }
  = CASES expr OF
      FPVariable(idx)           : expandLocalDefs(shrink(fpLocalEnv,idx),get(fpLocalEnv)(idx)),
      FPOperator(op,expr1,expr2): FPOperator( op,
      				  	      expandLocalDefs(fpLocalEnv,expr1),
      				  	      expandLocalDefs(fpLocalEnv,expr2) )
      ELSE expr
    ENDCASES
  MEASURE make_context(expr,fpLocalEnv) BY <<

  expandLocalDefs_no_local_vars
  : LEMMA
    FORALL(expr | bounded_by?(fpLocalEnv)(expr))
    : NoLocalVars?(expandLocalDefs(fpLocalEnv,expr))

  expandLocalDefs_eval
  : LEMMA
    FORALL(fpLocalEnv,fpLocalEnv2,(expr | bounded_by?(fpLocalEnv)(expr)))
    : eval(fpParamEnv,fpLocalEnv)(expr)
      = eval(fpParamEnv,fpLocalEnv2)(expandLocalDefs(fpLocalEnv,expr))

  expandLocalDefs_eval_ftor
  : LEMMA
    FORALL(fpLocalEnv,fpLocalEnv2,(expr | bounded_by?(fpLocalEnv)(expr)))
    : eval(FtoR(fpParamEnv),FtoR(fpLocalEnv))(FtoR(expr))
      = eval(FtoR(fpParamEnv),FtoR(fpLocalEnv2))(FtoR(expandLocalDefs(fpLocalEnv,expr)))

  %
  % Replacement on formulas
  %

  replace_local_var(form: FPBExpr)(replacement: FPAExpr)
  : RECURSIVE FPBExpr
  = CASES form OF
      FPNot(form)       : FPNot(replace_local_var(form)(replacement)),
      FPAnd(form1,form2): FPAnd( replace_local_var(form1)(replacement),
      			  	 replace_local_var(form2)(replacement) ),
      FPLT(expr1,expr2) : FPLT( replace_local_var(expr1)(replacement),
      			  	replace_local_var(expr2)(replacement) )
      ELSE form
    ENDCASES
  MEASURE form BY <<

  replace_local_var(form: RBExpr)(replacement: RAExpr)
  : RECURSIVE RBExpr
  = CASES form OF
      RNot(form)       : RNot(replace_local_var(form)(replacement)),
      RAnd(form1,form2): RAnd( replace_local_var(form1)(replacement),
      			  	 replace_local_var(form2)(replacement) ),
      RLT(expr1,expr2) : RLT( replace_local_var(expr1)(replacement),
      			  	replace_local_var(expr2)(replacement) )
      ELSE form
    ENDCASES
  MEASURE form BY <<

  % Properties

  replace_local_var_in_fpform_evaluable_in
  : LEMMA
    FORALL( fpLocalEnv : FPLocalEnvironment,
    	    aexpr      : FPAExpr | bounded_by?(fpLocalEnv)(aexpr) )
    : bounded_by?(cons(aexpr, fpLocalEnv))(form) 
      = bounded_by?(fpLocalEnv)(replace_local_var(form)(aexpr))

  replace_local_var_in_rform_evaluable_in
  : LEMMA
    FORALL( rLocalEnv : RLocalEnvironment,
    	    aexpr     : FPAExpr | bounded_by?(rLocalEnv)(FtoR(aexpr)),
	    form      : RBExpr )
    : bounded_by?(cons(FtoR(aexpr), rLocalEnv))(form) 
      = bounded_by?(rLocalEnv)(replace_local_var(form)(FtoR(aexpr)))

  replace_local_var_in_fpform_val
  : LEMMA
    FORALL( fpParamEnv : FPEnvironment,
  	    fpLocalEnv : FPLocalEnvironment,
	    aexpr      : FPAExpr | bounded_by?(fpLocalEnv)(aexpr),
	    form | bounded_by?(cons(aexpr,fpLocalEnv))(form) )
    : val(fpParamEnv, cons(aexpr, fpLocalEnv))(form)
      = val(fpParamEnv, fpLocalEnv)(replace_local_var(form)(aexpr))

  replace_local_var_in_rform_val
  : LEMMA
    FORALL( rParamEnv : REnvironment,
  	    rLocalEnv : RLocalEnvironment,
	    aexpr     : FPAExpr | bounded_by?(rLocalEnv)(FtoR(aexpr)),
	    form      : RBExpr  | bounded_by?(cons(FtoR(aexpr),rLocalEnv))(form) )
    : val(rParamEnv, cons(FtoR(aexpr), rLocalEnv))(form)
      = val(rParamEnv, rLocalEnv)(replace_local_var(form)(FtoR(aexpr)))

  var_appears_in_replaced_form_dec_var_appears_in_orig_form
  : LEMMA
    appears?(replace_local_var(form)(expr))(FPVariable(i_var))
    IMPLIES ( appears?(form)(FPVariable(i_var+1)) OR appears?(expr)(FPVariable(i_var)) )

  var_appears_in_replaced_rform_dec_var_appears_in_orig_rform
  : LEMMA
    appears?(replace_local_var(rform)(rexpr))(RVariable(i_var))
    IMPLIES ( appears?(rform)(RVariable(i_var+1)) OR appears?(rexpr)(RVariable(i_var)) )

  %
  % Replacement on CEBs.
  %
  
  replace_local_var_in_ceb(ceb: CEB)(replacement: FPAExpr)
  : CEB
  = ceb WITH [ fpconds := replace_local_var(fpconds(ceb))(replacement),
    	       rconds  := replace_local_var(rconds(ceb)) (FtoR(replacement)) ]

  var_appears_in_replaced_fpconds_dec_var_appears_in_orig_fpconds
  : LEMMA
    appears?(fpconds(replace_local_var_in_ceb(ceb)(expr)))(FPVariable(i_var))
    IMPLIES ( appears?(fpconds(ceb))(FPVariable(i_var+1))
    	      OR appears?(expr)(FPVariable(i_var)) )

  var_appears_in_replaced_rconds_dec_var_appears_in_orig_rconds
  : LEMMA
    appears?(rconds(replace_local_var_in_ceb(ceb)(expr)))(FtoR(FPVariable(i_var)))
    IMPLIES ( appears?(rconds(ceb))(FtoR(FPVariable(i_var+1)))
    	      OR appears?(expr)(FPVariable(i_var)) )

  %
  % Replacement on domains.
  %
  
  replace_local_var_in_domain(d: Domain)(index: nat, replacement: FPAExpr)
  : Domain
  = map(LAMBDA(ceb:CEB):replace_local_var_in_ceb(ceb)(replacement))(d)

  %
  % Properties
  %
  
  max_local_index_form_replaced_var
  : LEMMA
    maxFreeLocalIndex(replace_local_var(form)(expr)) <=
      max(maxFreeLocalIndex(expr), maxFreeLocalIndex(form))

  max_local_index_fpconds_replaced_var_ceb
  : COROLLARY
    maxFreeLocalIndex(fpconds(replace_local_var_in_ceb(ceb)(expr)))
    <= max(maxFreeLocalIndex(expr),maxFreeLocalIndex(fpconds(ceb)))

  unreplaced_var_ceb_in_dom
  : LEMMA
    FORALL(d: Domain, ceb: CEB, aexpr: FPAExpr)
    : replace_local_var_in_domain(d)(index,aexpr)(ceb)
      IMPLIES EXISTS(ceb_: CEB): d(ceb_) AND replace_local_var_in_ceb(ceb_)(aexpr) = ceb

  replace_local_var_dom_ceb
  : LEMMA
    FORALL(d: Domain, ceb: (d), aexpr: FPAExpr)
    : replace_local_var_in_domain(d)(index,aexpr)(replace_local_var_in_ceb(ceb)(aexpr))

  replace_local_var_in_fpconds_ceb_evaluable_in 
  : LEMMA 
    FORALL( fpLocalEnv : FPLocalEnvironment,
    	    ceb        : CEB,
    	    aexpr      : FPAExpr | bounded_by?(fpLocalEnv)(aexpr) )
    : bounded_by?(cons(aexpr, fpLocalEnv))(fpconds(ceb))
      = bounded_by?(fpLocalEnv)
                (fpconds(replace_local_var_in_ceb(ceb)(aexpr)))
			  
  replace_local_var_in_rconds_ceb_evaluable_in
  : LEMMA
    FORALL( rLocalEnv : RLocalEnvironment,
    	    ceb       : CEB,
    	    aexpr     : FPAExpr | bounded_by?(rLocalEnv)(FtoR(aexpr)) ) 
    : bounded_by?(cons(FtoR(aexpr), rLocalEnv))(rconds(ceb))
      = bounded_by?(rLocalEnv)
                (rconds(replace_local_var_in_ceb(ceb)(aexpr)))

  replace_local_var_in_fpconds_ceb_val
  : LEMMA
    FORALL( fpParamEnv : FPEnvironment,
    	  fpLocalEnv : FPLocalEnvironment,
    	  ceb        : CEB,
    	  aexpr	     : FPAExpr | bounded_by?(fpLocalEnv)(aexpr) AND
	  	       	       	 bounded_by?(cons(aexpr, fpLocalEnv))(fpconds(ceb))) 
    : val(fpParamEnv, cons(aexpr, fpLocalEnv))(fpconds(ceb))
      = val(fpParamEnv, fpLocalEnv)(fpconds(replace_local_var_in_ceb(ceb)(aexpr)))

  replace_local_var_in_rconds_ceb_val
  : LEMMA
    FORALL( rParamEnv : REnvironment,
    	    rLocalEnv : RLocalEnvironment,
    	    ceb       : CEB,
    	    aexpr     : FPAExpr | bounded_by?(rLocalEnv)(FtoR(aexpr)) AND
	    	      		  bounded_by?(cons(FtoR(aexpr), rLocalEnv))(rconds(ceb)) ) 
    : val(rParamEnv, cons(FtoR(aexpr), rLocalEnv))(rconds(ceb))
      = val(rParamEnv, rLocalEnv)(rconds(replace_local_var_in_ceb(ceb)(aexpr)))

  replace_local_var_in_ceb_result_id
  : LEMMA
    FORALL(ceb: CEB, aexpr: FPAExpr)
    : fpresult(replace_local_var_in_ceb(ceb)(aexpr)) = fpresult(ceb)

  replace_local_var_in_ceb_stable_id
  : LEMMA
    FORALL(ceb: CEB, aexpr: FPAExpr)
    : stable?(replace_local_var_in_ceb(ceb)(aexpr)) = stable?(ceb)

  %
  % The following function formalizes the semantics of a statement.
  %

  else_then_unstable_ceb
  ( semthen,semelse: {d: Domain | EXISTS (ceb: CEB): d(ceb) AND ceb`stable?} )
  : Domain
  = make_unstable_domain(stable_ceb_filter(semelse),stable_ceb_filter(semthen))

  then_else_unstable_ceb
  ( semthen,semelse: {d: Domain | EXISTS (ceb: CEB): d(ceb) AND ceb`stable?} )
  : Domain
  = make_unstable_domain(stable_ceb_filter(semthen),stable_ceb_filter(semelse))

  %

  else_then_unstable_ceb_def
  : LEMMA
    FORALL(semthen,semelse: {d: Domain | EXISTS (ceb: CEB): d(ceb) AND ceb`stable?})
    : else_then_unstable_ceb(semthen,semelse)
      = {ceb: CEB | EXISTS ( thenceb: (stable_ceb_filter(semthen)),
                             elseceb: (stable_ceb_filter(semelse))):
                            ceb`rconds = elseceb`rconds
                        AND ceb`fpconds = thenceb`fpconds
                        AND ceb`rresult = elseceb`rresult
                        AND ceb`fpresult = thenceb`fpresult
                        AND NOT ceb`stable?}

  then_else_unstable_ceb_def
  : LEMMA
    FORALL( semthen,semelse: {d: Domain | EXISTS (ceb: CEB): d(ceb) AND ceb`stable?} )
    : then_else_unstable_ceb(semthen,semelse)
      = { ceb: CEB | EXISTS( thenceb: (stable_ceb_filter(semthen)),
  		             elseceb: (stable_ceb_filter(semelse)) ):
                   rconds(ceb)   = rconds(thenceb)   AND
                   fpconds(ceb)  = fpconds(elseceb)  AND
                   rresult(ceb)  = rresult(thenceb)  AND
                   fpresult(ceb) = fpresult(elseceb) AND
                   NOT stable?(ceb) }

  %
   
  sem(nargs  : nat,
      env    : (validEnvironmentForStmt))
     (st     : FPStmt | wellFormed?(st,nargs,length(env)))
  : RECURSIVE {d: Domain | EXISTS(ceb:CEB): d(ceb) AND stable?(ceb)}
  = CASES st OF
      WARNING: singleton(make_ceb(RTrue,FPTrue,RBottom,FPBottom,true)),
      ITE(guard,thenb,elseb):
        LET semthen = sem(nargs,env)(thenb),
            semelse = sem(nargs,env)(elseb)
        IN union(
            propag(semthen, FtoR(guard), guard),
            union(
              propag(semelse, RNot(FtoR(guard)), FPNot(guard)),
              union(
                propag(else_then_unstable_ceb(semthen,semelse),RNot(FtoR(guard)),guard),
                propag(then_else_unstable_ceb(semthen,semelse),FtoR(guard),FPNot(guard))))),
      LETIN(aexpr,body) : LET sem_expr = sem(aexpr,nargs,env),
          		      new_env  = cons(sem_expr,env)
        		  IN replace_local_var_in_domain(sem(nargs,new_env)(body))(0,aexpr),
      AEXPR(aexpr)      : sem(aexpr,nargs,env)
    ENDCASES
  MEASURE st BY <<

  % Some properties of fpconds(ceb)

  built_from_stmt?(stmt: FPStmt, env: Environment)(fpconds: FPBExpr)
  : RECURSIVE bool
  = fpconds = FPTrue
    OR appears_in?(fpconds,stmt)
    OR ( FPAnd?(fpconds) AND
         built_from_stmt?(stmt,env)(expr1(fpconds)) AND
	 built_from_stmt?(stmt,env)(expr2(fpconds)) )
    OR (FPNot?(fpconds) AND appears_in?(expr(fpconds),stmt))
    OR (EXISTS(i:below(length(env)),ceb:(nth(env,i))): fpconds=fpconds(ceb))
  MEASURE fpconds BY <<

  bounded_by?(fpLocalEnv : FPLocalEnvironment)(env: Environment): bool
  = FORALL(i: below(length(env))):
     FORALL(ceb: (nth(env,i))): bounded_by?(fpLocalEnv)(fpconds(ceb))

  %
  % Environment Semantical Consistency
  %

  semanticallyConsistent?
  ( env        : (validEnvironmentForStmt),
    fpLocalEnv : FPLocalEnvironment )
  : bool
  = length(env) = size(fpLocalEnv) AND
    FORALL(i: below(size(fpLocalEnv)))
    : EXISTS(nargs:nat)
      : wellFormed?(get(fpLocalEnv)(i),nargs,length(env)-(i+1)) AND
        sem(get(fpLocalEnv)(i),nargs,takeFromRight(env,length(env)-(i+1))) = nth(env,i)

  empty_env_are_semantically_consistent: LEMMA
    semanticallyConsistent?(emptyEnv,FPEmptyLocalEnv)
  AUTO_REWRITE+ empty_env_are_semantically_consistent

  semantically_consistent_ext: LEMMA
    FORALL( fpLocalEnv : FPLocalEnvironment,
    	    env        : (validEnvironmentForStmt),
	    nargs      : nat,
	    aexpr      : FPAExpr | wellFormed?(aexpr,nargs,length(env)) ):
      semanticallyConsistent?(env, fpLocalEnv)
      IMPLIES semanticallyConsistent?(cons(sem(aexpr,nargs,env),env), cons(aexpr,fpLocalEnv))

  %

  max_local_index_evaluable_in__form: LEMMA
    maxFreeLocalIndex(form) < size(fpLocalEnv)
    IMPLIES bounded_by?(fpLocalEnv)(form)

  max_local_index_evaluable_in__rform
  : LEMMA
    maxFreeLocalIndex(rform) < size(rLocalEnv)
    IMPLIES bounded_by?(rLocalEnv)(rform)

  evaluable_in_max_local_index__stmt: LEMMA
    bounded_by?(fpLocalEnv)(stmt)
    IMPLIES maxFreeLocalIndex(stmt) < size(fpLocalEnv)

  appears_free_fpconds_expr
  : LEMMA
    FORALL( nargs: nat,
    	    env  : (validEnvironmentForStmt),
      	    ceb  : CEB )
    : wellFormed?(expr,nargs,length(env)) AND
      wellFormed?(env,nargs,length(env)) AND
      sem(expr,nargs,env)(ceb)
      IMPLIES FORALL(local: (FPVariable?))
              : appears?(fpconds(ceb))(local)
	        IMPLIES ( appears?(expr)(local)
			  OR appears?(env)(local) )

  appears_free_rconds_expr
  : LEMMA
    FORALL( nargs: nat,
    	    env  : (validEnvironmentForStmt),
      	    ceb  : CEB )
    : wellFormed?(expr,nargs,length(env)) AND
      wellFormed?(env,nargs,length(env)) AND
      sem(expr,nargs,env)(ceb)
      IMPLIES FORALL(local: (FPVariable?))
              : appears?(rconds(ceb))(FtoR(local))
	        IMPLIES ( appears?(expr)(local)
			  OR appears?(env)(local) )

  appears_free_fpconds
  : LEMMA
    FORALL( stmt : FPStmt,
      	    nargs: nat,
    	    env  : (validEnvironmentForStmt),
      	    ceb  : CEB )
    : wellFormed?(stmt,nargs,length(env)) AND
      wellFormed?(env,nargs,length(env)) AND
      sem(nargs,env)(stmt)(ceb)
      IMPLIES FORALL(local: (FPVariable?))
              : appears?(fpconds(ceb))(local)
	        IMPLIES appearsFree?(stmt)(local)

  appears_free_rconds
  : LEMMA
    FORALL( stmt : FPStmt,
      	    nargs: nat,
    	    env  : (validEnvironmentForStmt),
      	    ceb  : CEB )
    : wellFormed?(stmt,nargs,length(env)) AND
      wellFormed?(env,nargs,length(env)) AND
      sem(nargs,env)(stmt)(ceb)
      IMPLIES FORALL(local: (FPVariable?))
              : appears?(rconds(ceb))(FtoR(local))
	        IMPLIES appearsFree?(stmt)(local)

  mli_af_stmt_form
  : LEMMA
    (FORALL(local: (FPVariable?)): appears?(form)(local) = appearsFree?(stmt)(local))
    IMPLIES maxFreeLocalIndex(form) = maxFreeLocalIndex(stmt)

  mli_af_form_stmt_inclusion
  : LEMMA
    ( FORALL(local: (FPVariable?))
      : appears?(form)(local) IMPLIES appearsFree?(stmt)(local) )
    IMPLIES maxFreeLocalIndex(form) <= maxFreeLocalIndex(stmt)

  mli_af_rform_stmt_inclusion
  : LEMMA
    ( FORALL(local: (FPVariable?))
      : appears?(rform)(FtoR(local)) IMPLIES appearsFree?(stmt)(local) )
    IMPLIES maxFreeLocalIndex(rform) <= maxFreeLocalIndex(stmt)

  max_local_index_ceb_cond
  : THEOREM
    FORALL( stmt : FPStmt,
      	    nargs: nat,
    	    env  : (validEnvironmentForStmt),
      	    ceb  : CEB )
    : wellFormed?(stmt,nargs,length(env)) AND
      wellFormed?(env,nargs,length(env)) AND
      sem(nargs,env)(stmt)(ceb)
      IMPLIES maxFreeLocalIndex(fpconds(ceb)) <= max(maxFreeLocalIndex(stmt),maxFreeLocalIndex(env))

  max_local_index_ceb_rcond
  : THEOREM
    FORALL( stmt : FPStmt,
      	    nargs: nat,
    	    env  : (validEnvironmentForStmt),
      	    ceb  : CEB )
    : wellFormed?(stmt,nargs,length(env)) AND
      wellFormed?(env,nargs,length(env)) AND
      sem(nargs,env)(stmt)(ceb)
      IMPLIES maxFreeLocalIndex(rconds(ceb)) <= max(maxFreeLocalIndex(stmt),maxFreeLocalIndex(env))

  fp_evaluable_in_stmt_evaluable_ceb: THEOREM
    FORALL( fpLocalEnv : FPLocalEnvironment,
    	    stmt       : FPStmt):
      bounded_by?(fpLocalEnv)(stmt)
      IMPLIES FORALL( nargs   : nat,
      	    	      env     : (validEnvironmentForStmt) |
  		                   wellFormed?(stmt,nargs,length(env)) AND
  				   semanticallyConsistent?(env, fpLocalEnv) AND
				   wellFormed?(env,nargs,length(env)),
  		      ceb     : (sem(nargs, env)(stmt)) ):
                bounded_by?(fpLocalEnv)(fpconds(ceb))

  r_evaluable_in_stmt_evaluable_ceb: THEOREM
    FORALL( fpLocalEnv : FPLocalEnvironment,
    	    rLocalEnv  : RLocalEnvironment |
	                   consistentLocalEnvironments?(fpLocalEnv,rLocalEnv),
    	    stmt       : FPStmt):
      bounded_by?(fpLocalEnv)(stmt)
      IMPLIES FORALL( nargs   : nat,
      	    	      env     : (validEnvironmentForStmt) |
		                   wellFormed?(stmt,nargs,length(env)) AND
				   semanticallyConsistent?(env, fpLocalEnv) AND
				   wellFormed?(env,nargs,length(env)),
		      ceb     : (sem(nargs, env)(stmt)) ):
                bounded_by?(rLocalEnv)(rconds(ceb))

  % Semantics of a program

  sem(pgm: (wellFormedProgram?)): Domain
  = sem(nargs(pgm), emptyEnv)(body(pgm))

END semantics
