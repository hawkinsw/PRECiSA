two_level_expressions[

  Operator            : TYPE+,

  operatorUnderAnalysis? : { p: PRED[Operator] | EXISTS(op:Operator): p(op) },

  RealNumber          : TYPE+,
  lt_r                : (strict_total_order?[RealNumber]),
  applyFun_r          : [[Operator,RealNumber,RealNumber]->RealNumber],
  FloatingPointNumber : TYPE+,
  lt_fp               : (strict_total_order?[FloatingPointNumber]),
  applyFun_fp         : [[Operator,FloatingPointNumber,FloatingPointNumber]->FloatingPointNumber],
  FtoR 		      : [FloatingPointNumber -> RealNumber]

] : THEORY BEGIN

  ASSUMING
  
    X,Y: VAR FloatingPointNumber
    rX,rY: VAR RealNumber
  
    lt_fp_lt_r
    : ASSUMPTION
      lt_fp(X,Y) = lt_r(FtoR(X),FtoR(Y))
      
  ENDASSUMING

  operatorUnderAnalysis?_is_not_empty: LEMMA EXISTS (x: (operatorUnderAnalysis?)): TRUE;
  AUTO_REWRITE+ operatorUnderAnalysis?_is_not_empty

  IMPORTING expressions[(operatorUnderAnalysis?),RealNumber,FloatingPointNumber,FtoR]
             AS input_expr_th,
   	    expressions[Operator,RealNumber,FloatingPointNumber,FtoR]
             AS analysis_expr_th

  IRExpr: TYPE = input_expr_th.RAExpr
  IFExpr: TYPE = input_expr_th.FPAExpr
  ARExpr: TYPE = analysis_expr_th.RAExpr

  make_application_arexpr(op:Operator,arg1,arg2:ARExpr)
  : MACRO ARExpr
  = analysis_expr_th.ROperator(op,arg1,arg2)

  iRToAR(e: input_expr_th.RAExpr)
  : RECURSIVE analysis_expr_th.RAExpr
    = CASES e OF
       RConstant(number)       : RConstant(number),      
       RParameter(v)           : RParameter(v),     
       RVariable(v)            : RVariable(v),         
       ROperator(op,arg1,arg2) : ROperator(op,iRToAR(arg1),iRToAR(arg2))
      ENDCASES 
  MEASURE e BY <<

  iFToAF(e: input_expr_th.FPAExpr)
  : RECURSIVE analysis_expr_th.FPAExpr
    = CASES e OF
       FPConstant(number)       : FPConstant(number),      
       FPParameter(v)           : FPParameter(v),     
       FPVariable(v)            : FPVariable(v),         
       FPOperator(op,arg1,arg2) : FPOperator(op,iFToAF(arg1),iFToAF(arg2))
      ENDCASES 
  MEASURE e BY <<

  irexpr : VAR input_expr_th.RAExpr
  irlocal: VAR (input_expr_th.RVariable?)
  ire: VAR IRExpr
  are: VAR ARExpr

  rvariable_irtoar_rlocal   
  : JUDGEMENT
    iRToAR(irlocal) HAS_TYPE (analysis_expr_th.RVariable?)

  iRToAR_rexpr_var_existence
  : LEMMA
    FORALL( rexpr     : input_expr_th.RAExpr,
  	    v: (analysis_expr_th.RVariable?) | v = iRToAR(rexpr) OR v << iRToAR(rexpr)):
    EXISTS(v1: (input_expr_th.RVariable?)| v1 = rexpr OR v1 << rexpr): index(v) = index(v1)

  iFToAF_expr_var_existence
  : LEMMA
    FORALL( expr     : input_expr_th.FPAExpr,
  	    v: (analysis_expr_th.FPVariable?) | v = iFToAF(expr) OR v << iFToAF(expr)):
    EXISTS(v1: (input_expr_th.FPVariable?)| v1 = expr OR v1 << expr)
    : analysis_expr_th.index(v) = input_expr_th.index(v1)

  %

  IMPORTING expressions_semantics[ (operatorUnderAnalysis?),
  	                           RealNumber,lt_r,applyFun_r,
  		                   FloatingPointNumber,lt_fp,applyFun_fp,
  		                   FtoR ] AS input_esem_th
  		       
  IMPORTING expressions_semantics[ Operator,
  	                           RealNumber,lt_r,applyFun_r,
  		                   FloatingPointNumber,lt_fp,applyFun_fp,
  		                   FtoR ] AS analysis_esem_th

  arParamEnv : VAR analysis_esem_th.REnvironment
  
  irParamEnv : VAR input_esem_th.REnvironment
  ifpParamEnv : VAR input_esem_th.FPEnvironment
  irLocalEnv : VAR input_esem_th.RLocalEnvironment
  iInputRest : VAR input_esem_th.InputRestriction

  IFPEnvironment: TYPE = input_esem_th.FPEnvironment
  IFPLocalEnv: TYPE = input_esem_th.FPLocalEnvironment

  IRLocalEnv: TYPE = input_esem_th.RLocalEnvironment

  arlocal: VAR (analysis_expr_th.RVariable?)

  appears?_analysis_local_input_locals
  : LEMMA
    FORALL(are: analysis_expr_th.RAExpr)
    : analysis_expr_th.appears?(are)(arlocal)
      IMPLIES EXISTS(irlocal|index(irlocal)=index(arlocal))
              : analysis_expr_th.appears?(are)(iRToAR(irlocal))

  appears?_analysis_iRToAR_rexpr
  : LEMMA
    analysis_expr_th.appears?(iRToAR(ire))(iRToAR(irlocal))
    IMPLIES input_expr_th.appears?(ire)(irlocal)

  % Local Environments

  iRToAR_env(rLocalEnv: input_esem_th.RLocalEnvironment)
  : RECURSIVE { arLocalEnv: analysis_esem_th.RLocalEnvironment
    	       	 | size(rLocalEnv) = size(arLocalEnv) }
  = IF size(rLocalEnv) = 0
    THEN analysis_esem_th.REmptyLocalEnv
    ELSE analysis_esem_th.cons_renv
          ( iRToAR(input_esem_th.get_renv(rLocalEnv)(0)),
  	     iRToAR_env(input_esem_th.shrink_renv(rLocalEnv,0)) ) ENDIF
  MEASURE size(rLocalEnv)

  iFToAF_env(fpLocalEnv: input_esem_th.FPLocalEnvironment)
  : RECURSIVE { afLocalEnv: analysis_esem_th.FPLocalEnvironment
    	       	 | size(fpLocalEnv) = size(afLocalEnv) }
  = IF size(fpLocalEnv) = 0
    THEN analysis_esem_th.FPEmptyLocalEnv
    ELSE analysis_esem_th.cons_fpenv
          ( iFToAF(input_esem_th.get_fpenv(fpLocalEnv)(0)),
  	     iFToAF_env(input_esem_th.shrink_fpenv(fpLocalEnv,0)) ) ENDIF
  MEASURE size(fpLocalEnv)

  iRToAR_renv_size
  : LEMMA
    FORALL( rLocalEnv : input_esem_th.RLocalEnvironment )
    : size(rLocalEnv) = size(iRToAR_env(rLocalEnv))

  iFToAF_env_size
  : LEMMA
    FORALL( fpLocalEnv : input_esem_th.FPLocalEnvironment )
    : size(fpLocalEnv) = size(iFToAF_env(fpLocalEnv))

  % evaluable

  evaluable_rLocalEnv_evaluable_iRToAR_env
  : LEMMA
    FORALL( rLocalEnv : input_esem_th.RLocalEnvironment,
            rexpr     : input_expr_th.RAExpr )
    : bounded_by?(rLocalEnv)(rexpr)
      IMPLIES bounded_by?(iRToAR_env(rLocalEnv))(iRToAR(rexpr))

  iRToAR_env_preserves_get
  : LEMMA
    FORALL(irLocalEnv,(irlocal|bounded_by?(irLocalEnv)(irlocal)))
    : iRToAR(input_esem_th.get_renv(irLocalEnv)(index(irlocal)))
      = analysis_esem_th.get_renv(iRToAR_env(irLocalEnv))(index(irlocal))

  iRToAR_env_preserves_shrink
  : LEMMA
    FORALL(irLocalEnv,(irlocal|bounded_by?(irLocalEnv)(irlocal))):
    iRToAR_env(input_esem_th.shrink_renv(irLocalEnv, index(irlocal)))
    = shrink(iRToAR_env(irLocalEnv), index(irlocal))

  iRToAR_env_FtoR_fpLocalEnv_evaluable
  : LEMMA
    FORALL ( fpLocalEnv:input_esem_th.FPLocalEnvironment,
    	    errorExpr: analysis_expr_th.RAExpr |
               analysis_esem_th.bounded_by?_raexpr
  		(iRToAR_env(FtoR(fpLocalEnv)))(errorExpr) )
    : LET rLocalEnv : analysis_esem_th.RLocalEnvironment
          = iRToAR_env(input_esem_th.FtoR(fpLocalEnv))
      IN bounded_by?(rLocalEnv)(errorExpr)

  evaluable_fpLocalEnv_evaluable_iFToAF_env
  : LEMMA
    FORALL( fpLocalEnv : input_esem_th.FPLocalEnvironment,
            expr       : input_expr_th.FPAExpr )
    : bounded_by?(fpLocalEnv)(expr)
      IMPLIES bounded_by?(iFToAF_env(fpLocalEnv))(iFToAF(expr))

  iRToAR_env_FtoR_fpLocalEnv_iRToAR_FtoR_evaluable
  : LEMMA
    FORALL ( fpLocalEnv:input_esem_th.FPLocalEnvironment,
    	      ( expr: input_expr_th.FPAExpr | bounded_by?(fpLocalEnv)(expr) ) )
    : LET rLocalEnv : analysis_esem_th.RLocalEnvironment
      	   = iRToAR_env(input_esem_th.FtoR(fpLocalEnv))
      IN bounded_by?(rLocalEnv)(iRToAR(FtoR(expr)))

  %
  % Parameter Environments
  %

  iRToAR_par(env: input_esem_th.REnvironment): analysis_esem_th.REnvironment
  = LAMBDA(i: analysis_expr_th.ParameterIndex): env(i)

  iRToAR_par_def
  : LEMMA
    FORALL(i: nat): iRToAR_par(irParamEnv)(i) = irParamEnv(i)

  % Restriction Conversion

  iRToAR_res(rest: input_esem_th.RInputRestriction)
  : analysis_esem_th.RInputRestriction
  = LAMBDA(i: analysis_expr_th.ParameterIndex): rest(i)

  iRToAR_res_rValidInput
  : LEMMA
    input_esem_th.rValidInput?
    (input_esem_th.FtoR(iInputRest))(input_esem_th.FtoR(ifpParamEnv))
    IMPLIES analysis_esem_th.rValidInput?
    	       (iRToAR_res(input_esem_th.FtoR(iInputRest)))
    	       (iRToAR_par(input_esem_th.FtoR(ifpParamEnv)))

  % Evaluation

  IMPORTING orders@lex2_generic[nat,nat,<,<]

  eval_input_analysis_eq
  : LEMMA
    FORALL(irParamEnv, irLocalEnv, (irexpr | bounded_by?(irLocalEnv)(irexpr)))
    : eval(irParamEnv,irLocalEnv)(irexpr)
      = eval(iRToAR_par(irParamEnv),iRToAR_env(irLocalEnv))(iRToAR(irexpr))

END two_level_expressions
