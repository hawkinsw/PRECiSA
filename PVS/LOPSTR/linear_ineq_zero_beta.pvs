%
%  beta function used in the Polycarp example.
%
linear_ineq_zero_beta[
  Operator            : TYPE+,
  RealNumber          : TYPE+,
  lt_r                : (strict_total_order?[RealNumber]),
  applyFun_r          : [[Operator,RealNumber,RealNumber]->RealNumber],
  FloatingPointNumber : TYPE+,
  lt_fp               : (strict_total_order?[FloatingPointNumber]),
  applyFun_fp         : [[Operator,FloatingPointNumber,FloatingPointNumber]->FloatingPointNumber],
  FtoR 		      : [FloatingPointNumber -> RealNumber],

  zero_r   : RealNumber,
  abs      : [RealNumber->RealNumber],
  minus    : [RealNumber,RealNumber->RealNumber],
  Ropp     : [RealNumber->RealNumber],
  
  zero_fp  : FloatingPointNumber,
  Fopp     : [FloatingPointNumber->FloatingPointNumber]

] : THEORY
BEGIN

  ASSUMING

    X,Y,Z: VAR FloatingPointNumber
    rX,rY,rZ: VAR RealNumber 

    lt_fp_lt_r: ASSUMPTION lt_fp(X,Y) = lt_r(FtoR(X),FtoR(Y))

    %

    ftor_zero: ASSUMPTION FtoR(zero_fp) = zero_r

    ftor_fopp: ASSUMPTION FtoR(Fopp(X)) = Ropp(FtoR(X))

    ropp_id: ASSUMPTION Ropp(zero_r) = zero_r

    fopp_id: ASSUMPTION Fopp(zero_fp) = zero_fp

    IMPORTING expressions_semantics [ Operator,
      	               		      RealNumber,lt_r,applyFun_r,
      		       		      FloatingPointNumber,lt_fp,applyFun_fp,
      		       		      FtoR ]

    subtraction_eq_zero_r: ASSUMPTION minus(rX,rY) = zero_r IFF rX = rY
 
    subtraction_le_r: ASSUMPTION le_r(minus(rX,rY),rZ) IMPLIES le_r(minus(rX,rZ),rY)

    subtraction_le_isolate_2_r: ASSUMPTION le_r(minus(rX,rY),rZ) IMPLIES le_r(Ropp(rY),minus(rZ,rX))

    subtraction_le_zero_r: ASSUMPTION le_r(minus(rX,rY),zero_r) IFF le_r(zero_r,minus(rY,rX))

    lt_subtraction_r: ASSUMPTION lt_r(rX,rY) IFF lt_r(zero_r,minus(rY,rX))

    lt_subtractionp_ltz_r: ASSUMPTION lt_r(minus(rY,rX),zero_r) IFF lt_r(rY,rX)

    subtraction_lt_r: ASSUMPTION lt_r(minus(rX,rY),zero_r) IMPLIES lt_r(zero_r,minus(rY,rX))

    substraction_both_sides_zero_lt_x: ASSUMPTION lt_r(zero_r, rX) IFF lt_r(Ropp(rY), minus(rX, rY))

    addition_both_sides_zero_lt_opp_x: ASSUMPTION lt_r(zero_r,Ropp(rY)) IFF lt_r(rX,minus(rX,rY))

    ropp_subtraction: ASSUMPTION Ropp(minus(rX,rY)) = minus(rY,rX)

    subtratcion_cancellation_1: ASSUMPTION FORALL(rX, rY): minus(minus(rX, rY), rX) = Ropp(rY)

    %

    abs_le_zero_r: ASSUMPTION le_r(zero_r,abs(rX))

    abs_eq_zero_r: ASSUMPTION abs(rX) = zero_r IFF rX = zero_r

    abs_minus: ASSUMPTION abs(minus(rX,rY)) = abs(minus(rY,rX))

    abs_def: ASSUMPTION abs(rX) = IF le_r(zero_r,rX) THEN rX ELSE Ropp(rX) ENDIF

    %

    ropp_vs_zero: ASSUMPTION lt_r(zero_r,rX) IFF lt_r(Ropp(rX),zero_r)

    ropp_ropp_idemp: ASSUMPTION Ropp(Ropp(rX)) = rX

    ropp_le_r: ASSUMPTION FORALL (rX, rY): le_r(rX, rY) IFF le_r(Ropp(rY), Ropp(rX))

  ENDASSUMING

  %
  % Additional real-number lemmas
  %
  
  triangular_lemma_1: LEMMA
    FORALL (a, b, c: RealNumber):
      le_r(abs(minus(a, b)), c) AND lt_r(c, a) IMPLIES lt_r(zero_r, b)

  triangular_lemma_2: LEMMA
    FORALL (a, b, c: RealNumber):
      le_r(abs(minus(a, b)), c) AND lt_r(zero_r, b) IMPLIES lt_r(Ropp(c), a)

  triangular_lemma_3: LEMMA
    FORALL (a, b, c: RealNumber):
      le_r(abs(minus(a, b)), c) AND lt_r(a, Ropp(c)) IMPLIES lt_r(b,zero_r)

  triangular_lemma_4: CONJECTURE%D LEMMA
    FORALL (a, b, c: RealNumber):
      le_r(abs(minus(a, b)), c) AND lt_r(b, zero_r) IMPLIES lt_r(a,c)

  x : VAR real

  AUTO_REWRITE+ ftor_zero
  
  % These transormations are only defined on conditions of form:
  % <expr> < 0 | <expr> <= 0 | not <bexpr> | <bexpr> and <bexpr> | true | false

  zero?(aexpr: FPAExpr): MACRO bool =
    FPConstant?(aexpr) AND number(aexpr) = zero_fp

  FPBExprLinearVsZero: TYPE = { bexpr: FPBExpr |
    FPLT?(bexpr) IMPLIES ( zero?(expr1(bexpr)) OR zero?(expr2(bexpr)) ) }

  fpBExprRestriction(bexpr: FPBExpr): RECURSIVE bool =
    CASES bexpr OF
      FPTrue             : TRUE,
      FPFalse            : TRUE,
      FPNot(expr)        : fpBExprRestriction(expr),
      FPAnd(expr1,expr2) : fpBExprRestriction(expr1) AND fpBExprRestriction(expr2),
      FPLT(expr1,expr2)  : zero?(expr1) OR zero?(expr2)
    ENDCASES
  MEASURE bexpr BY <<

  fpLocalEnv : VAR FPLocalEnvironment
  nargs      : VAR nat
  fpParamEnv : VAR FPEnvironment
  inputRest  : VAR InputRestriction
  rLocalEnv  : VAR RLocalEnvironment
  
  % The following function returns a bound on the accumulated error produced
  % by the computation of the expression.
  % Such a function exists because the operations are total and their arguments
  % are being bounded by the input restriction (inputRest).

  accumulatedRoundoffErrorBound?
  (inputRest,fpLocalEnv,(expr: FPAExpr | bounded_by?(fpLocalEnv)(expr)))
  (err:FloatingPointNumber)
  : MACRO bool
  = FORALL( fpParamEnv: ValidInput(inputRest), 
      	      (rLocalEnv | consistentLocalEnvironments?(fpLocalEnv,rLocalEnv)) )
      : le_fp(zero_fp, err) AND
        le_r( abs(minus( FtoR(eval(fpParamEnv,fpLocalEnv)(expr)),
	                 eval(FtoR(fpParamEnv),rLocalEnv)(FtoR(expr)) ))
	    , FtoR(err) )

  accumulated_roundoff_error_bound_calculator_existence
  : AXIOM
    EXISTS( error:
      [ inputRest: InputRestriction, fpLocalEnv: FPLocalEnvironment
        -> [ expr: { expr: FPAExpr | bounded_by?(fpLocalEnv)(expr)}
	     -> (accumulatedRoundoffErrorBound?(inputRest,fpLocalEnv,expr)) ] ])
    : TRUE

  error(inputRest,fpLocalEnv)(expr: FPAExpr | bounded_by?(fpLocalEnv)(expr))
  : (accumulatedRoundoffErrorBound?(inputRest,fpLocalEnv,expr))
	
  %

  assures_positive_flow_on
  ( fpParamEnv : FPEnvironment,
    fpLocalEnv : FPLocalEnvironment,
    rLocalEnv  : RLocalEnvironment | consistentLocalEnvironments?(fpLocalEnv, rLocalEnv) )
  ( phi_fp: FPBExpr | bounded_by?(fpLocalEnv)(phi_fp) )
  ( beta_plus: FPBExpr | bounded_by?(fpLocalEnv)(beta_plus) )
  : bool
  = (  val(fpParamEnv,fpLocalEnv)(beta_plus)
        IMPLIES
        ( val(fpParamEnv,fpLocalEnv)(phi_fp) AND
	  val(FtoR(fpParamEnv),rLocalEnv)(FtoR(phi_fp)) ) )

  assures_negative_flow_on
  ( fpParamEnv : FPEnvironment,
    fpLocalEnv : FPLocalEnvironment,
    rLocalEnv  : RLocalEnvironment | consistentLocalEnvironments?(fpLocalEnv, rLocalEnv) )
  ( phi_fp: FPBExpr | bounded_by?(fpLocalEnv)(phi_fp) )
  ( beta_minus: FPBExpr | bounded_by?(fpLocalEnv)(beta_minus) )
  :bool
  = (	val(fpParamEnv,fpLocalEnv)(beta_minus)
        IMPLIES
        ( val(fpParamEnv,fpLocalEnv)(FPNot(phi_fp)) AND
	  val(FtoR(fpParamEnv),rLocalEnv)(RNot(FtoR(phi_fp))) ) )

  beta_ok
  ( inputRest,fpLocalEnv )
  ( phi_fp: (fpBExprRestriction)  | bounded_by?(fpLocalEnv)(phi_fp) )
  ( beta_minus : FPBExpr | bounded_by?(fpLocalEnv)(beta_minus),
    beta_plus  : FPBExpr | bounded_by?(fpLocalEnv)(beta_plus) )
  : bool =
   FORALL( fpParamEnv : ValidInput(inputRest),
  	   rLocalEnv  : RLocalEnvironment |
  	     consistentLocalEnvironments?(fpLocalEnv,rLocalEnv) ):
      assures_positive_flow_on(fpParamEnv,fpLocalEnv,rLocalEnv)(phi_fp)(beta_plus) AND
      assures_negative_flow_on(fpParamEnv,fpLocalEnv,rLocalEnv)(phi_fp)(beta_minus) 

  % Returns a tuple containing beta_minus and beta_plus resp.
  beta(inputRest,fpLocalEnv)(bexpr: FPBExpr | bounded_by?(fpLocalEnv)(bexpr))
  : RECURSIVE { res: [FPBExpr,FPBExpr] |
                  FORALL(nargs: nat):
                  fpBExprRestriction(bexpr) AND
		  wellFormed?(bexpr, nargs, size(fpLocalEnv))
		  IMPLIES ( wellFormed?(res`1, nargs, size(fpLocalEnv)) AND
		  	    wellFormed?(res`2, nargs, size(fpLocalEnv)) AND
			    beta_ok(inputRest,fpLocalEnv)(bexpr)(res) ) } =
    CASES bexpr OF
      FPTrue     : (FPFalse,FPTrue),
      FPFalse    : (FPTrue,FPFalse),
      FPNot(expr): LET (beta_minus,beta_plus) = beta(inputRest,fpLocalEnv)(expr)
		   IN ( beta_plus, beta_minus ),
      FPAnd(expr1,expr2) : LET (beta_minus1,beta_plus1) = beta(inputRest,fpLocalEnv)(expr1),
      			       (beta_minus2,beta_plus2) = beta(inputRest,fpLocalEnv)(expr2)
      			   IN ( FPAnd(beta_minus1,beta_minus2), FPAnd(beta_plus1,beta_plus2) ),
      FPLT(expr1,expr2)  : IF zero?(expr1)
      			   THEN LET err_expr2 = FPConstant(error(inputRest,fpLocalEnv)(expr2)),
      			       	    neg_err_expr2
				    = FPConstant(Fopp(error(inputRest,fpLocalEnv)(expr2)))
			        IN ( FPLEQ(expr2,neg_err_expr2), FPLT(err_expr2,expr2) )
      			   ELSE LET err_expr1 = FPConstant(error(inputRest,fpLocalEnv)(expr1)),
      			       	    neg_err_expr1
				    = FPConstant(Fopp(error(inputRest,fpLocalEnv)(expr1)))
			        IN ( FPLEQ(err_expr1,expr1),FPLT(expr1,neg_err_expr1) ) ENDIF
    ENDCASES
  MEASURE bexpr BY <<

  beta_plus(inputRest,fpLocalEnv)(bexpr: FPBExpr | bounded_by?(fpLocalEnv)(bexpr)): FPBExpr
  % = IF bounded_by?(fpLocalEnv)(bexpr)
  %   THEN beta(inputRest,fpLocalEnv)(bexpr)`2
  %   ELSE FPTrue ENDIF
  = beta(inputRest,fpLocalEnv)(bexpr)`2
  
  beta_minus(inputRest,fpLocalEnv)(bexpr: FPBExpr | bounded_by?(fpLocalEnv)(bexpr)): FPBExpr
  % = IF bounded_by?(fpLocalEnv)(bexpr)
  %   THEN beta(inputRest,fpLocalEnv)(bexpr)`1
  %   ELSE FPTrue ENDIF
  = beta(inputRest,fpLocalEnv)(bexpr)`1

  RestrictedFPBExpr: TYPE = (fpBExprRestriction)
  
  beta_plus_prop: THEOREM
    FORALL( phi_fp     : RestrictedFPBExpr,
    	    fpParamEnv : ValidInput(inputRest),
	    fpLocalEnv : FPLocalEnvironment | bounded_by?(fpLocalEnv)(phi_fp),
  	    rLocalEnv  : RLocalEnvironment |
  	       consistentLocalEnvironments?(fpLocalEnv,rLocalEnv) ):
      val(fpParamEnv,fpLocalEnv)(beta_plus(inputRest,fpLocalEnv)(phi_fp))
      IMPLIES
      ( val(fpParamEnv,fpLocalEnv)(phi_fp) AND
  	val(FtoR(fpParamEnv),rLocalEnv)(FtoR(phi_fp)) )

  beta_minus_prop: THEOREM
    FORALL( phi_fp     : RestrictedFPBExpr,
    	    fpParamEnv : ValidInput(inputRest),
	    fpLocalEnv : FPLocalEnvironment  | bounded_by?(fpLocalEnv)(phi_fp),
  	    rLocalEnv  : RLocalEnvironment |
  	       consistentLocalEnvironments?(fpLocalEnv,rLocalEnv) ):
      val(fpParamEnv,fpLocalEnv)(beta_minus(inputRest,fpLocalEnv)(phi_fp))
      IMPLIES
      ( val(fpParamEnv,fpLocalEnv)(FPNot(phi_fp)) AND
        val(FtoR(fpParamEnv),rLocalEnv)(RNot(FtoR(phi_fp))) )

  IMPORTING transformation [ Operator,
    	               	     RealNumber,lt_r,applyFun_r,
    		       	     FloatingPointNumber,lt_fp,applyFun_fp,
    		       	     FtoR,
		       	     fpBExprRestriction, beta_plus, beta_minus ]

END linear_ineq_zero_beta
