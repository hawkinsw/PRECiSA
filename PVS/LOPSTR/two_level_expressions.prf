(two_level_expressions
 (operatorUnderAnalysis?_is_not_empty 0
  (operatorUnderAnalysis?_is_not_empty-1 nil 3757699099
   ("" (typepred "operatorUnderAnalysis?")
    (("" (skeep :preds? t) (("" (inst?) nil nil)) nil)) nil)
   ((op skolem-const-decl "Operator" two_level_expressions nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (Operator formal-nonempty-type-decl nil two_level_expressions nil)
    (PRED type-eq-decl nil defined_types nil)
    (operatorUnderAnalysis? formal-const-decl
     "{p: PRED[Operator] | EXISTS (op: Operator): p(op)}"
     two_level_expressions nil))
   shostak))
 (input_expr_th_TCC1 0
  (input_expr_th_TCC1-1 nil 3757699071 ("" (existence-tcc) nil nil)
   ((operatorUnderAnalysis?_is_not_empty formula-decl nil
     two_level_expressions nil))
   nil))
 (iRToAR_TCC1 0
  (iRToAR_TCC1-1 nil 3757176823 ("" (termination-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (Operator formal-nonempty-type-decl nil two_level_expressions nil)
    (PRED type-eq-decl nil defined_types nil)
    (operatorUnderAnalysis? formal-const-decl
     "{p: PRED[Operator] | EXISTS (op: Operator): p(op)}"
     two_level_expressions nil)
    (FtoR formal-const-decl "[FloatingPointNumber -> RealNumber]"
     two_level_expressions nil)
    (FloatingPointNumber formal-nonempty-type-decl nil
     two_level_expressions nil)
    (RealNumber formal-nonempty-type-decl nil two_level_expressions
     nil)
    (<< adt-def-decl "(strict_well_founded?[RAExpr])" expressions nil))
   nil))
 (iRToAR_TCC2 0
  (iRToAR_TCC2-1 nil 3757176823 ("" (termination-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (Operator formal-nonempty-type-decl nil two_level_expressions nil)
    (PRED type-eq-decl nil defined_types nil)
    (operatorUnderAnalysis? formal-const-decl
     "{p: PRED[Operator] | EXISTS (op: Operator): p(op)}"
     two_level_expressions nil)
    (FtoR formal-const-decl "[FloatingPointNumber -> RealNumber]"
     two_level_expressions nil)
    (FloatingPointNumber formal-nonempty-type-decl nil
     two_level_expressions nil)
    (RealNumber formal-nonempty-type-decl nil two_level_expressions
     nil)
    (<< adt-def-decl "(strict_well_founded?[RAExpr])" expressions nil))
   nil))
 (iFToAF_TCC1 0
  (iFToAF_TCC1-1 nil 3757501814 ("" (termination-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (Operator formal-nonempty-type-decl nil two_level_expressions nil)
    (PRED type-eq-decl nil defined_types nil)
    (operatorUnderAnalysis? formal-const-decl
     "{p: PRED[Operator] | EXISTS (op: Operator): p(op)}"
     two_level_expressions nil)
    (FtoR formal-const-decl "[FloatingPointNumber -> RealNumber]"
     two_level_expressions nil)
    (FloatingPointNumber formal-nonempty-type-decl nil
     two_level_expressions nil)
    (RealNumber formal-nonempty-type-decl nil two_level_expressions
     nil)
    (<< adt-def-decl "(strict_well_founded?[FPAExpr])" expressions
     nil))
   nil))
 (iFToAF_TCC2 0
  (iFToAF_TCC2-1 nil 3757501814 ("" (termination-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (Operator formal-nonempty-type-decl nil two_level_expressions nil)
    (PRED type-eq-decl nil defined_types nil)
    (operatorUnderAnalysis? formal-const-decl
     "{p: PRED[Operator] | EXISTS (op: Operator): p(op)}"
     two_level_expressions nil)
    (FtoR formal-const-decl "[FloatingPointNumber -> RealNumber]"
     two_level_expressions nil)
    (FloatingPointNumber formal-nonempty-type-decl nil
     two_level_expressions nil)
    (RealNumber formal-nonempty-type-decl nil two_level_expressions
     nil)
    (<< adt-def-decl "(strict_well_founded?[FPAExpr])" expressions
     nil))
   nil))
 (rvariable_irtoar_rlocal 0
  (rvariable_irtoar_rlocal-1 nil 3757437702 ("" (grind) nil nil)
   ((iRToAR def-decl "analysis_expr_th.RAExpr" two_level_expressions
     nil))
   nil))
 (iRToAR_rexpr_var_existence 0
  (iRToAR_rexpr_var_existence-1 nil 3757437813
   ("" (induct "rexpr")
    (("1" (grind) nil nil)
     ("2" (skeep* :preds? t)
      (("2" (inst 1 "input_expr_th.RVariable(index(v))")
        (("1" (assert) nil nil)
         ("2" (split -2)
          (("1" (flatten)
            (("1" (expand "iRToAR")
              (("1" (apply-extensionality 1)
                (("1" (replace -1 :hide? t) (("1" (assert) nil nil))
                  nil))
                nil))
              nil))
            nil)
           ("2" (grind) nil nil))
          nil))
        nil))
      nil)
     ("3" (grind) nil nil) ("4" (grind) nil nil))
    nil)
   ((ROperator adt-constructor-decl
     "[[Operator, RAExpr, RAExpr] -> (ROperator?)]" expressions nil)
    (ROperator? adt-recognizer-decl "[RAExpr -> boolean]" expressions
     nil)
    (v1!2 skolem-const-decl "{v1: (input_expr_th.RVariable?) |
         v1 = ROperator3_var!1 OR v1 << ROperator3_var!1}"
     two_level_expressions nil)
    (v!1 skolem-const-decl "{v: (analysis_expr_th.RVariable?) |
         v =
          iRToAR(ROperator(ROperator1_var!1, ROperator2_var!1,
                           ROperator3_var!1))
          OR
          v <<
           iRToAR(ROperator(ROperator1_var!1, ROperator2_var!1,
                            ROperator3_var!1))}" two_level_expressions
     nil)
    (ROperator3_var!1 skolem-const-decl
     "RAExpr[(operatorUnderAnalysis?), RealNumber, FloatingPointNumber, FtoR]"
     two_level_expressions nil)
    (ROperator2_var!1 skolem-const-decl
     "RAExpr[(operatorUnderAnalysis?), RealNumber, FloatingPointNumber, FtoR]"
     two_level_expressions nil)
    (ROperator1_var!1 skolem-const-decl "(operatorUnderAnalysis?)"
     two_level_expressions nil)
    (v1!2 skolem-const-decl "{v1: (input_expr_th.RVariable?) |
         v1 = ROperator3_var!1 OR v1 << ROperator3_var!1}"
     two_level_expressions nil)
    (v1!1 skolem-const-decl "{v1: (input_expr_th.RVariable?) |
         v1 = ROperator3_var!1 OR v1 << ROperator3_var!1}"
     two_level_expressions nil)
    (v1!2 skolem-const-decl "{v1: (input_expr_th.RVariable?) |
         v1 = ROperator3_var!1 OR v1 << ROperator3_var!1}"
     two_level_expressions nil)
    (v1!2 skolem-const-decl "{v1: (input_expr_th.RVariable?) |
         v1 = ROperator3_var!1 OR v1 << ROperator3_var!1}"
     two_level_expressions nil)
    (v1!1 skolem-const-decl "{v1: (input_expr_th.RVariable?) |
         v1 = ROperator3_var!1 OR v1 << ROperator3_var!1}"
     two_level_expressions nil)
    (v1!2 skolem-const-decl "{v1: (input_expr_th.RVariable?) |
         v1 = ROperator3_var!1 OR v1 << ROperator3_var!1}"
     two_level_expressions nil)
    (v1!2 skolem-const-decl "{v1: (input_expr_th.RVariable?) |
         v1 = ROperator3_var!1 OR v1 << ROperator3_var!1}"
     two_level_expressions nil)
    (RParameter adt-constructor-decl
     "[ParameterIndex -> (RParameter?)]" expressions nil)
    (ParameterIndex nonempty-type-eq-decl nil expressions nil)
    (TRUE const-decl "bool" booleans nil)
    (RAExpr_RVariable_extensionality formula-decl nil expressions nil)
    (rvariable_irtoar_rlocal application-judgement
     "(analysis_expr_th.RVariable?)" two_level_expressions nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (RVariable adt-constructor-decl "[DeBruijnIndex -> (RVariable?)]"
     expressions nil)
    (RVariable1_var skolem-const-decl "DeBruijnIndex
    [(operatorUnderAnalysis?), RealNumber, FloatingPointNumber, FtoR]"
     two_level_expressions nil)
    (v skolem-const-decl "{v: (analysis_expr_th.RVariable?) |
         v = iRToAR(RVariable(RVariable1_var)) OR
          v << iRToAR(RVariable(RVariable1_var))}"
     two_level_expressions nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (RConstant? adt-recognizer-decl "[RAExpr -> boolean]" expressions
     nil)
    (RConstant adt-constructor-decl "[RNumber -> (RConstant?)]"
     expressions nil)
    (RNumber nonempty-type-eq-decl nil expressions nil)
    (RAExpr_induction formula-decl nil expressions nil)
    (Operator formal-nonempty-type-decl nil two_level_expressions nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (PRED type-eq-decl nil defined_types nil)
    (operatorUnderAnalysis? formal-const-decl
     "{p: PRED[Operator] | EXISTS (op: Operator): p(op)}"
     two_level_expressions nil)
    (RealNumber formal-nonempty-type-decl nil two_level_expressions
     nil)
    (FloatingPointNumber formal-nonempty-type-decl nil
     two_level_expressions nil)
    (FtoR formal-const-decl "[FloatingPointNumber -> RealNumber]"
     two_level_expressions nil)
    (index shared-adt-accessor-decl
           "[{x: RAExpr | RVariable?(x) OR RParameter?(x)} -> DeBruijnIndex]"
           expressions nil)
    (DeBruijnIndex nonempty-type-eq-decl nil expressions nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (RParameter? adt-recognizer-decl "[RAExpr -> boolean]" expressions
     nil)
    (number nonempty-type-decl nil numbers nil)
    (<< adt-def-decl "(strict_well_founded?[RAExpr])" expressions nil)
    (strict_well_founded? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (iRToAR def-decl "analysis_expr_th.RAExpr" two_level_expressions
     nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (RVariable? adt-recognizer-decl "[RAExpr -> boolean]" expressions
     nil)
    (RAExpr type-decl nil expressions nil))
   shostak))
 (iFToAF_expr_var_existence 0
  (iFToAF_expr_var_existence-1 nil 3757502003
   ("" (induct "expr")
    (("1" (grind) nil nil)
     ("2" (skeep* :preds? t)
      (("2" (inst 1 "input_expr_th.FPVariable(index(v))")
        (("1" (assert) nil nil)
         ("2" (split -2)
          (("1" (flatten)
            (("1" (expand "iFToAF")
              (("1" (apply-extensionality 1)
                (("1" (replace -1 :hide? t) (("1" (assert) nil nil))
                  nil))
                nil))
              nil))
            nil)
           ("2" (grind) nil nil))
          nil))
        nil))
      nil)
     ("3" (grind) nil nil) ("4" (grind) nil nil))
    nil)
   ((FPOperator adt-constructor-decl
     "[[Operator, FPAExpr, FPAExpr] -> (FPOperator?)]" expressions nil)
    (FPOperator? adt-recognizer-decl "[FPAExpr -> boolean]" expressions
     nil)
    (v1!2 skolem-const-decl "{v1: (input_expr_th.FPVariable?) |
         v1 = FPOperator3_var!1 OR v1 << FPOperator3_var!1}"
     two_level_expressions nil)
    (v!1 skolem-const-decl "{v: (analysis_expr_th.FPVariable?) |
         v =
          iFToAF(FPOperator(FPOperator1_var!1, FPOperator2_var!1,
                            FPOperator3_var!1))
          OR
          v <<
           iFToAF(FPOperator(FPOperator1_var!1, FPOperator2_var!1,
                             FPOperator3_var!1))}"
     two_level_expressions nil)
    (FPOperator3_var!1 skolem-const-decl
     "FPAExpr[(operatorUnderAnalysis?), RealNumber, FloatingPointNumber, FtoR]"
     two_level_expressions nil)
    (FPOperator2_var!1 skolem-const-decl
     "FPAExpr[(operatorUnderAnalysis?), RealNumber, FloatingPointNumber, FtoR]"
     two_level_expressions nil)
    (FPOperator1_var!1 skolem-const-decl "(operatorUnderAnalysis?)"
     two_level_expressions nil)
    (v1!2 skolem-const-decl "{v1: (input_expr_th.FPVariable?) |
         v1 = FPOperator3_var!1 OR v1 << FPOperator3_var!1}"
     two_level_expressions nil)
    (v1!1 skolem-const-decl "{v1: (input_expr_th.FPVariable?) |
         v1 = FPOperator3_var!1 OR v1 << FPOperator3_var!1}"
     two_level_expressions nil)
    (v1!2 skolem-const-decl "{v1: (input_expr_th.FPVariable?) |
         v1 = FPOperator3_var!1 OR v1 << FPOperator3_var!1}"
     two_level_expressions nil)
    (v1!2 skolem-const-decl "{v1: (input_expr_th.FPVariable?) |
         v1 = FPOperator3_var!1 OR v1 << FPOperator3_var!1}"
     two_level_expressions nil)
    (v1!1 skolem-const-decl "{v1: (input_expr_th.FPVariable?) |
         v1 = FPOperator3_var!1 OR v1 << FPOperator3_var!1}"
     two_level_expressions nil)
    (v1!2 skolem-const-decl "{v1: (input_expr_th.FPVariable?) |
         v1 = FPOperator3_var!1 OR v1 << FPOperator3_var!1}"
     two_level_expressions nil)
    (v1!2 skolem-const-decl "{v1: (input_expr_th.FPVariable?) |
         v1 = FPOperator3_var!1 OR v1 << FPOperator3_var!1}"
     two_level_expressions nil)
    (FPParameter adt-constructor-decl
     "[ParameterIndex -> (FPParameter?)]" expressions nil)
    (ParameterIndex nonempty-type-eq-decl nil expressions nil)
    (TRUE const-decl "bool" booleans nil)
    (FPAExpr_FPVariable_extensionality formula-decl nil expressions
     nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (FPVariable adt-constructor-decl "[DeBruijnIndex -> (FPVariable?)]"
     expressions nil)
    (FPVariable1_var skolem-const-decl "DeBruijnIndex
    [(operatorUnderAnalysis?), RealNumber, FloatingPointNumber, FtoR]"
     two_level_expressions nil)
    (v skolem-const-decl "{v: (analysis_expr_th.FPVariable?) |
         v = iFToAF(FPVariable(FPVariable1_var)) OR
          v << iFToAF(FPVariable(FPVariable1_var))}"
     two_level_expressions nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (FPConstant? adt-recognizer-decl "[FPAExpr -> boolean]" expressions
     nil)
    (FPConstant adt-constructor-decl "[FPNumber -> (FPConstant?)]"
     expressions nil)
    (FPNumber nonempty-type-eq-decl nil expressions nil)
    (FPAExpr_induction formula-decl nil expressions nil)
    (Operator formal-nonempty-type-decl nil two_level_expressions nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (PRED type-eq-decl nil defined_types nil)
    (operatorUnderAnalysis? formal-const-decl
     "{p: PRED[Operator] | EXISTS (op: Operator): p(op)}"
     two_level_expressions nil)
    (RealNumber formal-nonempty-type-decl nil two_level_expressions
     nil)
    (FloatingPointNumber formal-nonempty-type-decl nil
     two_level_expressions nil)
    (FtoR formal-const-decl "[FloatingPointNumber -> RealNumber]"
     two_level_expressions nil)
    (index shared-adt-accessor-decl
           "[{x: FPAExpr | FPVariable?(x) OR FPParameter?(x)} -> DeBruijnIndex]"
           expressions nil)
    (DeBruijnIndex nonempty-type-eq-decl nil expressions nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (FPParameter? adt-recognizer-decl "[FPAExpr -> boolean]"
     expressions nil)
    (number nonempty-type-decl nil numbers nil)
    (<< adt-def-decl "(strict_well_founded?[FPAExpr])" expressions nil)
    (strict_well_founded? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (iFToAF def-decl "analysis_expr_th.FPAExpr" two_level_expressions
     nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (FPVariable? adt-recognizer-decl "[FPAExpr -> boolean]" expressions
     nil)
    (FPAExpr type-decl nil expressions nil))
   nil))
 (input_esem_th_TCC1 0
  (input_esem_th_TCC1-1 nil 3757437702 ("" (use "lt_fp_lt_r") nil nil)
   ((lt_fp_lt_r formula-decl nil two_level_expressions nil)) nil))
 (appears?_analysis_local_input_locals 0
  (appears?_analysis_local_input_locals-1 nil 3757500366
   ("" (skeep :but "are")
    (("" (induct "are")
      (("1" (grind) nil nil)
       ("2" (skolem 1 "i")
        (("2" (flatten)
          (("2" (expand "iRToAR")
            (("2" (expand "appears?")
              (("2" (expand "appearsFree?")
                (("2" (inst 1 "RVariable(i)") (("2" (assert) nil nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("3" (grind) nil nil)
       ("4" (skolem 1 ("op" "are1" "are2"))
        (("4" (flatten)
          (("4" (rewrite "appears?_rexpr_subterm")
            (("4" (rewrite "appears?_rexpr_subterm")
              (("4" (rewrite "appears?_rexpr_subterm")
                (("4" (expand "subterm" -3)
                  (("4" (split -3)
                    (("1" (assert)
                      (("1" (skeep -2 :preds? t)
                        (("1" (inst 1 "irlocal")
                          (("1" (rewrite "appears?_rexpr_subterm")
                            (("1" (rewrite "appears?_rexpr_subterm")
                              (("1"
                                (expand "subterm" 1)
                                (("1" (assert) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil)
                     ("2" (assert)
                      (("2" (skeep -3 :preds? t)
                        (("2" (inst 1 "irlocal")
                          (("2" (rewrite "appears?_rexpr_subterm" 1)
                            (("2" (expand "subterm" 1)
                              (("2"
                                (rewrite "appears?_rexpr_subterm")
                                (("2" (assert) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((rvariable_irtoar_rlocal application-judgement
     "(analysis_expr_th.RVariable?)" two_level_expressions nil)
    (RAExpr type-decl nil expressions nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (RVariable? adt-recognizer-decl "[RAExpr -> boolean]" expressions
     nil)
    (appears? const-decl "bool" expressions nil)
    (PRED type-eq-decl nil defined_types nil)
    (operatorUnderAnalysis? formal-const-decl
     "{p: PRED[Operator] | EXISTS (op: Operator): p(op)}"
     two_level_expressions nil)
    (number nonempty-type-decl nil numbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (RParameter? adt-recognizer-decl "[RAExpr -> boolean]" expressions
     nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (DeBruijnIndex nonempty-type-eq-decl nil expressions nil)
    (index shared-adt-accessor-decl
           "[{x: RAExpr | RVariable?(x) OR RParameter?(x)} -> DeBruijnIndex]"
           expressions nil)
    (iRToAR def-decl "analysis_expr_th.RAExpr" two_level_expressions
     nil)
    (FtoR formal-const-decl "[FloatingPointNumber -> RealNumber]"
     two_level_expressions nil)
    (FloatingPointNumber formal-nonempty-type-decl nil
     two_level_expressions nil)
    (RealNumber formal-nonempty-type-decl nil two_level_expressions
     nil)
    (Operator formal-nonempty-type-decl nil two_level_expressions nil)
    (RAExpr_induction formula-decl nil expressions nil)
    (appearsFree? def-decl "bool" expressions nil)
    (i skolem-const-decl
     "DeBruijnIndex[Operator, RealNumber, FloatingPointNumber, FtoR]"
     two_level_expressions nil)
    (arlocal skolem-const-decl "(analysis_expr_th.RVariable?)"
     two_level_expressions nil)
    (RVariable adt-constructor-decl "[DeBruijnIndex -> (RVariable?)]"
     expressions nil)
    (subterm adt-def-decl "boolean" expressions nil)
    (ROperator? adt-recognizer-decl "[RAExpr -> boolean]" expressions
     nil)
    (ROperator adt-constructor-decl
     "[[Operator, RAExpr, RAExpr] -> (ROperator?)]" expressions nil)
    (appears?_rexpr_subterm formula-decl nil expressions nil))
   shostak))
 (appears?_analysis_iRToAR_rexpr 0
  (appears?_analysis_iRToAR_rexpr-1 nil 3757501227
   ("" (skeep :but "ire") (("" (induct-and-simplify "ire") nil nil))
    nil)
   ((int_minus_int_is_int application-judgement "int" integers nil)
    (appearsFree? def-decl "bool" expressions nil)
    (RAExpr_induction formula-decl nil expressions nil)
    (Operator formal-nonempty-type-decl nil two_level_expressions nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (PRED type-eq-decl nil defined_types nil)
    (operatorUnderAnalysis? formal-const-decl
     "{p: PRED[Operator] | EXISTS (op: Operator): p(op)}"
     two_level_expressions nil)
    (RealNumber formal-nonempty-type-decl nil two_level_expressions
     nil)
    (FloatingPointNumber formal-nonempty-type-decl nil
     two_level_expressions nil)
    (FtoR formal-const-decl "[FloatingPointNumber -> RealNumber]"
     two_level_expressions nil)
    (iRToAR def-decl "analysis_expr_th.RAExpr" two_level_expressions
     nil)
    (appears? const-decl "bool" expressions nil)
    (RVariable? adt-recognizer-decl "[RAExpr -> boolean]" expressions
     nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (IRExpr type-eq-decl nil two_level_expressions nil)
    (RAExpr type-decl nil expressions nil)
    (rvariable_irtoar_rlocal application-judgement
     "(analysis_expr_th.RVariable?)" two_level_expressions nil))
   shostak))
 (iRToAR_env_TCC1 0
  (iRToAR_env_TCC1-2 "" 3757691417
   ("" (skeep* :preds? t) (("" (grind) nil nil)) nil)
   ((size_empty formula-decl nil u_local_environment nil)
    (RAExpr type-decl nil expressions nil)
    (RVariable? adt-recognizer-decl "[RAExpr -> boolean]" expressions
     nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (rVarIndex const-decl "nat" expressions_semantics nil)
    (strict_well_founded? const-decl "bool" orders nil)
    (<< adt-def-decl "(strict_well_founded?[RAExpr])" expressions nil)
    (REmptyLocalEnv const-decl "RLocalEnvironment"
     expressions_semantics nil)
    (Operator formal-nonempty-type-decl nil two_level_expressions nil)
    (RealNumber formal-nonempty-type-decl nil two_level_expressions
     nil)
    (pred type-eq-decl nil defined_types nil)
    (strict_total_order? const-decl "bool" orders nil)
    (lt_r formal-const-decl "(strict_total_order?[RealNumber])"
     two_level_expressions nil)
    (applyFun_r formal-const-decl
     "[[Operator, RealNumber, RealNumber] -> RealNumber]"
     two_level_expressions nil)
    (FloatingPointNumber formal-nonempty-type-decl nil
     two_level_expressions nil)
    (lt_fp formal-const-decl
     "(strict_total_order?[FloatingPointNumber])" two_level_expressions
     nil)
    (applyFun_fp formal-const-decl
     "[[Operator, FloatingPointNumber, FloatingPointNumber] ->
   FloatingPointNumber]" two_level_expressions nil)
    (FtoR formal-const-decl "[FloatingPointNumber -> RealNumber]"
     two_level_expressions nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   shostak)
  (iRToAR_env_TCC1-1 nil 3757440997
   ("" (skeep* :preds? t)
    (("" (expand "bounded_by?")
      (("" (skeep :preds? t)
        (("" (use "iRToAR_rexpr_var_existence")
          (("" (skeep -1 :preds? t)
            (("" (inst -7 "v1") (("" (assert) nil nil)) nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((size_empty formula-decl nil u_local_environment nil)
    (RAExpr type-decl nil expressions nil)
    (RVariable? adt-recognizer-decl "[RAExpr -> boolean]" expressions
     nil)
    (rVarIndex const-decl "nat" expressions_semantics nil)
    (RParameter? adt-recognizer-decl "[RAExpr -> boolean]" expressions
     nil)
    (DeBruijnIndex nonempty-type-eq-decl nil expressions nil)
    (index shared-adt-accessor-decl
           "[{x: RAExpr | RVariable?(x) OR RParameter?(x)} -> DeBruijnIndex]"
           expressions nil)
    (maxFreeLocalIndex_RAExpr def-decl "{maxInd: upfrom(-1) |
         IF EXISTS (local: (RVariable?)): subterm(local, rexpr)
           THEN (EXISTS (local: (RVariable?) | subterm(local, rexpr)):
                   index(local) = maxInd)
                 AND
                 (FORALL (local: (RVariable?) | subterm(local, rexpr)):
                    index(local) <= maxInd)
         ELSE maxInd = -1
         ENDIF}" expressions nil)
    (<< adt-def-decl "(strict_well_founded?[RAExpr])" expressions nil)
    (REmptyLocalEnv const-decl "RLocalEnvironment"
     expressions_semantics nil))
   nil))
 (iRToAR_env_TCC2 0
  (iRToAR_env_TCC2-1 nil 3757440997
   ("" (skeep* :preds? t) (("" (assert) nil nil)) nil)
   ((real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil))
 (iRToAR_env_TCC3 0
  (iRToAR_env_TCC3-2 nil 3757682905
   ("" (skeep* :preds? t)
    (("" (expand "shrink_renv")
      (("" (assert)
        (("" (rewrite "size_shrink") (("" (assert) nil nil)) nil))
        nil))
      nil))
    nil)
   ((shrink_renv const-decl "RLocalEnvironment" expressions_semantics
     nil)
    (size_shrink formula-decl nil u_local_environment nil)
    (LocalEnvironment nonempty-type-decl nil u_local_environment nil)
    (RLocalEnvironment type-eq-decl nil expressions_semantics nil)
    (< const-decl "bool" reals nil)
    (size const-decl "nat" u_local_environment nil)
    (below type-eq-decl nil naturalnumbers nil)
    (Operator formal-nonempty-type-decl nil two_level_expressions nil)
    (PRED type-eq-decl nil defined_types nil)
    (operatorUnderAnalysis? formal-const-decl
     "{p: PRED[Operator] | EXISTS (op: Operator): p(op)}"
     two_level_expressions nil)
    (RealNumber formal-nonempty-type-decl nil two_level_expressions
     nil)
    (FloatingPointNumber formal-nonempty-type-decl nil
     two_level_expressions nil)
    (FtoR formal-const-decl "[FloatingPointNumber -> RealNumber]"
     two_level_expressions nil)
    (RAExpr type-decl nil expressions nil)
    (RVariable? adt-recognizer-decl "[RAExpr -> boolean]" expressions
     nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (pred type-eq-decl nil defined_types nil)
    (strict_total_order? const-decl "bool" orders nil)
    (lt_r formal-const-decl "(strict_total_order?[RealNumber])"
     two_level_expressions nil)
    (restrict const-decl "R" restrict nil)
    (applyFun_r formal-const-decl
     "[[Operator, RealNumber, RealNumber] -> RealNumber]"
     two_level_expressions nil)
    (lt_fp formal-const-decl
     "(strict_total_order?[FloatingPointNumber])" two_level_expressions
     nil)
    (applyFun_fp formal-const-decl
     "[[Operator, FloatingPointNumber, FloatingPointNumber] ->
   FloatingPointNumber]" two_level_expressions nil)
    (rVarIndex const-decl "nat" expressions_semantics nil)
    (strict_well_founded? const-decl "bool" orders nil)
    (<< adt-def-decl "(strict_well_founded?[RAExpr])" expressions nil)
    (even_plus_odd_is_odd application-judgement "odd_int" integers nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil)
  (iRToAR_env_TCC3-1 nil 3757682202 ("" (termination-tcc) nil nil) nil
   nil))
 (iRToAR_env_TCC4 0
  (iRToAR_env_TCC4-2 "" 3757691625
   ("" (skeep* :preds? t)
    (("" (expand "get_renv")
      (("" (expand "shrink_renv")
        (("" (typepred "v(shrink(rLocalEnv, 0))")
          ((""
            (use "local_definitions_are_evaluable_in_smaller_env[RAExpr
            [(operatorUnderAnalysis?), RealNumber, FloatingPointNumber,
             FtoR],
        RVariable?, rVarIndex, 
        <<]")
            (("" (expand "bounded_by?")
              (("" (skeep 2 :preds? t)
                (("" (use "iRToAR_rexpr_var_existence")
                  (("" (skeep -1 :preds? t)
                    (("" (inst -6 "v1")
                      (("" (assert)
                        (("" (expand "rVarIndex")
                          (("" (assert) nil nil)) nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((get_renv const-decl "RAExpr" expressions_semantics nil)
    (RLocalEnvironment type-eq-decl nil expressions_semantics nil)
    (shrink const-decl "LocalEnvironment" u_local_environment nil)
    (below type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (size const-decl "nat" u_local_environment nil)
    (LocalEnvironment nonempty-type-decl nil u_local_environment nil)
    (<< adt-def-decl "(strict_well_founded?[RAExpr])" expressions nil)
    (strict_well_founded? const-decl "bool" orders nil)
    (rVarIndex const-decl "nat" expressions_semantics nil)
    (applyFun_fp formal-const-decl
     "[[Operator, FloatingPointNumber, FloatingPointNumber] ->
   FloatingPointNumber]" two_level_expressions nil)
    (lt_fp formal-const-decl
     "(strict_total_order?[FloatingPointNumber])" two_level_expressions
     nil)
    (applyFun_r formal-const-decl
     "[[Operator, RealNumber, RealNumber] -> RealNumber]"
     two_level_expressions nil)
    (restrict const-decl "R" restrict nil)
    (lt_r formal-const-decl "(strict_total_order?[RealNumber])"
     two_level_expressions nil)
    (strict_total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (RVariable? adt-recognizer-decl "[RAExpr -> boolean]" expressions
     nil)
    (RAExpr type-decl nil expressions nil)
    (FtoR formal-const-decl "[FloatingPointNumber -> RealNumber]"
     two_level_expressions nil)
    (FloatingPointNumber formal-nonempty-type-decl nil
     two_level_expressions nil)
    (RealNumber formal-nonempty-type-decl nil two_level_expressions
     nil)
    (operatorUnderAnalysis? formal-const-decl
     "{p: PRED[Operator] | EXISTS (op: Operator): p(op)}"
     two_level_expressions nil)
    (PRED type-eq-decl nil defined_types nil)
    (Operator formal-nonempty-type-decl nil two_level_expressions nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bounded_by? const-decl "bool" u_local_environment nil)
    (iRToAR_rexpr_var_existence formula-decl nil two_level_expressions
     nil)
    (get const-decl "T" u_local_environment nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (iRToAR def-decl "analysis_expr_th.RAExpr" two_level_expressions
     nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (local_definitions_are_evaluable_in_smaller_env formula-decl nil
     u_local_environment nil)
    (shrink_renv const-decl "RLocalEnvironment" expressions_semantics
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   shostak)
  (iRToAR_env_TCC4-1 nil 3757682202
   ("" (skeep* :preds? t)
    (("" (expand "get_renv")
      (("" (typepred "v(shrink(rLocalEnv, 0))")
        (("" (inst -1 "input_esem_th.get_renv(rLocalEnv)(0)")
          (("" (expand "get_renv") (("" (assert) nil nil)) nil)) nil))
        nil))
      nil))
    nil)
   ((get_renv const-decl "RAExpr" expressions_semantics nil)
    (RLocalEnvironment type-eq-decl nil expressions_semantics nil)
    (shrink const-decl "LocalEnvironment" u_local_environment nil)
    (size const-decl "nat" u_local_environment nil)
    (LocalEnvironment nonempty-type-decl nil u_local_environment nil)
    (<< adt-def-decl "(strict_well_founded?[RAExpr])" expressions nil)
    (maxFreeLocalIndex_RAExpr def-decl "{maxInd: upfrom(-1) |
         IF EXISTS (local: (RVariable?)): subterm(local, rexpr)
           THEN (EXISTS (local: (RVariable?) | subterm(local, rexpr)):
                   index(local) = maxInd)
                 AND
                 (FORALL (local: (RVariable?) | subterm(local, rexpr)):
                    index(local) <= maxInd)
         ELSE maxInd = -1
         ENDIF}" expressions nil)
    (index shared-adt-accessor-decl
           "[{x: RAExpr | RVariable?(x) OR RParameter?(x)} -> DeBruijnIndex]"
           expressions nil)
    (DeBruijnIndex nonempty-type-eq-decl nil expressions nil)
    (RParameter? adt-recognizer-decl "[RAExpr -> boolean]" expressions
     nil)
    (rVarIndex const-decl "nat" expressions_semantics nil)
    (RVariable? adt-recognizer-decl "[RAExpr -> boolean]" expressions
     nil)
    (RAExpr type-decl nil expressions nil)
    (bounded_by? const-decl "bool" u_local_environment nil)
    (get const-decl "T" u_local_environment nil)
    (local_definitions_are_evaluable_in_smaller_env formula-decl nil
     u_local_environment nil)
    (shrink_renv const-decl "RLocalEnvironment" expressions_semantics
     nil))
   nil))
 (iRToAR_env_TCC5 0
  (iRToAR_env_TCC5-2 "" 3757692214
   ("" (skeep* :preds? t)
    (("" (expand "shrink_renv")
      (("" (expand "get_renv")
        (("" (expand "cons_renv")
          (("" (typepred "v(shrink(rLocalEnv, 0))")
            ((""
              (use "u_local_environment
               [RAExpr[Operator, RealNumber, FloatingPointNumber, FtoR],
                RVariable?, rVarIndex,  <<].size_cons_def")
              (("1" (replace -1 :hide? t)
                (("1" (assert)
                  (("1" (replace -1 :hide? t :dir rl)
                    (("1"
                      (use "size_cons_def[RAExpr
            [(operatorUnderAnalysis?), RealNumber, FloatingPointNumber,
             FtoR],
        RVariable?, rVarIndex,  <<]")
                      (("1"
                        (inst -1
                         "input_esem_th.get_renv(rLocalEnv)(0)")
                        (("1" (expand "get_renv")
                          (("1"
                            (use "env_cons_eta[RAExpr
            [(operatorUnderAnalysis?), RealNumber, FloatingPointNumber,
             FtoR],
        RVariable?, rVarIndex,  <<]")
                            (("1" (replace -1 :hide? t)
                              (("1" (propax) nil nil)) nil))
                            nil))
                          nil)
                         ("2" (expand "get_renv")
                          (("2" (assert) nil nil)) nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("2"
                (use "local_definitions_are_evaluable_in_smaller_env[RAExpr
            [(operatorUnderAnalysis?), RealNumber, FloatingPointNumber,
             FtoR],
        RVariable?, rVarIndex, 
        <<]")
                (("2" (hide 2 3)
                  (("2" (expand "bounded_by?")
                    (("2" (skeep 1 :preds? t)
                      (("2" (use "iRToAR_rexpr_var_existence")
                        (("2" (skeep -1 :preds? t)
                          (("2" (inst -6 "v1")
                            (("2" (expand "rVarIndex")
                              (("2" (assert) nil nil)) nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((shrink_renv const-decl "RLocalEnvironment" expressions_semantics
     nil)
    (cons_renv const-decl "RLocalEnvironment" expressions_semantics
     nil)
    (size_cons_def formula-decl nil u_local_environment nil)
    (get const-decl "T" u_local_environment nil)
    (iRToAR def-decl "analysis_expr_th.RAExpr" two_level_expressions
     nil)
    (v skolem-const-decl "[rLocalEnv1:
   {z:
      RLocalEnvironment
          [(operatorUnderAnalysis?), RealNumber, lt_r,
           restrict
               [[Operator, RealNumber, RealNumber],
                [(operatorUnderAnalysis?), RealNumber, RealNumber],
                RealNumber]
               (applyFun_r),
           FloatingPointNumber, lt_fp,
           restrict
               [[Operator, FloatingPointNumber, FloatingPointNumber],
                [(operatorUnderAnalysis?), FloatingPointNumber,
                 FloatingPointNumber],
                FloatingPointNumber]
               (applyFun_fp),
           FtoR] |
            size(z) < size(rLocalEnv)} ->
   {arLocalEnv: analysis_esem_th.RLocalEnvironment |
            size(rLocalEnv1) = size(arLocalEnv)}]"
     two_level_expressions nil)
    (rLocalEnv skolem-const-decl "input_esem_th
    [(operatorUnderAnalysis?), RealNumber, lt_r,
     restrict
         [[Operator, RealNumber, RealNumber],
          [(operatorUnderAnalysis?), RealNumber, RealNumber], RealNumber]
         (applyFun_r),
     FloatingPointNumber, lt_fp,
     restrict
         [[Operator, FloatingPointNumber, FloatingPointNumber],
          [(operatorUnderAnalysis?), FloatingPointNumber,
           FloatingPointNumber],
          FloatingPointNumber]
         (applyFun_fp),
     FtoR].RLocalEnvironment" two_level_expressions nil)
    (bounded_by? const-decl "bool" u_local_environment nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (even_minus_odd_is_odd application-judgement "odd_int" integers
     nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (odd_minus_odd_is_even application-judgement "even_int" integers
     nil)
    (local_definitions_are_evaluable_in_smaller_env formula-decl nil
     u_local_environment nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (env_cons_eta formula-decl nil u_local_environment nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (iRToAR_rexpr_var_existence formula-decl nil two_level_expressions
     nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (Operator formal-nonempty-type-decl nil two_level_expressions nil)
    (PRED type-eq-decl nil defined_types nil)
    (operatorUnderAnalysis? formal-const-decl
     "{p: PRED[Operator] | EXISTS (op: Operator): p(op)}"
     two_level_expressions nil)
    (RealNumber formal-nonempty-type-decl nil two_level_expressions
     nil)
    (FloatingPointNumber formal-nonempty-type-decl nil
     two_level_expressions nil)
    (FtoR formal-const-decl "[FloatingPointNumber -> RealNumber]"
     two_level_expressions nil)
    (RAExpr type-decl nil expressions nil)
    (RVariable? adt-recognizer-decl "[RAExpr -> boolean]" expressions
     nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (pred type-eq-decl nil defined_types nil)
    (strict_total_order? const-decl "bool" orders nil)
    (lt_r formal-const-decl "(strict_total_order?[RealNumber])"
     two_level_expressions nil)
    (restrict const-decl "R" restrict nil)
    (applyFun_r formal-const-decl
     "[[Operator, RealNumber, RealNumber] -> RealNumber]"
     two_level_expressions nil)
    (lt_fp formal-const-decl
     "(strict_total_order?[FloatingPointNumber])" two_level_expressions
     nil)
    (applyFun_fp formal-const-decl
     "[[Operator, FloatingPointNumber, FloatingPointNumber] ->
   FloatingPointNumber]" two_level_expressions nil)
    (rVarIndex const-decl "nat" expressions_semantics nil)
    (strict_well_founded? const-decl "bool" orders nil)
    (<< adt-def-decl "(strict_well_founded?[RAExpr])" expressions nil)
    (LocalEnvironment nonempty-type-decl nil u_local_environment nil)
    (size const-decl "nat" u_local_environment nil)
    (< const-decl "bool" reals nil)
    (below type-eq-decl nil naturalnumbers nil)
    (shrink const-decl "LocalEnvironment" u_local_environment nil)
    (RLocalEnvironment type-eq-decl nil expressions_semantics nil)
    (get_renv const-decl "RAExpr" expressions_semantics nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   shostak)
  (iRToAR_env_TCC5-1 nil 3757682202
   ("" (skeep* :preds? t)
    (("" (expand "shrink_renv")
      (("" (expand "get_renv")
        (("" (expand "cons_renv")
          (("" (typepred "v(shrink(rLocalEnv, 0))")
            (("" (inst -1 "irexpr")
              (("" (split -1)
                (("1" (expand "bounded_by?")
                  (("1" (skeep 2 :preds? t)
                    (("1" (use "iRToAR_rexpr_var_existence")
                      (("1" (skeep -1 :preds? t)
                        (("1" (inst -6 "v_1")
                          (("1"
                            (use "u_local_environment
       [RAExpr[Operator, RealNumber, FloatingPointNumber, FtoR],
        RVariable?, rVarIndex,  <<].size_cons_def")
                            (("1" (assert) nil nil)
                             ("2" (typepred "v(shrink(rLocalEnv, 0))")
                              (("2"
                                (inst? -1 :where 1)
                                (("2" (assert) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (expand "bounded_by?")
                  (("2" (skeep 3 :preds? t)
                    (("2" (skeep 1 :preds? t)
                      (("2"
                        (rewrite "u_local_environment
       [RAExpr[Operator, RealNumber, FloatingPointNumber, FtoR],
        RVariable?, rVarIndex,  <<].size_cons_def")
                        (("1"
                          (case "u_local_environment[expressions[Operator, RealNumber, FloatingPointNumber, FtoR].RAExpr,expressions[Operator, RealNumber, FloatingPointNumber, FtoR].RVariable?,expressions_semantics
    [Operator, RealNumber, lt_r, applyFun_r, FloatingPointNumber, lt_fp,
     applyFun_fp, FtoR].rVarIndex,expressions
    [Operator, RealNumber, FloatingPointNumber, FtoR].expressions[Operator, RealNumber, FloatingPointNumber, FtoR].<<].size(v(r_local_env.shrink(rLocalEnv, 0))) = u_local_environment[expressions
    [(operatorUnderAnalysis?), RealNumber, FloatingPointNumber, FtoR].RAExpr,expressions
    [(operatorUnderAnalysis?), RealNumber, FloatingPointNumber,
     FtoR].RVariable?,expressions_semantics
    [(operatorUnderAnalysis?), RealNumber, lt_r,
     restrict
         [[Operator, RealNumber, RealNumber],
          [(operatorUnderAnalysis?), RealNumber, RealNumber], RealNumber]
         (applyFun_r),
     FloatingPointNumber, lt_fp,
     restrict
         [[Operator, FloatingPointNumber, FloatingPointNumber],
          [(operatorUnderAnalysis?), FloatingPointNumber,
           FloatingPointNumber],
          FloatingPointNumber]
         (applyFun_fp),
     FtoR].rVarIndex,expressions
    [(operatorUnderAnalysis?), RealNumber, FloatingPointNumber,
     FtoR].expressions
    [(operatorUnderAnalysis?), RealNumber, FloatingPointNumber, FtoR].<<].size(shrink(rLocalEnv, 0))")
                          (("1" (replace -1 :hide? t)
                            (("1" (expand "rVarIndex")
                              (("1"
                                (inst -5 "v!1")
                                (("1" (postpone) nil nil))
                                nil))
                              nil))
                            nil)
                           ("2" (postpone) nil nil))
                          nil)
                         ("2" (typepred "v(shrink(rLocalEnv, 0))")
                          (("2" (inst? -1 :where 1)
                            (("2" (assert) nil nil)) nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   nil nil))
 (iFToAF_env_TCC1 0
  (iFToAF_env_TCC1-1 nil 3757501814 ("" (grind) nil nil)
   ((FtoR formal-const-decl "[FloatingPointNumber -> RealNumber]"
     two_level_expressions nil)
    (applyFun_fp formal-const-decl
     "[[Operator, FloatingPointNumber, FloatingPointNumber] ->
   FloatingPointNumber]" two_level_expressions nil)
    (lt_fp formal-const-decl
     "(strict_total_order?[FloatingPointNumber])" two_level_expressions
     nil)
    (FloatingPointNumber formal-nonempty-type-decl nil
     two_level_expressions nil)
    (applyFun_r formal-const-decl
     "[[Operator, RealNumber, RealNumber] -> RealNumber]"
     two_level_expressions nil)
    (lt_r formal-const-decl "(strict_total_order?[RealNumber])"
     two_level_expressions nil)
    (strict_total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (RealNumber formal-nonempty-type-decl nil two_level_expressions
     nil)
    (Operator formal-nonempty-type-decl nil two_level_expressions nil)
    (FPEmptyLocalEnv const-decl "FPLocalEnvironment"
     expressions_semantics nil)
    (<< adt-def-decl "(strict_well_founded?[FPAExpr])" expressions nil)
    (strict_well_founded? const-decl "bool" orders nil)
    (fpVarIndex const-decl "nat" expressions_semantics nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (FPVariable? adt-recognizer-decl "[FPAExpr -> boolean]" expressions
     nil)
    (FPAExpr type-decl nil expressions nil)
    (size_empty formula-decl nil u_local_environment nil))
   nil))
 (iFToAF_env_TCC2 0
  (iFToAF_env_TCC2-2 nil 3757502969 ("" (grind) nil nil)
   ((real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil))
   nil)
  (iFToAF_env_TCC2-1 nil 3757501814 ("" (termination-tcc) nil nil) nil
   nil))
 (iFToAF_env_TCC3 0
  (iFToAF_env_TCC3-2 nil 3757694113
   ("" (skeep* :preds? t)
    (("" (expand "shrink_fpenv")
      (("" (assert)
        (("" (rewrite "size_shrink") (("" (assert) nil nil)) nil))
        nil))
      nil))
    nil)
   ((shrink_fpenv const-decl "FPLocalEnvironment" expressions_semantics
     nil)
    (size_shrink formula-decl nil u_local_environment nil)
    (LocalEnvironment nonempty-type-decl nil u_local_environment nil)
    (FPLocalEnvironment type-eq-decl nil expressions_semantics nil)
    (< const-decl "bool" reals nil)
    (size const-decl "nat" u_local_environment nil)
    (below type-eq-decl nil naturalnumbers nil)
    (Operator formal-nonempty-type-decl nil two_level_expressions nil)
    (PRED type-eq-decl nil defined_types nil)
    (operatorUnderAnalysis? formal-const-decl
     "{p: PRED[Operator] | EXISTS (op: Operator): p(op)}"
     two_level_expressions nil)
    (RealNumber formal-nonempty-type-decl nil two_level_expressions
     nil)
    (FloatingPointNumber formal-nonempty-type-decl nil
     two_level_expressions nil)
    (FtoR formal-const-decl "[FloatingPointNumber -> RealNumber]"
     two_level_expressions nil)
    (FPAExpr type-decl nil expressions nil)
    (FPVariable? adt-recognizer-decl "[FPAExpr -> boolean]" expressions
     nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (pred type-eq-decl nil defined_types nil)
    (strict_total_order? const-decl "bool" orders nil)
    (lt_r formal-const-decl "(strict_total_order?[RealNumber])"
     two_level_expressions nil)
    (restrict const-decl "R" restrict nil)
    (applyFun_r formal-const-decl
     "[[Operator, RealNumber, RealNumber] -> RealNumber]"
     two_level_expressions nil)
    (lt_fp formal-const-decl
     "(strict_total_order?[FloatingPointNumber])" two_level_expressions
     nil)
    (applyFun_fp formal-const-decl
     "[[Operator, FloatingPointNumber, FloatingPointNumber] ->
   FloatingPointNumber]" two_level_expressions nil)
    (fpVarIndex const-decl "nat" expressions_semantics nil)
    (strict_well_founded? const-decl "bool" orders nil)
    (<< adt-def-decl "(strict_well_founded?[FPAExpr])" expressions nil)
    (even_plus_odd_is_odd application-judgement "odd_int" integers nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil)
  (iFToAF_env_TCC3-1 nil 3757682202 ("" (subtype-tcc) nil nil) nil
   nil))
 (iFToAF_env_TCC4 0
  (iFToAF_env_TCC4-2 nil 3757694289
   ("" (skeep* :preds? t)
    (("" (expand "get_fpenv")
      (("" (expand "shrink_fpenv")
        (("" (typepred "v(shrink(fpLocalEnv, 0))")
          ((""
            (use "local_definitions_are_evaluable_in_smaller_env[FPAExpr
                  [(operatorUnderAnalysis?), RealNumber, FloatingPointNumber,
                   FtoR],
              FPVariable?, fpVarIndex, 
              <<]")
            (("" (expand "bounded_by?")
              (("" (skeep 2 :preds? t)
                (("" (use "iFToAF_expr_var_existence")
                  (("" (skeep -1 :preds? t)
                    (("" (inst -6 "v1")
                      (("" (assert)
                        (("" (expand "fpVarIndex")
                          (("" (assert) nil nil)) nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((get_fpenv const-decl "FPAExpr" expressions_semantics nil)
    (FPLocalEnvironment type-eq-decl nil expressions_semantics nil)
    (shrink const-decl "LocalEnvironment" u_local_environment nil)
    (below type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (size const-decl "nat" u_local_environment nil)
    (LocalEnvironment nonempty-type-decl nil u_local_environment nil)
    (<< adt-def-decl "(strict_well_founded?[FPAExpr])" expressions nil)
    (strict_well_founded? const-decl "bool" orders nil)
    (fpVarIndex const-decl "nat" expressions_semantics nil)
    (applyFun_fp formal-const-decl
     "[[Operator, FloatingPointNumber, FloatingPointNumber] ->
   FloatingPointNumber]" two_level_expressions nil)
    (lt_fp formal-const-decl
     "(strict_total_order?[FloatingPointNumber])" two_level_expressions
     nil)
    (applyFun_r formal-const-decl
     "[[Operator, RealNumber, RealNumber] -> RealNumber]"
     two_level_expressions nil)
    (restrict const-decl "R" restrict nil)
    (lt_r formal-const-decl "(strict_total_order?[RealNumber])"
     two_level_expressions nil)
    (strict_total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (FPVariable? adt-recognizer-decl "[FPAExpr -> boolean]" expressions
     nil)
    (FPAExpr type-decl nil expressions nil)
    (FtoR formal-const-decl "[FloatingPointNumber -> RealNumber]"
     two_level_expressions nil)
    (FloatingPointNumber formal-nonempty-type-decl nil
     two_level_expressions nil)
    (RealNumber formal-nonempty-type-decl nil two_level_expressions
     nil)
    (operatorUnderAnalysis? formal-const-decl
     "{p: PRED[Operator] | EXISTS (op: Operator): p(op)}"
     two_level_expressions nil)
    (PRED type-eq-decl nil defined_types nil)
    (Operator formal-nonempty-type-decl nil two_level_expressions nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bounded_by? const-decl "bool" u_local_environment nil)
    (iFToAF_expr_var_existence formula-decl nil two_level_expressions
     nil)
    (get const-decl "T" u_local_environment nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (iFToAF def-decl "analysis_expr_th.FPAExpr" two_level_expressions
     nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (local_definitions_are_evaluable_in_smaller_env formula-decl nil
     u_local_environment nil)
    (shrink_fpenv const-decl "FPLocalEnvironment" expressions_semantics
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil)
  (iFToAF_env_TCC4-1 nil 3757693886 ("" (subtype-tcc) nil nil) nil
   nil))
 (iFToAF_env_TCC5 0
  (iFToAF_env_TCC5-2 nil 3757694515
   ("" (skeep* :preds? t)
    (("" (expand "shrink_fpenv")
      (("" (expand "get_fpenv")
        (("" (expand "cons_fpenv")
          (("" (typepred "v(shrink(fpLocalEnv, 0))")
            ((""
              (use "u_local_environment
                     [FPAExpr[Operator, RealNumber, FloatingPointNumber, FtoR],
                      FPVariable?, fpVarIndex,  <<].size_cons_def")
              (("1" (replace -1 :hide? t)
                (("1" (assert)
                  (("1" (replace -1 :hide? t :dir rl)
                    (("1"
                      (use "size_cons_def[FPAExpr
                    [(operatorUnderAnalysis?), RealNumber, FloatingPointNumber,
                     FtoR],
                FPVariable?, fpVarIndex,  <<]")
                      (("1"
                        (inst -1
                         "input_esem_th.get_fpenv(fpLocalEnv)(0)")
                        (("1" (expand "get_fpenv")
                          (("1"
                            (use "env_cons_eta[FPAExpr
                      [(operatorUnderAnalysis?), RealNumber, FloatingPointNumber,
                       FtoR],
                  FPVariable?, fpVarIndex,  <<]")
                            (("1" (replace -1 :hide? t)
                              (("1" (propax) nil nil)) nil))
                            nil))
                          nil)
                         ("2" (expand "get_fpenv")
                          (("2" (assert) nil nil)) nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("2"
                (use "local_definitions_are_evaluable_in_smaller_env[FPAExpr
                    [(operatorUnderAnalysis?), RealNumber, FloatingPointNumber,
                     FtoR],
                FPVariable?, fpVarIndex, 
                <<]")
                (("2" (hide 2 3)
                  (("2" (expand "bounded_by?")
                    (("2" (skeep 1 :preds? t)
                      (("2" (use "iFToAF_expr_var_existence")
                        (("2" (skeep -1 :preds? t)
                          (("2" (inst -6 "v1")
                            (("2" (expand "fpVarIndex")
                              (("2" (assert) nil nil)) nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((shrink_fpenv const-decl "FPLocalEnvironment" expressions_semantics
     nil)
    (cons_fpenv const-decl "FPLocalEnvironment" expressions_semantics
     nil)
    (size_cons_def formula-decl nil u_local_environment nil)
    (get const-decl "T" u_local_environment nil)
    (iFToAF def-decl "analysis_expr_th.FPAExpr" two_level_expressions
     nil)
    (v skolem-const-decl "[fpLocalEnv1:
   {z:
      FPLocalEnvironment
          [(operatorUnderAnalysis?), RealNumber, lt_r,
           restrict
               [[Operator, RealNumber, RealNumber],
                [(operatorUnderAnalysis?), RealNumber, RealNumber],
                RealNumber]
               (applyFun_r),
           FloatingPointNumber, lt_fp,
           restrict
               [[Operator, FloatingPointNumber, FloatingPointNumber],
                [(operatorUnderAnalysis?), FloatingPointNumber,
                 FloatingPointNumber],
                FloatingPointNumber]
               (applyFun_fp),
           FtoR] |
            size(z) < size(fpLocalEnv)} ->
   {afLocalEnv: analysis_esem_th.FPLocalEnvironment |
            size(fpLocalEnv1) = size(afLocalEnv)}]"
     two_level_expressions nil)
    (fpLocalEnv skolem-const-decl "input_esem_th
    [(operatorUnderAnalysis?), RealNumber, lt_r,
     restrict
         [[Operator, RealNumber, RealNumber],
          [(operatorUnderAnalysis?), RealNumber, RealNumber], RealNumber]
         (applyFun_r),
     FloatingPointNumber, lt_fp,
     restrict
         [[Operator, FloatingPointNumber, FloatingPointNumber],
          [(operatorUnderAnalysis?), FloatingPointNumber,
           FloatingPointNumber],
          FloatingPointNumber]
         (applyFun_fp),
     FtoR].FPLocalEnvironment" two_level_expressions nil)
    (bounded_by? const-decl "bool" u_local_environment nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (even_minus_odd_is_odd application-judgement "odd_int" integers
     nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (odd_minus_odd_is_even application-judgement "even_int" integers
     nil)
    (local_definitions_are_evaluable_in_smaller_env formula-decl nil
     u_local_environment nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (env_cons_eta formula-decl nil u_local_environment nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (iFToAF_expr_var_existence formula-decl nil two_level_expressions
     nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (Operator formal-nonempty-type-decl nil two_level_expressions nil)
    (PRED type-eq-decl nil defined_types nil)
    (operatorUnderAnalysis? formal-const-decl
     "{p: PRED[Operator] | EXISTS (op: Operator): p(op)}"
     two_level_expressions nil)
    (RealNumber formal-nonempty-type-decl nil two_level_expressions
     nil)
    (FloatingPointNumber formal-nonempty-type-decl nil
     two_level_expressions nil)
    (FtoR formal-const-decl "[FloatingPointNumber -> RealNumber]"
     two_level_expressions nil)
    (FPAExpr type-decl nil expressions nil)
    (FPVariable? adt-recognizer-decl "[FPAExpr -> boolean]" expressions
     nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (pred type-eq-decl nil defined_types nil)
    (strict_total_order? const-decl "bool" orders nil)
    (lt_r formal-const-decl "(strict_total_order?[RealNumber])"
     two_level_expressions nil)
    (restrict const-decl "R" restrict nil)
    (applyFun_r formal-const-decl
     "[[Operator, RealNumber, RealNumber] -> RealNumber]"
     two_level_expressions nil)
    (lt_fp formal-const-decl
     "(strict_total_order?[FloatingPointNumber])" two_level_expressions
     nil)
    (applyFun_fp formal-const-decl
     "[[Operator, FloatingPointNumber, FloatingPointNumber] ->
   FloatingPointNumber]" two_level_expressions nil)
    (fpVarIndex const-decl "nat" expressions_semantics nil)
    (strict_well_founded? const-decl "bool" orders nil)
    (<< adt-def-decl "(strict_well_founded?[FPAExpr])" expressions nil)
    (LocalEnvironment nonempty-type-decl nil u_local_environment nil)
    (size const-decl "nat" u_local_environment nil)
    (< const-decl "bool" reals nil)
    (below type-eq-decl nil naturalnumbers nil)
    (shrink const-decl "LocalEnvironment" u_local_environment nil)
    (FPLocalEnvironment type-eq-decl nil expressions_semantics nil)
    (get_fpenv const-decl "FPAExpr" expressions_semantics nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil)
  (iFToAF_env_TCC5-1 nil 3757693886 ("" (subtype-tcc) nil nil) nil
   nil))
 (iRToAR_renv_size 0
  (iRToAR_renv_size-3 "" 3757694735 ("" (grind) nil nil) nil shostak)
  (iRToAR_renv_size-2 "" 3757444634
   (""
    (lemma "u_local_environment
           [RAExpr
                [(operatorUnderAnalysis?), RealNumber, FloatingPointNumber,
                 FtoR],
            RVariable?, rVarIndex, 
            <<].lenv_induction")
    (("" (inst? -1 :where 1)
      (("" (split -1)
        (("1" (propax) nil nil)
         ("2" (hide 2) (("2" (grind) nil nil)) nil)
         ("3" (hide 2)
          (("3" (skeep :preds? t)
            (("3" (expand "iRToAR_env" 1)
              (("3" (lift-if 1)
                (("3" (split 1)
                  (("1" (flatten)
                    (("1" (rewrite "size_cons_def")
                      (("1" (assert) nil nil)) nil))
                    nil)
                   ("2" (flatten)
                    (("2" (expand "get_renv")
                      (("2" (rewrite "get_last_added")
                        (("2" (expand "cons_renv")
                          (("2" (rewrite "size_cons_def")
                            (("2" (rewrite "shrink_for_last_added")
                              (("2"
                                (rewrite "size_cons_def")
                                (("1" (assert) nil nil)
                                 ("2"
                                  (expand "bounded_by?")
                                  (("2"
                                    (skeep :preds? t)
                                    (("2"
                                      (replace -4 :hide? t :dir rl)
                                      (("2"
                                        (expand "rVarIndex")
                                        (("2"
                                          (use
                                           "iRToAR_rexpr_var_existence")
                                          (("2"
                                            (skeep -1)
                                            (("2"
                                              (inst -4 "v1")
                                              (("2" (assert) nil nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   nil shostak)
  (iRToAR_renv_size-1 nil 3757441682
   (""
    (lemma "u_local_environment
       [RAExpr
            [(operatorUnderAnalysis?), RealNumber, FloatingPointNumber,
             FtoR],
        RVariable?, rVarIndex, 
        <<].lenv_induction")
    (("" (inst? -1 :where 1)
      (("" (split -1)
        (("1" (propax) nil nil)
         ("2" (hide 2) (("2" (grind) nil nil)) nil)
         ("3" (hide 2)
          (("3" (skeep :preds? t)
            (("3" (expand "iRToAR_env" 1)
              (("3" (lift-if 1)
                (("3" (split 1)
                  (("1" (flatten)
                    (("1" (rewrite "size_cons_def")
                      (("1" (assert) nil nil)
                       ("2" (hide 2) (("2" (postpone) nil nil)) nil))
                      nil))
                    nil)
                   ("2" (flatten)
                    (("2" (rewrite "get_last_added")
                      (("1" (expand "cons_renv")
                        (("1" (rewrite "size_cons_def")
                          (("1" (rewrite "size_cons_def")
                            (("1" (assert)
                              (("1"
                                (replace -1 :hide? t)
                                (("1"
                                  (rewrite "shrink_for_last_added")
                                  (("1" (postpone) nil nil))
                                  nil))
                                nil))
                              nil)
                             ("2" (postpone) nil nil))
                            nil)
                           ("2" (postpone) nil nil))
                          nil))
                        nil)
                       ("2" (postpone) nil nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   nil shostak))
 (iFToAF_env_size 0
  (iFToAF_env_size-2 "" 3757694744 ("" (grind) nil nil) nil shostak)
  (iFToAF_env_size-1 nil 3757502557
   (""
    (lemma "u_local_environment
               [FPAExpr
                    [(operatorUnderAnalysis?), RealNumber, FloatingPointNumber,
                     FtoR],
                FPVariable?, fpVarIndex, 
                <<].lenv_induction")
    (("" (inst? -1 :where 1)
      (("" (split -1)
        (("1" (propax) nil nil)
         ("2" (hide 2) (("2" (grind) nil nil)) nil)
         ("3" (hide 2)
          (("3" (skeep :preds? t)
            (("3" (expand "iFToAF_env" 1)
              (("3" (lift-if 1)
                (("3" (split 1)
                  (("1" (flatten)
                    (("1" (rewrite "size_cons_def")
                      (("1" (assert) nil nil)) nil))
                    nil)
                   ("2" (flatten)
                    (("2" (expand "get_fpenv")
                      (("2" (rewrite "get_last_added")
                        (("2" (expand "cons_fpenv")
                          (("2" (rewrite "size_cons_def")
                            (("2" (rewrite "shrink_for_last_added")
                              (("2"
                                (rewrite "size_cons_def")
                                (("1" (assert) nil nil)
                                 ("2"
                                  (expand "bounded_by?")
                                  (("2"
                                    (skeep :preds? t)
                                    (("2"
                                      (replace -4 :hide? t :dir rl)
                                      (("2"
                                        (expand "fpVarIndex")
                                        (("2"
                                          (use
                                           "iFToAF_expr_var_existence")
                                          (("2"
                                            (skeep -1)
                                            (("2"
                                              (inst -4 "v1")
                                              (("2" (assert) nil nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   nil nil))
 (evaluable_rLocalEnv_evaluable_iRToAR_env 0
  (evaluable_rLocalEnv_evaluable_iRToAR_env-1 nil 3757437713
   ("" (skeep* :preds? t)
    (("" (expand "bounded_by?")
      (("" (skeep* :preds? t)
        (("" (use "iRToAR_rexpr_var_existence")
          (("" (skeep -1)
            (("" (rewrite "iRToAR_renv_size" :dir rl)
              (("" (inst -4 "v1")
                (("" (assert)
                  (("" (expand "rVarIndex") (("" (assert) nil nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((bounded_by? const-decl "bool" u_local_environment nil)
    (iRToAR_rexpr_var_existence formula-decl nil two_level_expressions
     nil)
    (RAExpr type-decl nil expressions nil)
    (FtoR formal-const-decl "[FloatingPointNumber -> RealNumber]"
     two_level_expressions nil)
    (FloatingPointNumber formal-nonempty-type-decl nil
     two_level_expressions nil)
    (RealNumber formal-nonempty-type-decl nil two_level_expressions
     nil)
    (operatorUnderAnalysis? formal-const-decl
     "{p: PRED[Operator] | EXISTS (op: Operator): p(op)}"
     two_level_expressions nil)
    (PRED type-eq-decl nil defined_types nil)
    (Operator formal-nonempty-type-decl nil two_level_expressions nil)
    (<< adt-def-decl "(strict_well_founded?[RAExpr])" expressions nil)
    (strict_well_founded? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (iRToAR def-decl "analysis_expr_th.RAExpr" two_level_expressions
     nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (RVariable? adt-recognizer-decl "[RAExpr -> boolean]" expressions
     nil)
    (iRToAR_renv_size formula-decl nil two_level_expressions nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (strict_total_order? const-decl "bool" orders nil)
    (lt_r formal-const-decl "(strict_total_order?[RealNumber])"
     two_level_expressions nil)
    (restrict const-decl "R" restrict nil)
    (applyFun_r formal-const-decl
     "[[Operator, RealNumber, RealNumber] -> RealNumber]"
     two_level_expressions nil)
    (lt_fp formal-const-decl
     "(strict_total_order?[FloatingPointNumber])" two_level_expressions
     nil)
    (applyFun_fp formal-const-decl
     "[[Operator, FloatingPointNumber, FloatingPointNumber] ->
   FloatingPointNumber]" two_level_expressions nil)
    (rVarIndex const-decl "nat" expressions_semantics nil)
    (LocalEnvironment nonempty-type-decl nil u_local_environment nil)
    (RLocalEnvironment type-eq-decl nil expressions_semantics nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   shostak))
 (iRToAR_env_preserves_get_TCC1 0
  (iRToAR_env_preserves_get_TCC1-1 nil 3757588595
   ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (Operator formal-nonempty-type-decl nil two_level_expressions nil)
    (PRED type-eq-decl nil defined_types nil)
    (operatorUnderAnalysis? formal-const-decl
     "{p: PRED[Operator] | EXISTS (op: Operator): p(op)}"
     two_level_expressions nil)
    (RealNumber formal-nonempty-type-decl nil two_level_expressions
     nil)
    (FloatingPointNumber formal-nonempty-type-decl nil
     two_level_expressions nil)
    (FtoR formal-const-decl "[FloatingPointNumber -> RealNumber]"
     two_level_expressions nil)
    (RAExpr type-decl nil expressions nil)
    (RVariable? adt-recognizer-decl "[RAExpr -> boolean]" expressions
     nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (pred type-eq-decl nil defined_types nil)
    (strict_total_order? const-decl "bool" orders nil)
    (lt_r formal-const-decl "(strict_total_order?[RealNumber])"
     two_level_expressions nil)
    (restrict const-decl "R" restrict nil)
    (applyFun_r formal-const-decl
     "[[Operator, RealNumber, RealNumber] -> RealNumber]"
     two_level_expressions nil)
    (lt_fp formal-const-decl
     "(strict_total_order?[FloatingPointNumber])" two_level_expressions
     nil)
    (applyFun_fp formal-const-decl
     "[[Operator, FloatingPointNumber, FloatingPointNumber] ->
   FloatingPointNumber]" two_level_expressions nil)
    (rVarIndex const-decl "nat" expressions_semantics nil)
    (strict_well_founded? const-decl "bool" orders nil)
    (<< adt-def-decl "(strict_well_founded?[RAExpr])" expressions nil)
    (LocalEnvironment nonempty-type-decl nil u_local_environment nil)
    (bounded_by? const-decl "bool" u_local_environment nil)
    (RLocalEnvironment type-eq-decl nil expressions_semantics nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil))
   nil))
 (iRToAR_env_preserves_get_TCC2 0
  (iRToAR_env_preserves_get_TCC2-1 nil 3757588595
   ("" (skeep :preds? t)
    (("" (expand "bounded_by?")
      (("" (inst -2 "irlocal")
        (("" (rewrite "iRToAR_renv_size")
          (("" (expand "rVarIndex") (("" (propax) nil nil)) nil)) nil))
        nil))
      nil))
    nil)
   ((bounded_by? const-decl "bool" u_local_environment nil)
    (iRToAR_renv_size formula-decl nil two_level_expressions nil)
    (RLocalEnvironment type-eq-decl nil expressions_semantics nil)
    (LocalEnvironment nonempty-type-decl nil u_local_environment nil)
    (<< adt-def-decl "(strict_well_founded?[RAExpr])" expressions nil)
    (strict_well_founded? const-decl "bool" orders nil)
    (rVarIndex const-decl "nat" expressions_semantics nil)
    (applyFun_fp formal-const-decl
     "[[Operator, FloatingPointNumber, FloatingPointNumber] ->
   FloatingPointNumber]" two_level_expressions nil)
    (lt_fp formal-const-decl
     "(strict_total_order?[FloatingPointNumber])" two_level_expressions
     nil)
    (applyFun_r formal-const-decl
     "[[Operator, RealNumber, RealNumber] -> RealNumber]"
     two_level_expressions nil)
    (restrict const-decl "R" restrict nil)
    (lt_r formal-const-decl "(strict_total_order?[RealNumber])"
     two_level_expressions nil)
    (strict_total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (RVariable? adt-recognizer-decl "[RAExpr -> boolean]" expressions
     nil)
    (RAExpr type-decl nil expressions nil)
    (FtoR formal-const-decl "[FloatingPointNumber -> RealNumber]"
     two_level_expressions nil)
    (FloatingPointNumber formal-nonempty-type-decl nil
     two_level_expressions nil)
    (RealNumber formal-nonempty-type-decl nil two_level_expressions
     nil)
    (operatorUnderAnalysis? formal-const-decl
     "{p: PRED[Operator] | EXISTS (op: Operator): p(op)}"
     two_level_expressions nil)
    (PRED type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (Operator formal-nonempty-type-decl nil two_level_expressions nil))
   nil))
 (iRToAR_env_preserves_get 0
  (iRToAR_env_preserves_get-1 nil 3757586356
   (""
    (lemma "u_local_environment
                 [RAExpr
                      [(operatorUnderAnalysis?), RealNumber, FloatingPointNumber,
                       FtoR],
                  RVariable?, rVarIndex, 
                  <<].lenv_induction")
    ((""
      (inst -1
       "LAMBDA(irLocalEnv: input_esem_th.RLocalEnvironment): FORALL(index: below(size(irLocalEnv))):
            iRToAR(input_esem_th.get_renv(irLocalEnv)(index)) =
             analysis_esem_th.get_renv(iRToAR_env(irLocalEnv))(index)")
      (("1" (split -1)
        (("1" (skeep 1)
          (("1" (inst -1 "irLocalEnv")
            (("1" (inst -1 "index(irlocal)") nil nil)) nil))
          nil)
         ("2" (hide 2) (("2" (grind) nil nil)) nil)
         ("3" (hide 2)
          (("3" (skolem 1 ("irLocalEnv" "irexpr") :skolem-typepreds? t)
            (("3" (flatten)
              (("3" (skeep :preds? t)
                (("3" (expand "get_renv")
                  (("3" (case "index = 0")
                    (("1" (replace -1 :hide? t)
                      (("1" (rewrite "get_last_added")
                        (("1" (expand "iRToAR_env")
                          (("1" (expand "cons_renv")
                            (("1" (expand "get_renv")
                              (("1"
                                (rewrite "get_last_added")
                                (("1"
                                  (rewrite "get_last_added")
                                  (("1"
                                    (expand "shrink_renv")
                                    (("1"
                                      (use
                                       "evaluable_rLocalEnv_evaluable_iRToAR_env")
                                      (("1"
                                        (assert)
                                        (("1"
                                          (rewrite
                                           "shrink_for_last_added")
                                          nil
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil)
                     ("2" (rewrite "get_env_monotonocity")
                      (("2" (expand "iRToAR_env" 2)
                        (("2" (expand "cons_renv")
                          (("2" (expand "get_renv")
                            (("2" (rewrite "get_last_added")
                              (("2"
                                (expand "shrink_renv")
                                (("2"
                                  (rewrite "shrink_for_last_added")
                                  (("2"
                                    (rewrite "get_env_monotonocity")
                                    (("1"
                                      (inst -3 "index-1")
                                      (("1" (assert) nil nil))
                                      nil)
                                     ("2"
                                      (use
                                       "evaluable_rLocalEnv_evaluable_iRToAR_env")
                                      (("2" (assert) nil nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (hide 2)
        (("2" (skeep :preds? t)
          (("2" (rewrite "iRToAR_renv_size") nil nil)) nil))
        nil))
      nil))
    nil)
   ((iRToAR_env def-decl
     "{arLocalEnv: analysis_esem_th.RLocalEnvironment |
         size(rLocalEnv) = size(arLocalEnv)}" two_level_expressions
     nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (below type-eq-decl nil naturalnumbers nil)
    (size const-decl "nat" u_local_environment nil)
    (< const-decl "bool" reals nil)
    (RLocalEnvironment type-eq-decl nil expressions_semantics nil)
    (LocalEnvironment nonempty-type-decl nil u_local_environment nil)
    (iRToAR def-decl "analysis_expr_th.RAExpr" two_level_expressions
     nil)
    (get_renv const-decl "RAExpr" expressions_semantics nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (<= const-decl "bool" reals nil)
    (get_env_monotonocity formula-decl nil u_local_environment nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (irLocalEnv skolem-const-decl "LocalEnvironment
    [RAExpr
         [(operatorUnderAnalysis?), RealNumber, FloatingPointNumber, FtoR],
     RVariable?, rVarIndex, <<]" two_level_expressions nil)
    (irexpr skolem-const-decl "{expr:
   RAExpr
       [(operatorUnderAnalysis?), RealNumber, FloatingPointNumber, FtoR] |
         bounded_by?(irLocalEnv)(expr)}" two_level_expressions nil)
    (index skolem-const-decl "below(size(cons(irexpr, irLocalEnv)))"
           two_level_expressions nil)
    (shrink_renv const-decl "RLocalEnvironment" expressions_semantics
     nil)
    (size_cons_def formula-decl nil u_local_environment nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (evaluable_rLocalEnv_evaluable_iRToAR_env formula-decl nil
     two_level_expressions nil)
    (shrink const-decl "LocalEnvironment" u_local_environment nil)
    (shrink_for_last_added formula-decl nil u_local_environment nil)
    (cons_renv const-decl "RLocalEnvironment" expressions_semantics
     nil)
    (get_last_added formula-decl nil u_local_environment nil)
    (cons const-decl "LocalEnvironment" u_local_environment nil)
    (empty_local_env const-decl "LocalEnvironment" u_local_environment
     nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (REmptyLocalEnv const-decl "RLocalEnvironment"
     expressions_semantics nil)
    (size_empty formula-decl nil u_local_environment nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (RParameter? adt-recognizer-decl "[RAExpr -> boolean]" expressions
     nil)
    (DeBruijnIndex nonempty-type-eq-decl nil expressions nil)
    (index shared-adt-accessor-decl
           "[{x: RAExpr | RVariable?(x) OR RParameter?(x)} -> DeBruijnIndex]"
           expressions nil)
    (bounded_by? const-decl "bool" u_local_environment nil)
    (iRToAR_renv_size formula-decl nil two_level_expressions nil)
    (lenv_induction formula-decl nil u_local_environment nil)
    (Operator formal-nonempty-type-decl nil two_level_expressions nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (PRED type-eq-decl nil defined_types nil)
    (operatorUnderAnalysis? formal-const-decl
     "{p: PRED[Operator] | EXISTS (op: Operator): p(op)}"
     two_level_expressions nil)
    (RealNumber formal-nonempty-type-decl nil two_level_expressions
     nil)
    (FloatingPointNumber formal-nonempty-type-decl nil
     two_level_expressions nil)
    (FtoR formal-const-decl "[FloatingPointNumber -> RealNumber]"
     two_level_expressions nil)
    (RAExpr type-decl nil expressions nil)
    (RVariable? adt-recognizer-decl "[RAExpr -> boolean]" expressions
     nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (pred type-eq-decl nil defined_types nil)
    (strict_total_order? const-decl "bool" orders nil)
    (lt_r formal-const-decl "(strict_total_order?[RealNumber])"
     two_level_expressions nil)
    (restrict const-decl "R" restrict nil)
    (applyFun_r formal-const-decl
     "[[Operator, RealNumber, RealNumber] -> RealNumber]"
     two_level_expressions nil)
    (lt_fp formal-const-decl
     "(strict_total_order?[FloatingPointNumber])" two_level_expressions
     nil)
    (applyFun_fp formal-const-decl
     "[[Operator, FloatingPointNumber, FloatingPointNumber] ->
   FloatingPointNumber]" two_level_expressions nil)
    (rVarIndex const-decl "nat" expressions_semantics nil)
    (strict_well_founded? const-decl "bool" orders nil)
    (<< adt-def-decl "(strict_well_founded?[RAExpr])" expressions nil))
   shostak))
 (iRToAR_env_preserves_shrink 0
  (iRToAR_env_preserves_shrink-1 nil 3757586612
   (""
    (lemma "u_local_environment
                   [RAExpr
                        [(operatorUnderAnalysis?), RealNumber, FloatingPointNumber,
                         FtoR],
                    RVariable?, rVarIndex, 
                    <<].lenv_induction")
    ((""
      (inst -1
       "LAMBDA(irLocalEnv: input_esem_th.RLocalEnvironment): FORALL(index: below(size(irLocalEnv))):
              iRToAR_env(input_esem_th.shrink_renv(irLocalEnv, index)) =
           shrink(iRToAR_env(irLocalEnv), index)")
      (("1" (split -1)
        (("1" (skeep 1)
          (("1" (inst -1 "irLocalEnv")
            (("1" (inst -1 "index(irlocal)") nil nil)) nil))
          nil)
         ("2" (hide 2) (("2" (grind) nil nil)) nil)
         ("3" (hide 2)
          (("3" (skolem 1 ("irLocalEnv" "irexpr") :skolem-typepreds? t)
            (("3" (flatten)
              (("3" (skeep :preds? t)
                (("3" (expand "shrink_renv")
                  (("3" (case "index = 0")
                    (("1" (replace -1 :hide? t)
                      (("1" (rewrite "shrink_for_last_added")
                        (("1" (expand "iRToAR_env" 1 2)
                          (("1" (expand "cons_renv")
                            (("1" (rewrite "shrink_for_last_added")
                              (("1"
                                (expand "shrink_renv")
                                (("1"
                                  (rewrite "shrink_for_last_added")
                                  nil
                                  nil))
                                nil)
                               ("2"
                                (expand "shrink_renv")
                                (("2"
                                  (expand "get_renv")
                                  (("2"
                                    (rewrite "get_last_added")
                                    (("2"
                                      (use
                                       "evaluable_rLocalEnv_evaluable_iRToAR_env")
                                      (("2"
                                        (rewrite
                                         "shrink_for_last_added")
                                        (("2" (assert) nil nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil)
                     ("2" (rewrite "shrink_env_monotonocity")
                      (("2" (expand "iRToAR_env" 2 2)
                        (("2" (expand "cons_renv")
                          (("2" (expand "shrink_renv")
                            (("2" (expand "get_renv")
                              (("2"
                                (rewrite "shrink_for_last_added")
                                (("2"
                                  (rewrite "get_last_added")
                                  (("2"
                                    (inst -3 "index-1")
                                    (("1"
                                      (rewrite
                                       "shrink_env_monotonocity")
                                      (("1"
                                        (use
                                         "evaluable_rLocalEnv_evaluable_iRToAR_env")
                                        (("1" (assert) nil nil))
                                        nil))
                                      nil)
                                     ("2" (assert) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (hide 2)
        (("2" (skeep :preds? t)
          (("2" (rewrite "iRToAR_renv_size") nil nil)) nil))
        nil))
      nil))
    nil)
   ((iRToAR_env def-decl
     "{arLocalEnv: analysis_esem_th.RLocalEnvironment |
         size(rLocalEnv) = size(arLocalEnv)}" two_level_expressions
     nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (below type-eq-decl nil naturalnumbers nil)
    (size const-decl "nat" u_local_environment nil)
    (< const-decl "bool" reals nil)
    (RLocalEnvironment type-eq-decl nil expressions_semantics nil)
    (LocalEnvironment nonempty-type-decl nil u_local_environment nil)
    (shrink_renv const-decl "RLocalEnvironment" expressions_semantics
     nil)
    (shrink const-decl "LocalEnvironment" u_local_environment nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (<= const-decl "bool" reals nil)
    (shrink_env_monotonocity formula-decl nil u_local_environment nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (index skolem-const-decl "below(size(cons(irexpr, irLocalEnv)))"
           two_level_expressions nil)
    (irexpr skolem-const-decl "{expr:
   RAExpr
       [(operatorUnderAnalysis?), RealNumber, FloatingPointNumber, FtoR] |
         bounded_by?(irLocalEnv)(expr)}" two_level_expressions nil)
    (irLocalEnv skolem-const-decl "LocalEnvironment
    [RAExpr
         [(operatorUnderAnalysis?), RealNumber, FloatingPointNumber, FtoR],
     RVariable?, rVarIndex, <<]" two_level_expressions nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (get_renv const-decl "RAExpr" expressions_semantics nil)
    (iRToAR def-decl "analysis_expr_th.RAExpr" two_level_expressions
     nil)
    (size_cons_def formula-decl nil u_local_environment nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (evaluable_rLocalEnv_evaluable_iRToAR_env formula-decl nil
     two_level_expressions nil)
    (get_last_added formula-decl nil u_local_environment nil)
    (cons_renv const-decl "RLocalEnvironment" expressions_semantics
     nil)
    (shrink_for_last_added formula-decl nil u_local_environment nil)
    (cons const-decl "LocalEnvironment" u_local_environment nil)
    (empty_local_env const-decl "LocalEnvironment" u_local_environment
     nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (REmptyLocalEnv const-decl "RLocalEnvironment"
     expressions_semantics nil)
    (size_empty formula-decl nil u_local_environment nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (RParameter? adt-recognizer-decl "[RAExpr -> boolean]" expressions
     nil)
    (DeBruijnIndex nonempty-type-eq-decl nil expressions nil)
    (index shared-adt-accessor-decl
           "[{x: RAExpr | RVariable?(x) OR RParameter?(x)} -> DeBruijnIndex]"
           expressions nil)
    (bounded_by? const-decl "bool" u_local_environment nil)
    (iRToAR_renv_size formula-decl nil two_level_expressions nil)
    (lenv_induction formula-decl nil u_local_environment nil)
    (Operator formal-nonempty-type-decl nil two_level_expressions nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (PRED type-eq-decl nil defined_types nil)
    (operatorUnderAnalysis? formal-const-decl
     "{p: PRED[Operator] | EXISTS (op: Operator): p(op)}"
     two_level_expressions nil)
    (RealNumber formal-nonempty-type-decl nil two_level_expressions
     nil)
    (FloatingPointNumber formal-nonempty-type-decl nil
     two_level_expressions nil)
    (FtoR formal-const-decl "[FloatingPointNumber -> RealNumber]"
     two_level_expressions nil)
    (RAExpr type-decl nil expressions nil)
    (RVariable? adt-recognizer-decl "[RAExpr -> boolean]" expressions
     nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (pred type-eq-decl nil defined_types nil)
    (strict_total_order? const-decl "bool" orders nil)
    (lt_r formal-const-decl "(strict_total_order?[RealNumber])"
     two_level_expressions nil)
    (restrict const-decl "R" restrict nil)
    (applyFun_r formal-const-decl
     "[[Operator, RealNumber, RealNumber] -> RealNumber]"
     two_level_expressions nil)
    (lt_fp formal-const-decl
     "(strict_total_order?[FloatingPointNumber])" two_level_expressions
     nil)
    (applyFun_fp formal-const-decl
     "[[Operator, FloatingPointNumber, FloatingPointNumber] ->
   FloatingPointNumber]" two_level_expressions nil)
    (rVarIndex const-decl "nat" expressions_semantics nil)
    (strict_well_founded? const-decl "bool" orders nil)
    (<< adt-def-decl "(strict_well_founded?[RAExpr])" expressions nil))
   shostak))
 (iRToAR_env_FtoR_fpLocalEnv_evaluable 0
  (iRToAR_env_FtoR_fpLocalEnv_evaluable-1 nil 3757501505
   ("" (skeep* :preds? t)
    (("" (assert)
      (("" (expand "bounded_by?")
        (("" (expand "bounded_by?_raexpr")
          (("" (expand "bounded_by?") (("" (propax) nil nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((bounded_by?_raexpr const-decl "bool" expressions_semantics nil)
    (bounded_by? const-decl "bool" u_local_environment nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   shostak))
 (evaluable_fpLocalEnv_evaluable_iFToAF_env 0
  (evaluable_fpLocalEnv_evaluable_iFToAF_env-1 nil 3757501897
   ("" (skeep* :preds? t)
    (("" (expand "bounded_by?")
      (("" (skeep* :preds? t)
        (("" (use "iFToAF_expr_var_existence")
          (("" (skeep -1)
            (("" (rewrite "iFToAF_env_size" :dir rl)
              (("" (inst -4 "v1")
                (("" (assert)
                  (("" (expand "fpVarIndex") (("" (assert) nil nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((bounded_by? const-decl "bool" u_local_environment nil)
    (iFToAF_expr_var_existence formula-decl nil two_level_expressions
     nil)
    (FPAExpr type-decl nil expressions nil)
    (FtoR formal-const-decl "[FloatingPointNumber -> RealNumber]"
     two_level_expressions nil)
    (FloatingPointNumber formal-nonempty-type-decl nil
     two_level_expressions nil)
    (RealNumber formal-nonempty-type-decl nil two_level_expressions
     nil)
    (operatorUnderAnalysis? formal-const-decl
     "{p: PRED[Operator] | EXISTS (op: Operator): p(op)}"
     two_level_expressions nil)
    (PRED type-eq-decl nil defined_types nil)
    (Operator formal-nonempty-type-decl nil two_level_expressions nil)
    (<< adt-def-decl "(strict_well_founded?[FPAExpr])" expressions nil)
    (strict_well_founded? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (iFToAF def-decl "analysis_expr_th.FPAExpr" two_level_expressions
     nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (FPVariable? adt-recognizer-decl "[FPAExpr -> boolean]" expressions
     nil)
    (iFToAF_env_size formula-decl nil two_level_expressions nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (strict_total_order? const-decl "bool" orders nil)
    (lt_r formal-const-decl "(strict_total_order?[RealNumber])"
     two_level_expressions nil)
    (restrict const-decl "R" restrict nil)
    (applyFun_r formal-const-decl
     "[[Operator, RealNumber, RealNumber] -> RealNumber]"
     two_level_expressions nil)
    (lt_fp formal-const-decl
     "(strict_total_order?[FloatingPointNumber])" two_level_expressions
     nil)
    (applyFun_fp formal-const-decl
     "[[Operator, FloatingPointNumber, FloatingPointNumber] ->
   FloatingPointNumber]" two_level_expressions nil)
    (fpVarIndex const-decl "nat" expressions_semantics nil)
    (LocalEnvironment nonempty-type-decl nil u_local_environment nil)
    (FPLocalEnvironment type-eq-decl nil expressions_semantics nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil))
 (iRToAR_env_FtoR_fpLocalEnv_iRToAR_FtoR_evaluable 0
  (iRToAR_env_FtoR_fpLocalEnv_iRToAR_FtoR_evaluable-1 nil 3757502696
   ("" (skeep* :preds? t)
    (("" (assert)
      (("" (lemma "input_esem_th.evaluable_in_expr_FtoR")
        (("" (inst? -1 :where -2)
          (("" (inst -1 "input_esem_th.FtoR(fpLocalEnv)")
            (("" (split -1)
              (("1" (use "evaluable_rLocalEnv_evaluable_iRToAR_env")
                (("1" (assert) nil nil)) nil)
               ("2" (assert) nil nil) ("3" (propax) nil nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((FPAExpr type-decl nil expressions nil)
    (FPVariable? adt-recognizer-decl "[FPAExpr -> boolean]" expressions
     nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (fpVarIndex const-decl "nat" expressions_semantics nil)
    (strict_well_founded? const-decl "bool" orders nil)
    (<< adt-def-decl "(strict_well_founded?[FPAExpr])" expressions nil)
    (LocalEnvironment nonempty-type-decl nil u_local_environment nil)
    (FPLocalEnvironment type-eq-decl nil expressions_semantics nil)
    (bounded_by? const-decl "bool" u_local_environment nil)
    (evaluable_rLocalEnv_evaluable_iRToAR_env formula-decl nil
     two_level_expressions nil)
    (FtoR const-decl "{rle: RLocalEnvironment |
         size(fle) = size(rle) AND
          (FORALL (i: below(size(rle))): get(rle)(i) = FtoR(get(fle)(i)))}"
     expressions_semantics nil)
    (FtoR def-decl "RAExpr" expressions nil)
    (get const-decl "T" u_local_environment nil)
    (below type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (size const-decl "nat" u_local_environment nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (RLocalEnvironment type-eq-decl nil expressions_semantics nil)
    (<< adt-def-decl "(strict_well_founded?[RAExpr])" expressions nil)
    (rVarIndex const-decl "nat" expressions_semantics nil)
    (RVariable? adt-recognizer-decl "[RAExpr -> boolean]" expressions
     nil)
    (RAExpr type-decl nil expressions nil)
    (evaluable_in_expr_FtoR formula-decl nil expressions_semantics nil)
    (Operator formal-nonempty-type-decl nil two_level_expressions nil)
    (PRED type-eq-decl nil defined_types nil)
    (operatorUnderAnalysis? formal-const-decl
     "{p: PRED[Operator] | EXISTS (op: Operator): p(op)}"
     two_level_expressions nil)
    (RealNumber formal-nonempty-type-decl nil two_level_expressions
     nil)
    (pred type-eq-decl nil defined_types nil)
    (strict_total_order? const-decl "bool" orders nil)
    (lt_r formal-const-decl "(strict_total_order?[RealNumber])"
     two_level_expressions nil)
    (restrict const-decl "R" restrict nil)
    (applyFun_r formal-const-decl
     "[[Operator, RealNumber, RealNumber] -> RealNumber]"
     two_level_expressions nil)
    (FloatingPointNumber formal-nonempty-type-decl nil
     two_level_expressions nil)
    (lt_fp formal-const-decl
     "(strict_total_order?[FloatingPointNumber])" two_level_expressions
     nil)
    (applyFun_fp formal-const-decl
     "[[Operator, FloatingPointNumber, FloatingPointNumber] ->
   FloatingPointNumber]" two_level_expressions nil)
    (FtoR formal-const-decl "[FloatingPointNumber -> RealNumber]"
     two_level_expressions nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil))
 (iRToAR_par_def 0
  (iRToAR_par_def-1 nil 3757439074 ("" (grind) nil nil)
   ((iRToAR_par const-decl "analysis_esem_th.REnvironment"
     two_level_expressions nil))
   shostak))
 (iRToAR_res_rValidInput 0
  (iRToAR_res_rValidInput-1 nil 3757499652 ("" (grind) nil nil)
   ((FtoR formal-const-decl "[FloatingPointNumber -> RealNumber]"
     two_level_expressions nil)
    (applyFun_fp formal-const-decl
     "[[Operator, FloatingPointNumber, FloatingPointNumber] ->
   FloatingPointNumber]" two_level_expressions nil)
    (lt_fp formal-const-decl
     "(strict_total_order?[FloatingPointNumber])" two_level_expressions
     nil)
    (FloatingPointNumber formal-nonempty-type-decl nil
     two_level_expressions nil)
    (applyFun_r formal-const-decl
     "[[Operator, RealNumber, RealNumber] -> RealNumber]"
     two_level_expressions nil)
    (restrict const-decl "R" restrict nil)
    (lt_r formal-const-decl "(strict_total_order?[RealNumber])"
     two_level_expressions nil)
    (strict_total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (RealNumber formal-nonempty-type-decl nil two_level_expressions
     nil)
    (operatorUnderAnalysis? formal-const-decl
     "{p: PRED[Operator] | EXISTS (op: Operator): p(op)}"
     two_level_expressions nil)
    (PRED type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (Operator formal-nonempty-type-decl nil two_level_expressions nil)
    (FtoR const-decl "RRange" expressions_semantics nil)
    (FtoR const-decl "RInputRestriction" expressions_semantics nil)
    (FtoR const-decl "InducedREnv(fpEnv)" expressions_semantics nil)
    (le const-decl "bool" le "orders/")
    (le_r const-decl "bool" le_r nil)
    (rValidInput? const-decl "bool" expressions_semantics nil)
    (iRToAR_res const-decl "analysis_esem_th.RInputRestriction"
     two_level_expressions nil)
    (iRToAR_par const-decl "analysis_esem_th.REnvironment"
     two_level_expressions nil))
   shostak))
 (IMP_lex2_generic_TCC1 0
  (IMP_lex2_generic_TCC1-1 nil 3757583043
   ("" (use "wf_nat") (("" (grind) nil nil)) nil)
   ((well_founded? const-decl "bool" orders nil)
    (restrict const-decl "R" restrict nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (irreflexive_restrict application-judgement "(irreflexive?[S])"
     restrict_order_props nil)
    (antisymmetric_restrict application-judgement "(antisymmetric?[S])"
     restrict_order_props nil)
    (transitive_restrict application-judgement "(transitive?[S])"
     restrict_order_props nil)
    (strict_order_restrict application-judgement "(strict_order?[S])"
     restrict_order_props nil)
    (trichotomous_restrict application-judgement "(trichotomous?[S])"
     restrict_order_props nil)
    (strict_total_order_restrict application-judgement
     "(strict_total_order?[S])" restrict_order_props nil)
    (wf_nat formula-decl nil naturalnumbers nil))
   nil))
 (eval_input_analysis_eq_TCC1 0
  (eval_input_analysis_eq_TCC1-1 nil 3757437702
   ("" (skeep* :preds? t)
    (("" (use "evaluable_rLocalEnv_evaluable_iRToAR_env")
      (("" (assert) nil nil)) nil))
    nil)
   ((evaluable_rLocalEnv_evaluable_iRToAR_env formula-decl nil
     two_level_expressions nil)
    (bounded_by? const-decl "bool" u_local_environment nil)
    (RLocalEnvironment type-eq-decl nil expressions_semantics nil)
    (LocalEnvironment nonempty-type-decl nil u_local_environment nil)
    (<< adt-def-decl "(strict_well_founded?[RAExpr])" expressions nil)
    (strict_well_founded? const-decl "bool" orders nil)
    (rVarIndex const-decl "nat" expressions_semantics nil)
    (applyFun_fp formal-const-decl
     "[[Operator, FloatingPointNumber, FloatingPointNumber] ->
   FloatingPointNumber]" two_level_expressions nil)
    (lt_fp formal-const-decl
     "(strict_total_order?[FloatingPointNumber])" two_level_expressions
     nil)
    (applyFun_r formal-const-decl
     "[[Operator, RealNumber, RealNumber] -> RealNumber]"
     two_level_expressions nil)
    (restrict const-decl "R" restrict nil)
    (lt_r formal-const-decl "(strict_total_order?[RealNumber])"
     two_level_expressions nil)
    (strict_total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (RVariable? adt-recognizer-decl "[RAExpr -> boolean]" expressions
     nil)
    (RAExpr type-decl nil expressions nil)
    (FtoR formal-const-decl "[FloatingPointNumber -> RealNumber]"
     two_level_expressions nil)
    (FloatingPointNumber formal-nonempty-type-decl nil
     two_level_expressions nil)
    (RealNumber formal-nonempty-type-decl nil two_level_expressions
     nil)
    (operatorUnderAnalysis? formal-const-decl
     "{p: PRED[Operator] | EXISTS (op: Operator): p(op)}"
     two_level_expressions nil)
    (PRED type-eq-decl nil defined_types nil)
    (Operator formal-nonempty-type-decl nil two_level_expressions nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil))
 (eval_input_analysis_eq 0
  (eval_input_analysis_eq-1 nil 3757503837
   ("" (use "wf_nat")
    ((""
      (measure-induct "(size(irLocalEnv),complexity(irexpr))"
       ("irLocalEnv" "irexpr") :order "lt_lex2")
      (("1" (skolem 1 ("irLocalEnv" "irexpr"))
        (("1" (flatten)
          (("1" (skeep 1)
            (("1" (use "input_expr_th.RAExpr_inclusive")
              (("1" (split -1)
                (("1" (grind) nil nil)
                 ("2" (expand "iRToAR" 1)
                  (("2" (assert)
                    (("2" (expand "eval" 1)
                      (("2"
                        (inst -2
                         "input_esem_th.shrink_renv(irLocalEnv, index(irexpr))"
                         "input_esem_th.get_renv(irLocalEnv)(index(irexpr))")
                        (("1" (split -2)
                          (("1" (inst -1 "irParamEnv")
                            (("1" (expand "shrink_renv")
                              (("1"
                                (expand "get_renv")
                                (("1"
                                  (replace -1 :hide? t)
                                  (("1"
                                    (use "iRToAR_env_preserves_shrink")
                                    (("1"
                                      (expand "shrink_renv")
                                      (("1"
                                        (replace -1 :hide? t)
                                        (("1"
                                          (use
                                           "iRToAR_env_preserves_get")
                                          (("1"
                                            (expand "get_renv")
                                            (("1" (assert) nil nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil)
                           ("2" (hide 2)
                            (("2" (expand "lt_lex2")
                              (("2"
                                (flatten)
                                (("2"
                                  (hide 2)
                                  (("2"
                                    (expand "shrink_renv")
                                    (("2"
                                      (rewrite
                                       "u_local_environment
       [RAExpr
            [(operatorUnderAnalysis?), RealNumber, FloatingPointNumber,
             FtoR],
        RVariable?, rVarIndex,  <<].size_shrink")
                                      (("2" (assert) nil nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil)
                         ("2" (expand "shrink_renv")
                          (("2" (expand "get_renv")
                            (("2" (assert) nil nil)) nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("3" (grind) nil nil)
                 ("4" (expand "eval" 1)
                  (("4" (assert)
                    (("4" (expand "iRToAR" 1)
                      (("4" (inst-cp -2 "irLocalEnv" "arg1(irexpr)")
                        (("4" (inst -2 "irLocalEnv" "arg2(irexpr)")
                          (("4" (split -2)
                            (("1" (split -3)
                              (("1"
                                (insteep)
                                (("1"
                                  (insteep)
                                  (("1" (assert) nil nil))
                                  nil))
                                nil)
                               ("2"
                                (hide 2)
                                (("2"
                                  (expand "lt_lex2")
                                  (("2"
                                    (expand "complexity" 1 2)
                                    (("2"
                                      (expand "reduce_nat")
                                      (("2"
                                        (expand "complexity")
                                        (("2" (assert) nil nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil)
                             ("2" (grind) nil nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (hide 2)
        (("2" (skeep :preds? t)
          (("2" (use "evaluable_rLocalEnv_evaluable_iRToAR_env")
            (("2" (assert) nil nil)) nil))
          nil))
        nil)
       ("3" (hide 2) (("3" (assert) (("3" (grind) nil nil)) nil)) nil)
       ("4" (hide 2)
        (("4" (skeep :preds? t)
          (("4" (use "evaluable_rLocalEnv_evaluable_iRToAR_env")
            (("4" (assert) nil nil)) nil))
          nil))
        nil)
       ("5" (hide 2)
        (("5" (skeep :preds? t)
          (("5" (use "evaluable_rLocalEnv_evaluable_iRToAR_env")
            (("5" (assert) nil nil)) nil))
          nil))
        nil)
       ("6" (hide 2) (("6" (grind) nil nil)) nil)
       ("7" (hide 2)
        (("7" (skeep :preds? t)
          (("7" (use "evaluable_rLocalEnv_evaluable_iRToAR_env")
            (("7" (assert) nil nil)) nil))
          nil))
        nil)
       ("8" (hide 2) (("8" (grind) nil nil)) nil))
      nil))
    nil)
   ((well_founded? const-decl "bool" orders nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (strict_total_order_restrict application-judgement
     "(strict_total_order?[S])" restrict_order_props nil)
    (trichotomous_restrict application-judgement "(trichotomous?[S])"
     restrict_order_props nil)
    (strict_order_restrict application-judgement "(strict_order?[S])"
     restrict_order_props nil)
    (transitive_restrict application-judgement "(transitive?[S])"
     restrict_order_props nil)
    (antisymmetric_restrict application-judgement "(antisymmetric?[S])"
     restrict_order_props nil)
    (irreflexive_restrict application-judgement "(irreflexive?[S])"
     restrict_order_props nil)
    (lt_lex2_wf name-judgement "(well_founded?[[nat, nat]])"
     two_level_expressions nil)
    (measure_induction formula-decl nil measure_induction nil)
    (Operator formal-nonempty-type-decl nil two_level_expressions nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (PRED type-eq-decl nil defined_types nil)
    (operatorUnderAnalysis? formal-const-decl
     "{p: PRED[Operator] | EXISTS (op: Operator): p(op)}"
     two_level_expressions nil)
    (RealNumber formal-nonempty-type-decl nil two_level_expressions
     nil)
    (FloatingPointNumber formal-nonempty-type-decl nil
     two_level_expressions nil)
    (FtoR formal-const-decl "[FloatingPointNumber -> RealNumber]"
     two_level_expressions nil)
    (RAExpr type-decl nil expressions nil)
    (RVariable? adt-recognizer-decl "[RAExpr -> boolean]" expressions
     nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (pred type-eq-decl nil defined_types nil)
    (strict_total_order? const-decl "bool" orders nil)
    (lt_r formal-const-decl "(strict_total_order?[RealNumber])"
     two_level_expressions nil)
    (restrict const-decl "R" restrict nil)
    (applyFun_r formal-const-decl
     "[[Operator, RealNumber, RealNumber] -> RealNumber]"
     two_level_expressions nil)
    (lt_fp formal-const-decl
     "(strict_total_order?[FloatingPointNumber])" two_level_expressions
     nil)
    (applyFun_fp formal-const-decl
     "[[Operator, FloatingPointNumber, FloatingPointNumber] ->
   FloatingPointNumber]" two_level_expressions nil)
    (rVarIndex const-decl "nat" expressions_semantics nil)
    (strict_well_founded? const-decl "bool" orders nil)
    (<< adt-def-decl "(strict_well_founded?[RAExpr])" expressions nil)
    (LocalEnvironment nonempty-type-decl nil u_local_environment nil)
    (RLocalEnvironment type-eq-decl nil expressions_semantics nil)
    (bounded_by? const-decl "bool" u_local_environment nil)
    (size const-decl "nat" u_local_environment nil)
    (complexity const-decl "nat" expressions nil)
    (< const-decl "bool" reals nil)
    (lt_lex2 const-decl "bool" lex2_generic "orders/")
    (= const-decl "[T, T -> boolean]" equalities nil)
    (iRToAR_env def-decl
     "{arLocalEnv: analysis_esem_th.RLocalEnvironment |
         size(rLocalEnv) = size(arLocalEnv)}" two_level_expressions
     nil)
    (iRToAR def-decl "analysis_expr_th.RAExpr" two_level_expressions
     nil)
    (iRToAR_par const-decl "analysis_esem_th.REnvironment"
     two_level_expressions nil)
    (eval def-decl "RNumber" expressions_semantics nil)
    (REnvironment nonempty-type-eq-decl nil expressions_semantics nil)
    (RNumber nonempty-type-eq-decl nil expressions nil)
    (ParameterIndex nonempty-type-eq-decl nil expressions nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (RAExpr_inclusive formula-decl nil expressions nil)
    (arg2 adt-accessor-decl "[(ROperator?) -> RAExpr]" expressions nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (reduce_nat adt-def-decl "[RAExpr -> nat]" expressions nil)
    (ROperator? adt-recognizer-decl "[RAExpr -> boolean]" expressions
     nil)
    (arg1 adt-accessor-decl "[(ROperator?) -> RAExpr]" expressions nil)
    (local_definitions_are_evaluable_in_smaller_env formula-decl nil
     u_local_environment nil)
    (iRToAR_env_preserves_get formula-decl nil two_level_expressions
     nil)
    (iRToAR_env_preserves_shrink formula-decl nil two_level_expressions
     nil)
    (size_shrink formula-decl nil u_local_environment nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (get_renv const-decl "RAExpr" expressions_semantics nil)
    (irexpr skolem-const-decl
     "{irexpr | bounded_by?(irLocalEnv)(irexpr)}" two_level_expressions
     nil)
    (index shared-adt-accessor-decl
           "[{x: RAExpr | RVariable?(x) OR RParameter?(x)} -> DeBruijnIndex]"
           expressions nil)
    (DeBruijnIndex nonempty-type-eq-decl nil expressions nil)
    (RParameter? adt-recognizer-decl "[RAExpr -> boolean]" expressions
     nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (irLocalEnv skolem-const-decl "LocalEnvironment
    [RAExpr
         [(operatorUnderAnalysis?), RealNumber, FloatingPointNumber, FtoR],
     RVariable?, rVarIndex, <<]" two_level_expressions nil)
    (shrink_renv const-decl "RLocalEnvironment" expressions_semantics
     nil)
    (below type-eq-decl nil naturalnumbers nil)
    (evaluable_rLocalEnv_evaluable_iRToAR_env formula-decl nil
     two_level_expressions nil)
    (wf_nat formula-decl nil naturalnumbers nil))
   shostak)))

