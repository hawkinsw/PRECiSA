%
% The goal of this theory is to show the existence of the "error" function
% defined in the linear_ineq_zero_beta theory.
%
accumulated_roundoff_error[

  Operator            : TYPE+,

  operatorUnderAnalysis? : { p: PRED[Operator] | EXISTS(op:Operator): p(op) },

  RealNumber          : TYPE+,
  lt_r                : (strict_total_order?[RealNumber]),
  applyFun_r          : [[Operator,RealNumber,RealNumber]->RealNumber],
  FloatingPointNumber : TYPE+,
  lt_fp               : (strict_total_order?[FloatingPointNumber]),
  applyFun_fp         : [[Operator,FloatingPointNumber,FloatingPointNumber]->FloatingPointNumber],
  FtoR 		      : [FloatingPointNumber -> RealNumber],

   (IMPORTING two_level_expressions[Operator,(operatorUnderAnalysis?),RealNumber,lt_r,applyFun_r,FloatingPointNumber,lt_fp,applyFun_fp,FtoR])

  %
  % The following parameter (aerrByOp) encapsulates a family of functions
  % such that, for each function (f) of the family, given an operator (op),
  % f returns a syntactic expression denoting an upper bound of the roundoff
  % error introduced by the corresponding operation. The arguments of the f
  % functions are expressions denoting the value of the parameters of the
  % argument and expressions denoting the accumulated roundoff error of
  % each such parameter.
  %
  aerrByOp : [(operatorUnderAnalysis?)
  	      ->[ input_expr_th.RAExpr,     % first argument
	      	  analysis_expr_th.RAExpr,  % accumulated error of the first argument
		  input_expr_th.RAExpr,     % second argument
		  analysis_expr_th.RAExpr   % accumulated error of the second argument
		  ->analysis_expr_th.RAExpr]], 

  zero_r   : RealNumber,
  abs      : [RealNumber->RealNumber],
  minus    : [RealNumber,RealNumber->RealNumber], 
  zero_fp  : FloatingPointNumber
  
]: THEORY
BEGIN
  ASSUMING

    fe1,fe2: VAR input_expr_th.FPAExpr
    
    X,Y,Z: VAR FloatingPointNumber
    rX,rY,rZ: VAR RealNumber 

    lt_fp_lt_r          : ASSUMPTION lt_fp(X,Y) = lt_r(FtoR(X),FtoR(Y))

    subtractive_inverse : ASSUMPTION minus(rX,rX) = zero_r

    ftor_zero_fp        : ASSUMPTION FtoR(zero_fp) = zero_r

    abs_zero            : ASSUMPTION abs(zero_r) = zero_r

    nargs             : VAR nat
    expr,fpe1,fe3     : VAR input_expr_th.FPAExpr
    ire,rexpr,re1,re3 : VAR input_expr_th.RAExpr
    re2,re4 	      : VAR analysis_expr_th.RAExpr
    err   	      : VAR RealNumber
    irlocal,rlocal    : VAR (input_expr_th.RVariable?)
    operator 	      : VAR (operatorUnderAnalysis?)
    rParamEnv	      : VAR analysis_esem_th.REnvironment

    %

    ResultAndErrorExprPair: TYPE
    = [# value: input_expr_th.RAExpr, error: analysis_expr_th.RAExpr #]

    makeRE(value: input_expr_th.RAExpr, error: analysis_expr_th.RAExpr): ResultAndErrorExprPair
    = (# value := value, error := error #)

    re: VAR ResultAndErrorExprPair

    aerrByOp_ve (op: (operatorUnderAnalysis?)) (ve1,ve2:ResultAndErrorExprPair)
    : ResultAndErrorExprPair
    = LET arg1 = value(ve1),
      	  err1 = error(ve1),
	  arg2 = value(ve2),
      	  err2 = error(ve2)
      IN makeRE(ROperator(op,arg1,arg2), aerrByOp(op)(arg1,err1,arg2,err2))

    %
    
    fpParamEnv  : VAR analysis_esem_th.FPEnvironment
    fpLocalEnv  : VAR analysis_esem_th.FPLocalEnvironment
    rLocalEnv   : VAR analysis_esem_th.RLocalEnvironment
    arlocal     : VAR (analysis_expr_th.RVariable?)
    irexpr      : VAR input_expr_th.RAExpr
    irParamEnv  : VAR input_esem_th.REnvironment
    irLocalEnv  : VAR input_esem_th.RLocalEnvironment
    ifpParamEnv : VAR input_esem_th.FPEnvironment
    iInputRest  : VAR input_esem_th.InputRestriction

    %
    % Conversions from input to analysis
    %

    aerrByOp_does_not_add_locals
    : ASSUMPTION FORALL(arlocal)
      : appears?(aerrByOp(operator)(re1,re2,re3,re4))(arlocal)
        IMPLIES ( appears?(iRToAR(re1))(arlocal) OR
        	  appears?(re2)(arlocal) OR
        	  appears?(iRToAR(re3))(arlocal) OR
        	  appears?(re4)(arlocal) )

    aerrByOp_evaluable
    : ASSUMPTION FORALL(rLocalEnv: input_esem_th.RLocalEnvironment)
      : bounded_by?(rLocalEnv)(re1) AND
        bounded_by?(iRToAR_env(rLocalEnv))(re2) AND
        bounded_by?(rLocalEnv)(re3) AND
        bounded_by?(iRToAR_env(rLocalEnv))(re4)
        IMPLIES bounded_by?(iRToAR_env(rLocalEnv))(aerrByOp(operator)(re1,re2,re3,re4))

    aerrByOp_functional_on_param_evaluation
    : ASSUMPTION
      FORALL( re5,re7: input_expr_th.RAExpr,
      	      re6,re8: analysis_expr_th.RAExpr,
	      irLocalEnv, irParamEnv )
      :
      LET rLocalEnv = iRToAR_env(irLocalEnv),
      	  rParamEnv = iRToAR_par(irParamEnv) IN
      bounded_by?(irLocalEnv)(re1) AND
      bounded_by?(rLocalEnv)(re2) AND
      bounded_by?(irLocalEnv)(re3) AND
      bounded_by?(rLocalEnv)(re4) AND
      bounded_by?(irLocalEnv)(re5) AND
      bounded_by?(rLocalEnv)(re6) AND
      bounded_by?(irLocalEnv)(re7) AND
      bounded_by?(rLocalEnv)(re8) AND
      eval(irParamEnv,irLocalEnv)(re1) = eval(irParamEnv,irLocalEnv)(re5) AND
      eval(rParamEnv,rLocalEnv)(re2) = eval(rParamEnv,rLocalEnv)(re6) AND
      eval(irParamEnv,irLocalEnv)(re3) = eval(irParamEnv,irLocalEnv)(re7) AND
      eval(rParamEnv,rLocalEnv)(re4) = eval(rParamEnv,rLocalEnv)(re8) 
      IMPLIES eval(rParamEnv,rLocalEnv)(aerrByOp(operator)(re1,re2,re3,re4))
      	      = eval(rParamEnv,rLocalEnv)(aerrByOp(operator)(re5,re6,re7,re8))
   
    symbolicErrorExpression?
    ( fpParamEnv:input_esem_th.FPEnvironment,
      fpLocalEnv:input_esem_th.FPLocalEnvironment )
    ( expr | bounded_by?(fpLocalEnv)(expr) )
    ( errorExpr: analysis_expr_th.RAExpr
      | analysis_esem_th.bounded_by?_raexpr(iRToAR_env(FtoR(fpLocalEnv)))(errorExpr))
    : MACRO bool
    = LET arParamEnv : analysis_esem_th.REnvironment
      	 = iRToAR_par(input_esem_th.FtoR(fpParamEnv)),
          irParamEnv : input_esem_th.REnvironment
      	 = input_esem_th.FtoR(fpParamEnv),
          arLocalEnv : analysis_esem_th.RLocalEnvironment
    	 = iRToAR_env(input_esem_th.FtoR(fpLocalEnv)),
          irLocalEnv : input_esem_th.RLocalEnvironment
    	 = input_esem_th.FtoR(fpLocalEnv),
          errorValue = eval(arParamEnv,arLocalEnv)(errorExpr),
      	 exprRValue = input_esem_th.eval(irParamEnv,irLocalEnv)(FtoR(expr)),
    	 exprFValue = input_esem_th.eval(fpParamEnv,fpLocalEnv)(expr)
      IN le_r(zero_r, errorValue) AND
         le_r(abs(minus(FtoR(exprFValue),exprRValue)),errorValue)
    
    aerrByOp_definition
    : ASSUMPTION
      FORALL( fpParamEnv:input_esem_th.FPEnvironment,
      	     fpLocalEnv:input_esem_th.FPLocalEnvironment )
            ( fe1 | bounded_by?(fpLocalEnv)(fe1),
              fe3 | bounded_by?(fpLocalEnv)(fe3),
    	     re2 | analysis_esem_th.bounded_by?_raexpr(iRToAR_env(FtoR(fpLocalEnv)))(re2),
              re4 | analysis_esem_th.bounded_by?_raexpr(iRToAR_env(FtoR(fpLocalEnv)))(re4) ) :
      symbolicErrorExpression?(fpParamEnv,fpLocalEnv)(fe1)(re2) AND
      symbolicErrorExpression?(fpParamEnv,fpLocalEnv)(fe3)(re4)
      IMPLIES symbolicErrorExpression?(fpParamEnv,fpLocalEnv)
      	      (FPOperator(operator,fe1,fe3))
     	      (aerrByOp(operator)(FtoR(fe1),re2,FtoR(fe3),re4))

  ENDASSUMING

  AUTO_REWRITE+ subtractive_inverse
  AUTO_REWRITE+ ftor_zero_fp
  AUTO_REWRITE+ abs_zero
  
  IMPORTING le_r_fp[RealNumber,lt_r,FloatingPointNumber,lt_fp,FtoR]

  %
  % Symbolic Error Expressions Computation
  %

  symbolicErrorExpression
  : VAR {rexpr: analysis_expr_th.RAExpr | NoLocalVars?(rexpr)}

  symbolic_accumulated_error_bound?
  ( fpLocalEnv : input_esem_th.FPLocalEnvironment,
   (expr | bounded_by?(fpLocalEnv)(expr)) )
  (symbolicErrorExpression)
  : bool
  = LET rLocalEnv : input_esem_th.RLocalEnvironment = input_esem_th.FtoR(fpLocalEnv)
    IN bounded_by?(iRToAR_env(rLocalEnv))(symbolicErrorExpression) AND
    FORALL( fpParamEnv: input_esem_th.FPEnvironment )
    : LET rParamEnv : input_esem_th.REnvironment = input_esem_th.FtoR(fpParamEnv),
      	  err = analysis_esem_th.eval
	      	( iRToAR_par(rParamEnv),iRToAR_env(rLocalEnv) )
		( symbolicErrorExpression )
      IN le_r(zero_r, err) AND
         le_r( abs( minus( FtoR( eval(fpParamEnv,fpLocalEnv)(expr) ),
          	           input_esem_th.eval(rParamEnv,rLocalEnv)(FtoR(expr)) ) ),
               err )

  correctResultAndError?
  ( fpLocalEnv  : input_esem_th.FPLocalEnvironment,
   (expr | bounded_by?(fpLocalEnv)(expr)) )
  (re | NoLocalVars?(error(re)) AND NoLocalVars?(value(re)) ): bool
  = symbolic_accumulated_error_bound?(fpLocalEnv,expr)(error(re)) AND
    LET rLocalEnv : input_esem_th.RLocalEnvironment = input_esem_th.FtoR(fpLocalEnv)
    IN bounded_by?(rLocalEnv)(value(re)) AND
    FORALL(fpParamEnv)
    : LET rParamEnv : input_esem_th.REnvironment = input_esem_th.FtoR(fpParamEnv)
      IN input_esem_th.eval(rParamEnv,rLocalEnv)(FtoR(expr))
         = input_esem_th.eval(rParamEnv,rLocalEnv)(value(re))


  %
  % The first part of the process that PRECiSA performs is
  % to generate a symbolic expression (parametric on the arguments
  % of the input expression) that denotes an upper bound for
  % the roundoff error of the input expression.
  %
  precisa_symbolic_error
  ( fpLocalEnv: input_esem_th.FPLocalEnvironment ,
    (expr | input_esem_th.bounded_by?_fpaexpr(fpLocalEnv)(expr)))
  : RECURSIVE (correctResultAndError?(fpLocalEnv,expr))
  = CASES expr OF
      %
      FPConstant(number)
      : makeRE(RConstant(FtoR(number)),RConstant(zero_r)),
      %
      FPVariable(vidx)
      : LET newEnv = input_esem_th.shrink_fple(fpLocalEnv,vidx),
            newExpr = input_esem_th.get_fple(fpLocalEnv)(vidx)
        IN precisa_symbolic_error( newEnv, newExpr ),
      %
      FPParameter(variable)
      % Here it is assumed that function arguments do not carry roundoff error,
      % i.e., they can be correctly represented. To change it, replace zero_r
      % by ulp(rParamEnv(variable)).
      : makeRE(RParameter(variable),RConstant(zero_r)),
      %
      FPOperator(op,exp1,exp2)
      : LET err1 = precisa_symbolic_error(fpLocalEnv,exp1),
      	    err2 = precisa_symbolic_error(fpLocalEnv,exp2) 
	IN aerrByOp_ve(op)(err1, err2)
      %
    ENDCASES
  MEASURE input_esem_th.make_context_fpaexpr(expr,fpLocalEnv) BY <<

  %
  % Concrete Roundoff Error Bound 
  %

  inputRest  : VAR analysis_esem_th.InputRestriction
  rInputRest  : VAR analysis_esem_th.RInputRestriction

  upperBound?
  ( rLocalEnv: analysis_esem_th.RLocalEnvironment,
   (rexpr: analysis_expr_th.RAExpr | bounded_by?(rLocalEnv)(rexpr)))
  (err)
  : bool
  = FORALL( rInputRest : analysis_esem_th.RInputRestriction,
    	    rParamEnv  : analysis_esem_th.RValidInput(rInputRest) )
    : le_r( eval(rParamEnv,rLocalEnv)(rexpr), err)

  % Such a function exists because the operations are total and their arguments
  % are being bounded by the input restriction (inputRest).
  optimizer_existence
  : AXIOM
    EXISTS(optimizer: [ rLocalEnv : analysis_esem_th.RLocalEnvironment,
    		      	rexpr     : { rexpr: analysis_expr_th.RAExpr
			      	      | bounded_by?(rLocalEnv)(rexpr) }
		        -> (upperBound?(rLocalEnv, rexpr)) ])
    : TRUE

  optimizer
  ( rLocalEnv: analysis_esem_th.RLocalEnvironment,
   (rexpr: analysis_expr_th.RAExpr | analysis_esem_th.bounded_by?_raexpr(rLocalEnv)(rexpr)) )
  : (upperBound?(rLocalEnv, rexpr))

  accumulated_error_bound?
  ( fpLocalEnv : input_esem_th.FPLocalEnvironment,
   (expr | bounded_by?(fpLocalEnv)(expr)) )
  (err)
  : bool
  = le_r(zero_r, err) AND
    FORALL( inputRest : input_esem_th.InputRestriction,
    	    fpParamEnv : input_esem_th.ValidInput(inputRest) ,
            ( rLocalEnv : input_esem_th.RLocalEnvironment |
	        input_esem_th.consistentLocalEnvironments?(fpLocalEnv,rLocalEnv) ) )
    : LET rParamEnv : input_esem_th.REnvironment = input_esem_th.FtoR(fpParamEnv)
      IN le_r( abs( minus( FtoR( eval(fpParamEnv,fpLocalEnv)(expr) ),
          	              eval(rParamEnv,rLocalEnv)(input_expr_th.FtoR(expr)) ) ),
            err )
	    
  %

  accumulated_error
  (fpLocalEnv: input_esem_th.FPLocalEnvironment)
  (expr|bounded_by?(fpLocalEnv)(expr))
  : (accumulated_error_bound?(fpLocalEnv,expr))
  = optimizer( iRToAR_env(input_esem_th.FtoR(fpLocalEnv)),
    	       error(precisa_symbolic_error(fpLocalEnv,expr)) )

  %

  accumulated_error_correct: THEOREM
    FORALL(env: input_esem_th.FPLocalEnvironment, (expr | bounded_by?(env)(expr))): 
    LET err = accumulated_error(env)(expr)
    IN accumulated_error_bound?(env,expr)(err)

END accumulated_roundoff_error
