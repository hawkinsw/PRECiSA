(accumulated_roundoff_error
 (IMP_two_level_expressions_TCC1 0
  (IMP_two_level_expressions_TCC1-1 nil 3757677139
   ("" (use "lt_fp_lt_r") nil nil)
   ((FtoR formal-const-decl "[FloatingPointNumber -> RealNumber]"
     accumulated_roundoff_error nil)
    (lt_fp formal-const-decl
     "(strict_total_order?[FloatingPointNumber])"
     accumulated_roundoff_error nil)
    (FloatingPointNumber formal-nonempty-type-decl nil
     accumulated_roundoff_error nil)
    (lt_r formal-const-decl "(strict_total_order?[RealNumber])"
     accumulated_roundoff_error nil)
    (strict_total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (RealNumber formal-nonempty-type-decl nil
     accumulated_roundoff_error nil)
    (lt_fp_lt_r formula-decl nil le_r_fp nil))
   nil))
 (aerrByOp_functional_on_param_evaluation_TCC1 0
  (aerrByOp_functional_on_param_evaluation_TCC1-1 nil 3757072393
   ("" (skeep* :preds? t)
    (("" (replace -3 :hide? t)
      (("" (replace -15 :hide? t)
        (("" (lemma "aerrByOp_evaluable")
          (("" (inst? -1 :where 1) (("" (assert) nil nil)) nil)) nil))
        nil))
      nil))
    nil)
   ((aerrByOp_evaluable formula-decl nil accumulated_roundoff_error
     nil)
    (RLocalEnvironment type-eq-decl nil expressions_semantics nil)
    (LocalEnvironment nonempty-type-decl nil u_local_environment nil)
    (<< adt-def-decl "(strict_well_founded?[RAExpr])" expressions nil)
    (strict_well_founded? const-decl "bool" orders nil)
    (rVarIndex const-decl "nat" expressions_semantics nil)
    (applyFun_fp formal-const-decl
     "[[Operator, FloatingPointNumber, FloatingPointNumber] ->
   FloatingPointNumber]" accumulated_roundoff_error nil)
    (lt_fp formal-const-decl
     "(strict_total_order?[FloatingPointNumber])"
     accumulated_roundoff_error nil)
    (applyFun_r formal-const-decl
     "[[Operator, RealNumber, RealNumber] -> RealNumber]"
     accumulated_roundoff_error nil)
    (restrict const-decl "R" restrict nil)
    (lt_r formal-const-decl "(strict_total_order?[RealNumber])"
     accumulated_roundoff_error nil)
    (strict_total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (RVariable? adt-recognizer-decl "[RAExpr -> boolean]" expressions
     nil)
    (RAExpr type-decl nil expressions nil)
    (FtoR formal-const-decl "[FloatingPointNumber -> RealNumber]"
     accumulated_roundoff_error nil)
    (FloatingPointNumber formal-nonempty-type-decl nil
     accumulated_roundoff_error nil)
    (RealNumber formal-nonempty-type-decl nil
     accumulated_roundoff_error nil)
    (operatorUnderAnalysis? formal-const-decl
     "{p: PRED[Operator] | EXISTS (op: Operator): p(op)}"
     accumulated_roundoff_error nil)
    (PRED type-eq-decl nil defined_types nil)
    (Operator formal-nonempty-type-decl nil accumulated_roundoff_error
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   shostak))
 (aerrByOp_functional_on_param_evaluation_TCC2 0
  (aerrByOp_functional_on_param_evaluation_TCC2-1 nil 3757072393
   ("" (skeep* :preds? t)
    (("" (replace -3 :hide? t)
      (("" (replace -15 :hide? t)
        (("" (rewrite "aerrByOp_evaluable") nil nil)) nil))
      nil))
    nil)
   ((aerrByOp_evaluable formula-decl nil accumulated_roundoff_error
     nil)
    (Operator formal-nonempty-type-decl nil accumulated_roundoff_error
     nil)
    (PRED type-eq-decl nil defined_types nil)
    (operatorUnderAnalysis? formal-const-decl
     "{p: PRED[Operator] | EXISTS (op: Operator): p(op)}"
     accumulated_roundoff_error nil)
    (RealNumber formal-nonempty-type-decl nil
     accumulated_roundoff_error nil)
    (FloatingPointNumber formal-nonempty-type-decl nil
     accumulated_roundoff_error nil)
    (FtoR formal-const-decl "[FloatingPointNumber -> RealNumber]"
     accumulated_roundoff_error nil)
    (RAExpr type-decl nil expressions nil)
    (RVariable? adt-recognizer-decl "[RAExpr -> boolean]" expressions
     nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (pred type-eq-decl nil defined_types nil)
    (strict_total_order? const-decl "bool" orders nil)
    (lt_r formal-const-decl "(strict_total_order?[RealNumber])"
     accumulated_roundoff_error nil)
    (restrict const-decl "R" restrict nil)
    (applyFun_r formal-const-decl
     "[[Operator, RealNumber, RealNumber] -> RealNumber]"
     accumulated_roundoff_error nil)
    (lt_fp formal-const-decl
     "(strict_total_order?[FloatingPointNumber])"
     accumulated_roundoff_error nil)
    (applyFun_fp formal-const-decl
     "[[Operator, FloatingPointNumber, FloatingPointNumber] ->
   FloatingPointNumber]" accumulated_roundoff_error nil)
    (rVarIndex const-decl "nat" expressions_semantics nil)
    (strict_well_founded? const-decl "bool" orders nil)
    (<< adt-def-decl "(strict_well_founded?[RAExpr])" expressions nil)
    (LocalEnvironment nonempty-type-decl nil u_local_environment nil)
    (RLocalEnvironment type-eq-decl nil expressions_semantics nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   shostak))
 (symbolicErrorExpression?_TCC1 0
  (symbolicErrorExpression?_TCC1-1 nil 3756488254
   ("" (skeep* :preds? t)
    (("" (use "iRToAR_env_FtoR_fpLocalEnv_evaluable")
      (("" (assert) nil nil)) nil))
    nil)
   ((iRToAR_env_FtoR_fpLocalEnv_evaluable formula-decl nil
     two_level_expressions nil)
    (Operator formal-nonempty-type-decl nil accumulated_roundoff_error
     nil)
    (PRED type-eq-decl nil defined_types nil)
    (operatorUnderAnalysis? formal-const-decl
     "{p: PRED[Operator] | EXISTS (op: Operator): p(op)}"
     accumulated_roundoff_error nil)
    (RealNumber formal-nonempty-type-decl nil
     accumulated_roundoff_error nil)
    (pred type-eq-decl nil defined_types nil)
    (strict_total_order? const-decl "bool" orders nil)
    (lt_r formal-const-decl "(strict_total_order?[RealNumber])"
     accumulated_roundoff_error nil)
    (applyFun_r formal-const-decl
     "[[Operator, RealNumber, RealNumber] -> RealNumber]"
     accumulated_roundoff_error nil)
    (FloatingPointNumber formal-nonempty-type-decl nil
     accumulated_roundoff_error nil)
    (lt_fp formal-const-decl
     "(strict_total_order?[FloatingPointNumber])"
     accumulated_roundoff_error nil)
    (applyFun_fp formal-const-decl
     "[[Operator, FloatingPointNumber, FloatingPointNumber] ->
   FloatingPointNumber]" accumulated_roundoff_error nil)
    (FtoR formal-const-decl "[FloatingPointNumber -> RealNumber]"
     accumulated_roundoff_error nil)
    (FPLocalEnvironment type-eq-decl nil expressions_semantics nil)
    (LocalEnvironment nonempty-type-decl nil u_local_environment nil)
    (<< adt-def-decl "(strict_well_founded?[FPAExpr])" expressions nil)
    (strict_well_founded? const-decl "bool" orders nil)
    (fpVarIndex const-decl "nat" expressions_semantics nil)
    (restrict const-decl "R" restrict nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (FPVariable? adt-recognizer-decl "[FPAExpr -> boolean]" expressions
     nil)
    (FPAExpr type-decl nil expressions nil)
    (FtoR const-decl "{rle: RLocalEnvironment |
         size(fle) = size(rle) AND
          (FORALL (i: below(size(rle))): get(rle)(i) = FtoR(get(fle)(i)))}"
     expressions_semantics nil)
    (FtoR def-decl "RAExpr" expressions nil)
    (get const-decl "T" u_local_environment nil)
    (below type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (iRToAR_env def-decl
     "{arLocalEnv: analysis_esem_th.RLocalEnvironment |
         size(rLocalEnv) = size(arLocalEnv)}" two_level_expressions
     nil)
    (size const-decl "nat" u_local_environment nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (bounded_by?_raexpr const-decl "bool" expressions_semantics nil)
    (RLocalEnvironment type-eq-decl nil expressions_semantics nil)
    (<< adt-def-decl "(strict_well_founded?[RAExpr])" expressions nil)
    (rVarIndex const-decl "nat" expressions_semantics nil)
    (RVariable? adt-recognizer-decl "[RAExpr -> boolean]" expressions
     nil)
    (RAExpr type-decl nil expressions nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   shostak))
 (symbolicErrorExpression?_TCC2 0
  (symbolicErrorExpression?_TCC2-1 nil 3757076767
   ("" (skeep* :preds? t)
    (("" (replace -6 :hide? t)
      (("" (use "input_esem_th.evaluable_in_expr_FtoR")
        (("" (assert) nil nil)) nil))
      nil))
    nil)
   ((RAExpr type-decl nil expressions nil)
    (RVariable? adt-recognizer-decl "[RAExpr -> boolean]" expressions
     nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (rVarIndex const-decl "nat" expressions_semantics nil)
    (strict_well_founded? const-decl "bool" orders nil)
    (<< adt-def-decl "(strict_well_founded?[RAExpr])" expressions nil)
    (LocalEnvironment nonempty-type-decl nil u_local_environment nil)
    (RLocalEnvironment type-eq-decl nil expressions_semantics nil)
    (FPAExpr type-decl nil expressions nil)
    (FPVariable? adt-recognizer-decl "[FPAExpr -> boolean]" expressions
     nil)
    (fpVarIndex const-decl "nat" expressions_semantics nil)
    (<< adt-def-decl "(strict_well_founded?[FPAExpr])" expressions nil)
    (FPLocalEnvironment type-eq-decl nil expressions_semantics nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (size const-decl "nat" u_local_environment nil)
    (< const-decl "bool" reals nil)
    (below type-eq-decl nil naturalnumbers nil)
    (get const-decl "T" u_local_environment nil)
    (FtoR def-decl "RAExpr" expressions nil)
    (FtoR const-decl "{rle: RLocalEnvironment |
         size(fle) = size(rle) AND
          (FORALL (i: below(size(rle))): get(rle)(i) = FtoR(get(fle)(i)))}"
     expressions_semantics nil)
    (bounded_by? const-decl "bool" u_local_environment nil)
    (FtoR formal-const-decl "[FloatingPointNumber -> RealNumber]"
     accumulated_roundoff_error nil)
    (applyFun_fp formal-const-decl
     "[[Operator, FloatingPointNumber, FloatingPointNumber] ->
   FloatingPointNumber]" accumulated_roundoff_error nil)
    (lt_fp formal-const-decl
     "(strict_total_order?[FloatingPointNumber])"
     accumulated_roundoff_error nil)
    (FloatingPointNumber formal-nonempty-type-decl nil
     accumulated_roundoff_error nil)
    (applyFun_r formal-const-decl
     "[[Operator, RealNumber, RealNumber] -> RealNumber]"
     accumulated_roundoff_error nil)
    (restrict const-decl "R" restrict nil)
    (lt_r formal-const-decl "(strict_total_order?[RealNumber])"
     accumulated_roundoff_error nil)
    (strict_total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (RealNumber formal-nonempty-type-decl nil
     accumulated_roundoff_error nil)
    (operatorUnderAnalysis? formal-const-decl
     "{p: PRED[Operator] | EXISTS (op: Operator): p(op)}"
     accumulated_roundoff_error nil)
    (PRED type-eq-decl nil defined_types nil)
    (Operator formal-nonempty-type-decl nil accumulated_roundoff_error
     nil)
    (evaluable_in_expr_FtoR formula-decl nil expressions_semantics nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   shostak))
 (aerrByOp_definition_TCC1 0
  (aerrByOp_definition_TCC1-1 nil 3756488254
   ("" (skeep* :preds? t)
    (("" (expand "bounded_by?_raexpr")
      (("" (use "aerrByOp_evaluable")
        (("" (assert)
          (("" (hide 2)
            (("" (split 1)
              (("1" (use "input_esem_th.evaluable_in_expr_FtoR")
                (("1" (assert)
                  (("1"
                    (rewrite
                     "evaluable_rLocalEnv_evaluable_iRToAR_env")
                    nil nil))
                  nil))
                nil)
               ("2" (hide -2)
                (("2" (use "input_esem_th.evaluable_in_expr_FtoR")
                  (("2" (assert)
                    (("2"
                      (rewrite
                       "evaluable_rLocalEnv_evaluable_iRToAR_env")
                      nil nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((bounded_by?_raexpr const-decl "bool" expressions_semantics nil)
    (evaluable_in_expr_FtoR formula-decl nil expressions_semantics nil)
    (Operator formal-nonempty-type-decl nil accumulated_roundoff_error
     nil)
    (PRED type-eq-decl nil defined_types nil)
    (operatorUnderAnalysis? formal-const-decl
     "{p: PRED[Operator] | EXISTS (op: Operator): p(op)}"
     accumulated_roundoff_error nil)
    (RealNumber formal-nonempty-type-decl nil
     accumulated_roundoff_error nil)
    (FloatingPointNumber formal-nonempty-type-decl nil
     accumulated_roundoff_error nil)
    (FtoR formal-const-decl "[FloatingPointNumber -> RealNumber]"
     accumulated_roundoff_error nil)
    (RAExpr type-decl nil expressions nil)
    (FPAExpr type-decl nil expressions nil)
    (FtoR def-decl "RAExpr" expressions nil)
    (FPVariable? adt-recognizer-decl "[FPAExpr -> boolean]" expressions
     nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (pred type-eq-decl nil defined_types nil)
    (strict_total_order? const-decl "bool" orders nil)
    (lt_r formal-const-decl "(strict_total_order?[RealNumber])"
     accumulated_roundoff_error nil)
    (restrict const-decl "R" restrict nil)
    (applyFun_r formal-const-decl
     "[[Operator, RealNumber, RealNumber] -> RealNumber]"
     accumulated_roundoff_error nil)
    (lt_fp formal-const-decl
     "(strict_total_order?[FloatingPointNumber])"
     accumulated_roundoff_error nil)
    (applyFun_fp formal-const-decl
     "[[Operator, FloatingPointNumber, FloatingPointNumber] ->
   FloatingPointNumber]" accumulated_roundoff_error nil)
    (fpVarIndex const-decl "nat" expressions_semantics nil)
    (strict_well_founded? const-decl "bool" orders nil)
    (<< adt-def-decl "(strict_well_founded?[FPAExpr])" expressions nil)
    (LocalEnvironment nonempty-type-decl nil u_local_environment nil)
    (bounded_by? const-decl "bool" u_local_environment nil)
    (FPLocalEnvironment type-eq-decl nil expressions_semantics nil)
    (RVariable? adt-recognizer-decl "[RAExpr -> boolean]" expressions
     nil)
    (rVarIndex const-decl "nat" expressions_semantics nil)
    (<< adt-def-decl "(strict_well_founded?[RAExpr])" expressions nil)
    (RLocalEnvironment type-eq-decl nil expressions_semantics nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (size const-decl "nat" u_local_environment nil)
    (iRToAR_env def-decl
     "{arLocalEnv: analysis_esem_th.RLocalEnvironment |
         size(rLocalEnv) = size(arLocalEnv)}" two_level_expressions
     nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (< const-decl "bool" reals nil)
    (below type-eq-decl nil naturalnumbers nil)
    (get const-decl "T" u_local_environment nil)
    (FtoR const-decl "{rle: RLocalEnvironment |
         size(fle) = size(rle) AND
          (FORALL (i: below(size(rle))): get(rle)(i) = FtoR(get(fle)(i)))}"
     expressions_semantics nil)
    (aerrByOp_evaluable formula-decl nil accumulated_roundoff_error
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   shostak))
 (aerrByOp_definition_TCC2 0
  (aerrByOp_definition_TCC2-1 nil 3756488254
   ("" (skeep* :preds? t)
    (("" (rewrite "evaluable_in_fpaexpr_def_op") nil nil)) nil)
   ((evaluable_in_fpaexpr_def_op formula-decl nil expressions_semantics
     nil)
    (FPAExpr type-decl nil expressions nil)
    (FPVariable? adt-recognizer-decl "[FPAExpr -> boolean]" expressions
     nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (fpVarIndex const-decl "nat" expressions_semantics nil)
    (strict_well_founded? const-decl "bool" orders nil)
    (<< adt-def-decl "(strict_well_founded?[FPAExpr])" expressions nil)
    (LocalEnvironment nonempty-type-decl nil u_local_environment nil)
    (FPLocalEnvironment type-eq-decl nil expressions_semantics nil)
    (bounded_by? const-decl "bool" u_local_environment nil)
    (Operator formal-nonempty-type-decl nil accumulated_roundoff_error
     nil)
    (PRED type-eq-decl nil defined_types nil)
    (operatorUnderAnalysis? formal-const-decl
     "{p: PRED[Operator] | EXISTS (op: Operator): p(op)}"
     accumulated_roundoff_error nil)
    (RealNumber formal-nonempty-type-decl nil
     accumulated_roundoff_error nil)
    (pred type-eq-decl nil defined_types nil)
    (strict_total_order? const-decl "bool" orders nil)
    (lt_r formal-const-decl "(strict_total_order?[RealNumber])"
     accumulated_roundoff_error nil)
    (restrict const-decl "R" restrict nil)
    (applyFun_r formal-const-decl
     "[[Operator, RealNumber, RealNumber] -> RealNumber]"
     accumulated_roundoff_error nil)
    (FloatingPointNumber formal-nonempty-type-decl nil
     accumulated_roundoff_error nil)
    (lt_fp formal-const-decl
     "(strict_total_order?[FloatingPointNumber])"
     accumulated_roundoff_error nil)
    (applyFun_fp formal-const-decl
     "[[Operator, FloatingPointNumber, FloatingPointNumber] ->
   FloatingPointNumber]" accumulated_roundoff_error nil)
    (FtoR formal-const-decl "[FloatingPointNumber -> RealNumber]"
     accumulated_roundoff_error nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   shostak))
 (symbolic_accumulated_error_bound?_TCC1 0
  (symbolic_accumulated_error_bound?_TCC1-1 nil 3756210679
   ("" (skeep* :preds? t)
    (("" (use "input_esem_th.evaluable_in_expr_FtoR")
      (("" (assert) nil nil)) nil))
    nil)
   ((evaluable_in_expr_FtoR formula-decl nil expressions_semantics nil)
    (Operator formal-nonempty-type-decl nil accumulated_roundoff_error
     nil)
    (PRED type-eq-decl nil defined_types nil)
    (operatorUnderAnalysis? formal-const-decl
     "{p: PRED[Operator] | EXISTS (op: Operator): p(op)}"
     accumulated_roundoff_error nil)
    (RealNumber formal-nonempty-type-decl nil
     accumulated_roundoff_error nil)
    (pred type-eq-decl nil defined_types nil)
    (strict_total_order? const-decl "bool" orders nil)
    (lt_r formal-const-decl "(strict_total_order?[RealNumber])"
     accumulated_roundoff_error nil)
    (restrict const-decl "R" restrict nil)
    (applyFun_r formal-const-decl
     "[[Operator, RealNumber, RealNumber] -> RealNumber]"
     accumulated_roundoff_error nil)
    (FloatingPointNumber formal-nonempty-type-decl nil
     accumulated_roundoff_error nil)
    (lt_fp formal-const-decl
     "(strict_total_order?[FloatingPointNumber])"
     accumulated_roundoff_error nil)
    (applyFun_fp formal-const-decl
     "[[Operator, FloatingPointNumber, FloatingPointNumber] ->
   FloatingPointNumber]" accumulated_roundoff_error nil)
    (FtoR formal-const-decl "[FloatingPointNumber -> RealNumber]"
     accumulated_roundoff_error nil)
    (FPLocalEnvironment type-eq-decl nil expressions_semantics nil)
    (bounded_by? const-decl "bool" u_local_environment nil)
    (<< adt-def-decl "(strict_well_founded?[FPAExpr])" expressions nil)
    (fpVarIndex const-decl "nat" expressions_semantics nil)
    (FPVariable? adt-recognizer-decl "[FPAExpr -> boolean]" expressions
     nil)
    (FPAExpr type-decl nil expressions nil)
    (RLocalEnvironment type-eq-decl nil expressions_semantics nil)
    (LocalEnvironment nonempty-type-decl nil u_local_environment nil)
    (<< adt-def-decl "(strict_well_founded?[RAExpr])" expressions nil)
    (strict_well_founded? const-decl "bool" orders nil)
    (rVarIndex const-decl "nat" expressions_semantics nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (RVariable? adt-recognizer-decl "[RAExpr -> boolean]" expressions
     nil)
    (RAExpr type-decl nil expressions nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   shostak))
 (correctResultAndError?_TCC1 0
  (correctResultAndError?_TCC1-1 nil 3756986659
   (""
    (then (skeep* :preds? t)
     (use "evaluable_fpLocalEnv_evaluable_iFToAF_env") (assert)))
   nil nil))
 (correctResultAndError?_TCC2 0
  (correctResultAndError?_TCC2-1 nil 3756986659
   ("" (skeep* :preds? t)
    (("" (use "input_esem_th.evaluable_in_expr_FtoR")
      (("" (assert) nil nil)) nil))
    nil)
   ((evaluable_in_expr_FtoR formula-decl nil expressions_semantics nil)
    (Operator formal-nonempty-type-decl nil accumulated_roundoff_error
     nil)
    (PRED type-eq-decl nil defined_types nil)
    (operatorUnderAnalysis? formal-const-decl
     "{p: PRED[Operator] | EXISTS (op: Operator): p(op)}"
     accumulated_roundoff_error nil)
    (RealNumber formal-nonempty-type-decl nil
     accumulated_roundoff_error nil)
    (pred type-eq-decl nil defined_types nil)
    (strict_total_order? const-decl "bool" orders nil)
    (lt_r formal-const-decl "(strict_total_order?[RealNumber])"
     accumulated_roundoff_error nil)
    (restrict const-decl "R" restrict nil)
    (applyFun_r formal-const-decl
     "[[Operator, RealNumber, RealNumber] -> RealNumber]"
     accumulated_roundoff_error nil)
    (FloatingPointNumber formal-nonempty-type-decl nil
     accumulated_roundoff_error nil)
    (lt_fp formal-const-decl
     "(strict_total_order?[FloatingPointNumber])"
     accumulated_roundoff_error nil)
    (applyFun_fp formal-const-decl
     "[[Operator, FloatingPointNumber, FloatingPointNumber] ->
   FloatingPointNumber]" accumulated_roundoff_error nil)
    (FtoR formal-const-decl "[FloatingPointNumber -> RealNumber]"
     accumulated_roundoff_error nil)
    (FPLocalEnvironment type-eq-decl nil expressions_semantics nil)
    (bounded_by? const-decl "bool" u_local_environment nil)
    (<< adt-def-decl "(strict_well_founded?[FPAExpr])" expressions nil)
    (fpVarIndex const-decl "nat" expressions_semantics nil)
    (FPVariable? adt-recognizer-decl "[FPAExpr -> boolean]" expressions
     nil)
    (FPAExpr type-decl nil expressions nil)
    (RLocalEnvironment type-eq-decl nil expressions_semantics nil)
    (LocalEnvironment nonempty-type-decl nil u_local_environment nil)
    (<< adt-def-decl "(strict_well_founded?[RAExpr])" expressions nil)
    (strict_well_founded? const-decl "bool" orders nil)
    (rVarIndex const-decl "nat" expressions_semantics nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (RVariable? adt-recognizer-decl "[RAExpr -> boolean]" expressions
     nil)
    (RAExpr type-decl nil expressions nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   shostak))
 (precisa_symbolic_error_TCC1 0
  (precisa_symbolic_error_TCC1-1 nil 3756210679
   ("" (use "input_esem_th.doublelessp_swf_fpaexpr")
    (("" (expand "strict_well_founded?")
      (("" (flatten) (("" (assert) (("" (grind) nil nil)) nil)) nil))
      nil))
    nil)
   ((strict_well_founded? const-decl "bool" orders nil)
    (<< adt-def-decl "(strict_well_founded?[FPAExpr])" expressions nil)
    (fpVarIndex const-decl "nat" expressions_semantics nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (FPVariable? adt-recognizer-decl "[FPAExpr -> boolean]" expressions
     nil)
    (FPAExpr type-decl nil expressions nil)
    (<< const-decl "[EvaluationContext, EvaluationContext -> bool]"
     u_local_environment nil)
    (irreflexive? const-decl "bool" relations nil)
    (transitive? const-decl "bool" relations nil)
    (strict_order? const-decl "bool" orders nil)
    (well_founded? const-decl "bool" orders nil)
    (FtoR formal-const-decl "[FloatingPointNumber -> RealNumber]"
     accumulated_roundoff_error nil)
    (applyFun_fp formal-const-decl
     "[[Operator, FloatingPointNumber, FloatingPointNumber] ->
   FloatingPointNumber]" accumulated_roundoff_error nil)
    (lt_fp formal-const-decl
     "(strict_total_order?[FloatingPointNumber])"
     accumulated_roundoff_error nil)
    (FloatingPointNumber formal-nonempty-type-decl nil
     accumulated_roundoff_error nil)
    (applyFun_r formal-const-decl
     "[[Operator, RealNumber, RealNumber] -> RealNumber]"
     accumulated_roundoff_error nil)
    (restrict const-decl "R" restrict nil)
    (lt_r formal-const-decl "(strict_total_order?[RealNumber])"
     accumulated_roundoff_error nil)
    (strict_total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (RealNumber formal-nonempty-type-decl nil
     accumulated_roundoff_error nil)
    (operatorUnderAnalysis? formal-const-decl
     "{p: PRED[Operator] | EXISTS (op: Operator): p(op)}"
     accumulated_roundoff_error nil)
    (PRED type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (Operator formal-nonempty-type-decl nil accumulated_roundoff_error
     nil)
    (doublelessp_swf_fpaexpr formula-decl nil expressions_semantics
     nil))
   shostak))
 (precisa_symbolic_error_TCC2 0
  (precisa_symbolic_error_TCC2-1 nil 3756216926
   ("" (skeep* :preds? t)
    (("" (expand "correctResultAndError?")
      (("" (expand "symbolic_accumulated_error_bound?")
        (("" (split 1)
          (("1" (grind) nil nil) ("2" (grind) nil nil)
           ("3" (grind) nil nil)
           ("4" (expand "makeRE")
            (("4" (skeep)
              (("4" (split 1)
                (("1" (expand "eval")
                  (("1" (assert)
                    (("1" (case "reflexive?(le_r)")
                      (("1" (expand "reflexive?")
                        (("1" (inst?) nil nil)) nil)
                       ("2" (hide-all-but 1)
                        (("2" (use "le_r_total_order")
                          (("2" (grind) nil nil)) nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (replace -2 :hide? t)
                  (("2" (expand "eval" 1 1)
                    (("2" (expand "FtoR" 1 4)
                      (("2" (expand "eval" 1 1)
                        (("2" (rewrite "subtractive_inverse")
                          (("2" (rewrite "abs_zero")
                            (("2" (expand "eval" 1 1)
                              (("2"
                                (assert)
                                (("2"
                                  (case "reflexive?(le_r)")
                                  (("1"
                                    (expand "reflexive?")
                                    (("1" (inst?) nil nil))
                                    nil)
                                   ("2"
                                    (hide-all-but 1)
                                    (("2"
                                      (use "le_r_total_order")
                                      (("2" (grind) nil nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil)
           ("5" (expand "makeRE") (("5" (grind) nil nil)) nil)
           ("6" (expand "makeRE") (("6" (grind) nil nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((correctResultAndError? const-decl "bool"
     accumulated_roundoff_error nil)
    (makeRE const-decl "ResultAndErrorExprPair"
     accumulated_roundoff_error nil)
    (FtoR formal-const-decl "[FloatingPointNumber -> RealNumber]"
     accumulated_roundoff_error nil)
    (FloatingPointNumber formal-nonempty-type-decl nil
     accumulated_roundoff_error nil)
    (RealNumber formal-nonempty-type-decl nil
     accumulated_roundoff_error nil)
    (Operator formal-nonempty-type-decl nil accumulated_roundoff_error
     nil)
    (appearsFree? def-decl "bool" expressions nil)
    (appears? const-decl "bool" expressions nil)
    (NoLocalVars? const-decl "bool" expressions nil)
    (operatorUnderAnalysis? formal-const-decl
     "{p: PRED[Operator] | EXISTS (op: Operator): p(op)}"
     accumulated_roundoff_error nil)
    (PRED type-eq-decl nil defined_types nil)
    (zero_r formal-const-decl "RealNumber" accumulated_roundoff_error
     nil)
    (RConstant adt-constructor-decl "[RNumber -> (RConstant?)]"
     expressions nil)
    (RConstant? adt-recognizer-decl "[RAExpr -> boolean]" expressions
     nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (applyFun_fp formal-const-decl
     "[[Operator, FloatingPointNumber, FloatingPointNumber] ->
   FloatingPointNumber]" accumulated_roundoff_error nil)
    (lt_fp formal-const-decl
     "(strict_total_order?[FloatingPointNumber])"
     accumulated_roundoff_error nil)
    (applyFun_r formal-const-decl
     "[[Operator, RealNumber, RealNumber] -> RealNumber]"
     accumulated_roundoff_error nil)
    (restrict const-decl "R" restrict nil)
    (lt_r formal-const-decl "(strict_total_order?[RealNumber])"
     accumulated_roundoff_error nil)
    (strict_total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (FtoR const-decl "{rle: RLocalEnvironment |
         size(fle) = size(rle) AND
          (FORALL (i: below(size(rle))): get(rle)(i) = FtoR(get(fle)(i)))}"
     expressions_semantics nil)
    (rVarIndex const-decl "nat" expressions_semantics nil)
    (<< adt-def-decl "(strict_well_founded?[RAExpr])" expressions nil)
    (strict_well_founded? const-decl "bool" orders nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (RVariable? adt-recognizer-decl "[RAExpr -> boolean]" expressions
     nil)
    (RAExpr type-decl nil expressions nil)
    (bounded_by? const-decl "bool" u_local_environment nil)
    (fpVarIndex const-decl "nat" expressions_semantics nil)
    (<< adt-def-decl "(strict_well_founded?[FPAExpr])" expressions nil)
    (FPVariable? adt-recognizer-decl "[FPAExpr -> boolean]" expressions
     nil)
    (FPAExpr type-decl nil expressions nil)
    (bounded_by?_fpaexpr const-decl "bool" expressions_semantics nil)
    (FtoR def-decl "RAExpr" expressions nil)
    (subtractive_inverse formula-decl nil accumulated_roundoff_error
     nil)
    (FPNumber nonempty-type-eq-decl nil expressions nil)
    (abs_zero formula-decl nil accumulated_roundoff_error nil)
    (eval def-decl "FPNumber" expressions_semantics nil)
    (eval def-decl "RNumber" expressions_semantics nil)
    (le_r const-decl "bool" le_r nil)
    (reflexive? const-decl "bool" relations nil)
    (le_r_total_order formula-decl nil le_r nil)
    (le const-decl "bool" le "orders/")
    (transitive? const-decl "bool" relations nil)
    (preorder? const-decl "bool" orders nil)
    (antisymmetric? const-decl "bool" relations nil)
    (partial_order? const-decl "bool" orders nil)
    (dichotomous? const-decl "bool" orders nil)
    (total_order? const-decl "bool" orders nil)
    (symbolic_accumulated_error_bound? const-decl "bool"
     accumulated_roundoff_error nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   shostak))
 (precisa_symbolic_error_TCC3 0
  (precisa_symbolic_error_TCC3-1 nil 3756216926
   ("" (subtype-tcc) nil nil)
   ((NOT const-decl "[bool -> bool]" booleans nil)
    (FPAExpr type-decl nil expressions nil)
    (FPVariable? adt-recognizer-decl "[FPAExpr -> boolean]" expressions
     nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (fpVarIndex const-decl "nat" expressions_semantics nil)
    (strict_well_founded? const-decl "bool" orders nil)
    (<< adt-def-decl "(strict_well_founded?[FPAExpr])" expressions nil)
    (LocalEnvironment nonempty-type-decl nil u_local_environment nil)
    (FPLocalEnvironment type-eq-decl nil expressions_semantics nil)
    (bounded_by?_fpaexpr const-decl "bool" expressions_semantics nil)
    (DeBruijnIndex nonempty-type-eq-decl nil expressions nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (bounded_by? const-decl "bool" u_local_environment nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (FPVariable adt-constructor-decl "[DeBruijnIndex -> (FPVariable?)]"
     expressions nil)
    (FtoR formal-const-decl "[FloatingPointNumber -> RealNumber]"
     accumulated_roundoff_error nil)
    (applyFun_fp formal-const-decl
     "[[Operator, FloatingPointNumber, FloatingPointNumber] ->
   FloatingPointNumber]" accumulated_roundoff_error nil)
    (lt_fp formal-const-decl
     "(strict_total_order?[FloatingPointNumber])"
     accumulated_roundoff_error nil)
    (FloatingPointNumber formal-nonempty-type-decl nil
     accumulated_roundoff_error nil)
    (applyFun_r formal-const-decl
     "[[Operator, RealNumber, RealNumber] -> RealNumber]"
     accumulated_roundoff_error nil)
    (restrict const-decl "R" restrict nil)
    (lt_r formal-const-decl "(strict_total_order?[RealNumber])"
     accumulated_roundoff_error nil)
    (strict_total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (RealNumber formal-nonempty-type-decl nil
     accumulated_roundoff_error nil)
    (operatorUnderAnalysis? formal-const-decl
     "{p: PRED[Operator] | EXISTS (op: Operator): p(op)}"
     accumulated_roundoff_error nil)
    (PRED type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (Operator formal-nonempty-type-decl nil accumulated_roundoff_error
     nil)
    (shrink_fple const-decl "FPLocalEnvironment" expressions_semantics
     nil))
   shostak))
 (precisa_symbolic_error_TCC4 0
  (precisa_symbolic_error_TCC4-1 nil 3756216926
   ("" (skeep* :preds? t)
    (("" (expand "bounded_by?_fpaexpr") (("" (assert) nil nil)) nil))
    nil)
   ((bounded_by?_fpaexpr const-decl "bool" expressions_semantics nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   shostak))
 (precisa_symbolic_error_TCC5 0
  (precisa_symbolic_error_TCC5-1 nil 3756216926
   ("" (skeep* :preds? t)
    (("" (expand "<<")
      (("" (flatten)
        (("" (expand "bounded_by?_fpaexpr")
          (("" (expand "make_context_fpaexpr")
            (("" (expand "shrink_fple")
              (("" (expand "get_fple")
                (("" (expand "bounded_by?")
                  (("" (inst -1 "expr")
                    (("1" (replace -4 :hide? t)
                      (("1" (expand "fpVarIndex")
                        (("1" (replace -4 :hide? t)
                          (("1" (replace -4 :hide? t)
                            (("1" (rewrite "size_shrink")
                              (("1" (grind) nil nil)) nil))
                            nil))
                          nil))
                        nil))
                      nil)
                     ("2" (assert)
                      (("2" (replace -4 :hide? t)
                        (("2" (replace -4 :hide? t)
                          (("2" (rewrite "size_shrink")
                            (("2" (grind) nil nil)) nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((<< const-decl "[EvaluationContext, EvaluationContext -> bool]"
     u_local_environment nil)
    (bounded_by?_fpaexpr const-decl "bool" expressions_semantics nil)
    (shrink_fple const-decl "FPLocalEnvironment" expressions_semantics
     nil)
    (bounded_by? const-decl "bool" u_local_environment nil)
    (size_shrink formula-decl nil u_local_environment nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (Operator formal-nonempty-type-decl nil accumulated_roundoff_error
     nil)
    (PRED type-eq-decl nil defined_types nil)
    (operatorUnderAnalysis? formal-const-decl
     "{p: PRED[Operator] | EXISTS (op: Operator): p(op)}"
     accumulated_roundoff_error nil)
    (RealNumber formal-nonempty-type-decl nil
     accumulated_roundoff_error nil)
    (FloatingPointNumber formal-nonempty-type-decl nil
     accumulated_roundoff_error nil)
    (FtoR formal-const-decl "[FloatingPointNumber -> RealNumber]"
     accumulated_roundoff_error nil)
    (FPAExpr type-decl nil expressions nil)
    (FPVariable? adt-recognizer-decl "[FPAExpr -> boolean]" expressions
     nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (pred type-eq-decl nil defined_types nil)
    (strict_total_order? const-decl "bool" orders nil)
    (lt_r formal-const-decl "(strict_total_order?[RealNumber])"
     accumulated_roundoff_error nil)
    (restrict const-decl "R" restrict nil)
    (applyFun_r formal-const-decl
     "[[Operator, RealNumber, RealNumber] -> RealNumber]"
     accumulated_roundoff_error nil)
    (lt_fp formal-const-decl
     "(strict_total_order?[FloatingPointNumber])"
     accumulated_roundoff_error nil)
    (applyFun_fp formal-const-decl
     "[[Operator, FloatingPointNumber, FloatingPointNumber] ->
   FloatingPointNumber]" accumulated_roundoff_error nil)
    (fpVarIndex const-decl "nat" expressions_semantics nil)
    (strict_well_founded? const-decl "bool" orders nil)
    (<< adt-def-decl "(strict_well_founded?[FPAExpr])" expressions nil)
    (LocalEnvironment nonempty-type-decl nil u_local_environment nil)
    (FPLocalEnvironment type-eq-decl nil expressions_semantics nil)
    (fpLocalEnv skolem-const-decl "input_esem_th
    [(operatorUnderAnalysis?), RealNumber, lt_r,
     restrict
         [[Operator, RealNumber, RealNumber],
          [(operatorUnderAnalysis?), RealNumber, RealNumber], RealNumber]
         (applyFun_r),
     FloatingPointNumber, lt_fp,
     restrict
         [[Operator, FloatingPointNumber, FloatingPointNumber],
          [(operatorUnderAnalysis?), FloatingPointNumber,
           FloatingPointNumber],
          FloatingPointNumber]
         (applyFun_fp),
     FtoR].FPLocalEnvironment" accumulated_roundoff_error nil)
    (expr skolem-const-decl
          "{expr | input_esem_th.bounded_by?_fpaexpr(fpLocalEnv)(expr)}"
          accumulated_roundoff_error nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (< const-decl "bool" reals nil)
    (size const-decl "nat" u_local_environment nil)
    (below type-eq-decl nil naturalnumbers nil)
    (DeBruijnIndex nonempty-type-eq-decl nil expressions nil)
    (vidx skolem-const-decl "DeBruijnIndex
    [(operatorUnderAnalysis?), RealNumber, FloatingPointNumber, FtoR]"
     accumulated_roundoff_error nil)
    (newExpr skolem-const-decl
     "{expr_1 | bounded_by?(shrink_fple(fpLocalEnv, vidx))(expr_1)}"
     accumulated_roundoff_error nil)
    (get_fple const-decl
     "{expr | bounded_by?(shrink_fple(fpLocalEnv, vidx))(expr)}"
     expressions_semantics nil)
    (make_context_fpaexpr const-decl "fp_local_env.EvaluationContext"
     expressions_semantics nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   shostak))
 (precisa_symbolic_error_TCC6 0
  (precisa_symbolic_error_TCC6-1 nil 3756216926
   ("" (skeep* :preds? t)
    (("" (invoke (typepred "%1") (! 1 1))
      (("1" (expand "correctResultAndError?")
        (("1" (flatten)
          (("1" (expand "symbolic_accumulated_error_bound?")
            (("1" (flatten)
              (("1" (split 1)
                (("1"
                  (rewrite
                   "analysis_esem_th.no_local_vars_r_evaluable_in")
                  (("1" (expand "bounded_by?_fpaexpr")
                    (("1" (assert) nil nil)) nil))
                  nil)
                 ("2" (skeep 1)
                  (("2" (insteep -4)
                    (("2" (flatten)
                      (("2"
                        (lemma
                         "analysis_esem_th.no_local_vars_eval_eq")
                        (("2"
                          (inst -1
                           "iRToAR_env(input_esem_th.FtoR(fpLocalEnv))"
                           "iRToAR_env(input_esem_th.FtoR(newEnv))"
                           "iRToAR_par(input_esem_th.FtoR(fpParamEnv))"
                           "error(v(newEnv, newExpr))")
                          (("1" (assert)
                            (("1" (replace -1 :hide? t)
                              (("1"
                                (expand "eval" 1 1)
                                (("1"
                                  (replace -11)
                                  (("1"
                                    (expand "FtoR" 1 4)
                                    (("1"
                                      (expand "eval" 1 2)
                                      (("1"
                                        (use
                                         "input_esem_th.ftor_shrink")
                                        (("1"
                                          (replace -1 :dir rl :hide? t)
                                          (("1"
                                            (use
                                             "input_esem_th.ftor_get")
                                            (("1"
                                              (replace
                                               -1
                                               :dir
                                               rl
                                               :hide?
                                               t)
                                              (("1"
                                                (expand "shrink_fple")
                                                (("1"
                                                  (expand "get_fple")
                                                  (("1"
                                                    (assert)
                                                    nil
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil)
                           ("2" (expand "bounded_by?_fpaexpr")
                            (("2" (assert) nil nil)) nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("3"
                  (rewrite "input_esem_th.no_local_vars_r_evaluable_in"
                   1)
                  (("3" (expand "bounded_by?_fpaexpr")
                    (("3" (assert) nil nil)) nil))
                  nil)
                 ("4" (skeep)
                  (("4" (insteep -6)
                    (("4" (lemma "input_esem_th.no_local_vars_eval_eq")
                      (("4"
                        (inst -1 "input_esem_th.FtoR(fpLocalEnv)"
                         "input_esem_th.FtoR(newEnv)"
                         "input_esem_th.FtoR(fpParamEnv)"
                         "value(v(newEnv, newExpr))")
                        (("1" (assert)
                          (("1" (replace -1 :hide? t)
                            (("1" (replace -10)
                              (("1"
                                (expand "FtoR" 1 3)
                                (("1"
                                  (expand "eval" 1 1)
                                  (("1"
                                    (expand "shrink_fple")
                                    (("1"
                                      (expand "get_fple")
                                      (("1"
                                        (use
                                         "input_esem_th.ftor_shrink")
                                        (("1"
                                          (replace -1 :dir rl :hide? t)
                                          (("1"
                                            (use
                                             "input_esem_th.ftor_get")
                                            (("1"
                                              (replace
                                               -1
                                               :dir
                                               rl
                                               :hide?
                                               t)
                                              (("1"
                                                (replace
                                                 -6
                                                 :hide?
                                                 t
                                                 :dir
                                                 rl)
                                                (("1"
                                                  (assert)
                                                  nil
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil)
                         ("2" (expand "bounded_by?_fpaexpr")
                          (("2" (assert) nil nil)) nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (expand "bounded_by?_fpaexpr") (("2" (assert) nil nil))
        nil))
      nil))
    nil)
   ((NOT const-decl "[bool -> bool]" booleans nil)
    (Operator formal-nonempty-type-decl nil accumulated_roundoff_error
     nil)
    (RealNumber formal-nonempty-type-decl nil
     accumulated_roundoff_error nil)
    (FloatingPointNumber formal-nonempty-type-decl nil
     accumulated_roundoff_error nil)
    (FtoR formal-const-decl "[FloatingPointNumber -> RealNumber]"
     accumulated_roundoff_error nil)
    (RAExpr type-decl nil expressions nil)
    (NoLocalVars? const-decl "bool" expressions nil)
    (PRED type-eq-decl nil defined_types nil)
    (operatorUnderAnalysis? formal-const-decl
     "{p: PRED[Operator] | EXISTS (op: Operator): p(op)}"
     accumulated_roundoff_error nil)
    (pred type-eq-decl nil defined_types nil)
    (strict_total_order? const-decl "bool" orders nil)
    (lt_r formal-const-decl "(strict_total_order?[RealNumber])"
     accumulated_roundoff_error nil)
    (restrict const-decl "R" restrict nil)
    (applyFun_r formal-const-decl
     "[[Operator, RealNumber, RealNumber] -> RealNumber]"
     accumulated_roundoff_error nil)
    (lt_fp formal-const-decl
     "(strict_total_order?[FloatingPointNumber])"
     accumulated_roundoff_error nil)
    (applyFun_fp formal-const-decl
     "[[Operator, FloatingPointNumber, FloatingPointNumber] ->
   FloatingPointNumber]" accumulated_roundoff_error nil)
    (FPLocalEnvironment type-eq-decl nil expressions_semantics nil)
    (FPAExpr type-decl nil expressions nil)
    (FPVariable? adt-recognizer-decl "[FPAExpr -> boolean]" expressions
     nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (fpVarIndex const-decl "nat" expressions_semantics nil)
    (strict_well_founded? const-decl "bool" orders nil)
    (<< adt-def-decl "(strict_well_founded?[FPAExpr])" expressions nil)
    (LocalEnvironment nonempty-type-decl nil u_local_environment nil)
    (bounded_by?_fpaexpr const-decl "bool" expressions_semantics nil)
    (EvaluationContext type-eq-decl nil u_local_environment nil)
    (<< const-decl "[EvaluationContext, EvaluationContext -> bool]"
     u_local_environment nil)
    (make_context_fpaexpr const-decl "fp_local_env.EvaluationContext"
     expressions_semantics nil)
    (ResultAndErrorExprPair type-eq-decl nil accumulated_roundoff_error
     nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (bounded_by? const-decl "bool" u_local_environment nil)
    (correctResultAndError? const-decl "bool"
     accumulated_roundoff_error nil)
    (< const-decl "bool" reals nil)
    (size const-decl "nat" u_local_environment nil)
    (below type-eq-decl nil naturalnumbers nil)
    (shrink_fple const-decl "FPLocalEnvironment" expressions_semantics
     nil)
    (DeBruijnIndex nonempty-type-eq-decl nil expressions nil)
    (newEnv skolem-const-decl "FPLocalEnvironment
    [(operatorUnderAnalysis?), RealNumber, lt_r,
     restrict
         [[Operator, RealNumber, RealNumber],
          [(operatorUnderAnalysis?), RealNumber, RealNumber], RealNumber]
         (applyFun_r),
     FloatingPointNumber, lt_fp,
     restrict
         [[Operator, FloatingPointNumber, FloatingPointNumber],
          [(operatorUnderAnalysis?), FloatingPointNumber,
           FloatingPointNumber],
          FloatingPointNumber]
         (applyFun_fp),
     FtoR]" accumulated_roundoff_error nil)
    (fpLocalEnv skolem-const-decl "input_esem_th
    [(operatorUnderAnalysis?), RealNumber, lt_r,
     restrict
         [[Operator, RealNumber, RealNumber],
          [(operatorUnderAnalysis?), RealNumber, RealNumber], RealNumber]
         (applyFun_r),
     FloatingPointNumber, lt_fp,
     restrict
         [[Operator, FloatingPointNumber, FloatingPointNumber],
          [(operatorUnderAnalysis?), FloatingPointNumber,
           FloatingPointNumber],
          FloatingPointNumber]
         (applyFun_fp),
     FtoR].FPLocalEnvironment" accumulated_roundoff_error nil)
    (vidx skolem-const-decl "DeBruijnIndex
    [(operatorUnderAnalysis?), RealNumber, FloatingPointNumber, FtoR]"
     accumulated_roundoff_error nil)
    (newExpr skolem-const-decl
     "{expr_1 | bounded_by?(shrink_fple(fpLocalEnv, vidx))(expr_1)}"
     accumulated_roundoff_error nil)
    (RNumber nonempty-type-eq-decl nil expressions nil)
    (REnvironment nonempty-type-eq-decl nil expressions_semantics nil)
    (iRToAR_par const-decl "analysis_esem_th.REnvironment"
     two_level_expressions nil)
    (InducedREnv nonempty-type-eq-decl nil expressions_semantics nil)
    (FtoR const-decl "InducedREnv(fpEnv)" expressions_semantics nil)
    (eval def-decl "RNumber" expressions_semantics nil)
    (get_fple const-decl
     "{expr | bounded_by?(shrink_fple(fpLocalEnv, vidx))(expr)}"
     expressions_semantics nil)
    (ftor_get formula-decl nil expressions_semantics nil)
    (ftor_shrink formula-decl nil expressions_semantics nil)
    (eval def-decl "FPNumber" expressions_semantics nil)
    (no_local_vars_eval_eq formula-decl nil expressions_semantics nil)
    (FPEnvironment nonempty-type-eq-decl nil expressions_semantics nil)
    (FPNumber nonempty-type-eq-decl nil expressions nil)
    (ParameterIndex nonempty-type-eq-decl nil expressions nil)
    (no_local_vars_r_evaluable_in formula-decl nil
     expressions_semantics nil)
    (RVariable? adt-recognizer-decl "[RAExpr -> boolean]" expressions
     nil)
    (rVarIndex const-decl "nat" expressions_semantics nil)
    (<< adt-def-decl "(strict_well_founded?[RAExpr])" expressions nil)
    (RLocalEnvironment type-eq-decl nil expressions_semantics nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (iRToAR_env def-decl
     "{arLocalEnv: analysis_esem_th.RLocalEnvironment |
         size(rLocalEnv) = size(arLocalEnv)}" two_level_expressions
     nil)
    (get const-decl "T" u_local_environment nil)
    (FtoR def-decl "RAExpr" expressions nil)
    (FtoR const-decl "{rle: RLocalEnvironment |
         size(fle) = size(rle) AND
          (FORALL (i: below(size(rle))): get(rle)(i) = FtoR(get(fle)(i)))}"
     expressions_semantics nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (symbolic_accumulated_error_bound? const-decl "bool"
     accumulated_roundoff_error nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   shostak))
 (precisa_symbolic_error_TCC7 0
  (precisa_symbolic_error_TCC7-2 nil 3756561128
   ("" (skeep* :preds? t)
    (("" (expand "correctResultAndError?")
      (("" (expand "symbolic_accumulated_error_bound?")
        (("" (split 1)
          (("1" (grind) nil nil) ("2" (grind) nil nil)
           ("3" (expand "makeRE") (("3" (grind) nil nil)) nil)
           ("4" (skeep)
            (("4" (expand "makeRE")
              (("4" (split 1)
                (("1" (expand "eval")
                  (("1" (case "reflexive?(le_r)")
                    (("1" (expand "reflexive?") (("1" (inst?) nil nil))
                      nil)
                     ("2" (hide-all-but 1)
                      (("2" (use "le_r_total_order")
                        (("2" (grind) nil nil)) nil))
                      nil))
                    nil))
                  nil)
                 ("2" (replace -3 :hide? t)
                  (("2" (expand "eval" 1 1)
                    (("2" (expand "FtoR" 1 4)
                      (("2" (expand "eval" 1 1)
                        (("2" (expand "FtoR" 1 2)
                          (("2" (rewrite "subtractive_inverse")
                            (("2" (rewrite "abs_zero")
                              (("2"
                                (expand "eval" 1 1)
                                (("2"
                                  (assert)
                                  (("2"
                                    (case "reflexive?(le_r)")
                                    (("1"
                                      (expand "reflexive?")
                                      (("1" (inst?) nil nil))
                                      nil)
                                     ("2"
                                      (hide-all-but 1)
                                      (("2"
                                        (use "le_r_total_order")
                                        (("2" (grind) nil nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil)
           ("5" (expand "makeRE") (("5" (grind) nil nil)) nil)
           ("6" (expand "makeRE")
            (("6" (skeep) (("6" (grind) nil nil)) nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (bounded_by?_fpaexpr const-decl "bool" expressions_semantics nil)
    (bounded_by? const-decl "bool" u_local_environment nil)
    (FPAExpr type-decl nil expressions nil)
    (FPVariable? adt-recognizer-decl "[FPAExpr -> boolean]" expressions
     nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (strict_well_founded? const-decl "bool" orders nil)
    (<< adt-def-decl "(strict_well_founded?[FPAExpr])" expressions nil)
    (fpVarIndex const-decl "nat" expressions_semantics nil)
    (Operator formal-nonempty-type-decl nil accumulated_roundoff_error
     nil)
    (PRED type-eq-decl nil defined_types nil)
    (operatorUnderAnalysis? formal-const-decl
     "{p: PRED[Operator] | EXISTS (op: Operator): p(op)}"
     accumulated_roundoff_error nil)
    (RealNumber formal-nonempty-type-decl nil
     accumulated_roundoff_error nil)
    (pred type-eq-decl nil defined_types nil)
    (strict_total_order? const-decl "bool" orders nil)
    (lt_r formal-const-decl "(strict_total_order?[RealNumber])"
     accumulated_roundoff_error nil)
    (restrict const-decl "R" restrict nil)
    (applyFun_r formal-const-decl
     "[[Operator, RealNumber, RealNumber] -> RealNumber]"
     accumulated_roundoff_error nil)
    (FloatingPointNumber formal-nonempty-type-decl nil
     accumulated_roundoff_error nil)
    (lt_fp formal-const-decl
     "(strict_total_order?[FloatingPointNumber])"
     accumulated_roundoff_error nil)
    (applyFun_fp formal-const-decl
     "[[Operator, FloatingPointNumber, FloatingPointNumber] ->
   FloatingPointNumber]" accumulated_roundoff_error nil)
    (FtoR formal-const-decl "[FloatingPointNumber -> RealNumber]"
     accumulated_roundoff_error nil)
    (FPLocalEnvironment type-eq-decl nil expressions_semantics nil)
    (LocalEnvironment nonempty-type-decl nil u_local_environment nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   shostak)
  (precisa_symbolic_error_TCC7-1 nil 3756216926
   ("" (use "precisa_symbolic_error_TCC2") (("" (grind) nil nil)) nil)
   ((<< adt-def-decl "(strict_well_founded?[FPAExpr])" expressions nil)
    (le_r const-decl "bool" le_r nil)
    (le const-decl "bool" le "orders/")
    (eval def-decl "RNumber" expressions_semantics nil)
    (bounded_by? const-decl "bool" u_local_environment nil)
    (RAExpr type-decl nil expressions nil)
    (RVariable? adt-recognizer-decl "[RAExpr -> boolean]" expressions
     nil)
    (RParameter? adt-recognizer-decl "[RAExpr -> boolean]" expressions
     nil)
    (DeBruijnIndex nonempty-type-eq-decl nil expressions nil)
    (index shared-adt-accessor-decl
           "[{x: RAExpr | RVariable?(x) OR RParameter?(x)} -> DeBruijnIndex]"
           expressions nil)
    (maxFreeLocalIndex_RAExpr def-decl "{maxInd: upfrom(-1) |
         IF EXISTS (local: (RVariable?)): subterm(local, rexpr)
           THEN (EXISTS (local: (RVariable?) | subterm(local, rexpr)):
                   index(local) = maxInd)
                 AND
                 (FORALL (local: (RVariable?) | subterm(local, rexpr)):
                    index(local) <= maxInd)
         ELSE maxInd = -1
         ENDIF}" expressions nil)
    (<< adt-def-decl "(strict_well_founded?[RAExpr])" expressions nil)
    (rVarIndex const-decl "nat" expressions_semantics nil)
    (FtoR const-decl "{rle: RLocalEnvironment |
         size(fle) = size(rle) AND
          (FORALL (i: below(size(rle))): get(rle)(i) = FtoR(get(fle)(i)))}"
     expressions_semantics nil)
    (eval def-decl "FPNumber" expressions_semantics nil)
    (FtoR def-decl "RAExpr" expressions nil)
    (FtoR const-decl "InducedREnv(fpEnv)" expressions_semantics nil)
    (RConstant adt-constructor-decl "[RNumber -> (RConstant?)]"
     expressions nil)
    (RConstant? adt-recognizer-decl "[RAExpr -> boolean]" expressions
     nil)
    (FPAExpr type-decl nil expressions nil)
    (FPVariable? adt-recognizer-decl "[FPAExpr -> boolean]" expressions
     nil)
    (fpVarIndex const-decl "nat" expressions_semantics nil)
    (FPParameter? adt-recognizer-decl "[FPAExpr -> boolean]"
     expressions nil)
    (index shared-adt-accessor-decl
           "[{x: FPAExpr | FPVariable?(x) OR FPParameter?(x)} -> DeBruijnIndex]"
           expressions nil)
    (maxFreeLocalIndex def-decl "{maxInd: upfrom(-1) |
         IF EXISTS (local: (FPVariable?)): subterm(local, expr)
           THEN (EXISTS (local: (FPVariable?) | subterm(local, expr)):
                   index(local) = maxInd)
                 AND
                 (FORALL (local: (FPVariable?) | subterm(local, expr)):
                    index(local) <= maxInd)
         ELSE maxInd = -1
         ENDIF}" expressions nil)
    (LocalEnvironment nonempty-type-decl nil u_local_environment nil)
    (FPLocalEnvironment type-eq-decl nil expressions_semantics nil)
    (ParameterIndex nonempty-type-eq-decl nil expressions nil))
   nil))
 (precisa_symbolic_error_TCC8 0
  (precisa_symbolic_error_TCC8-1 nil 3756216926
   ("" (skeep* :preds? t)
    (("" (expand "correctResultAndError?")
      (("" (expand "symbolic_accumulated_error_bound?")
        (("" (split 1)
          (("1" (grind) nil nil) ("2" (grind) nil nil)
           ("3" (expand "makeRE") (("3" (grind) nil nil)) nil)
           ("4" (skeep)
            (("4" (expand "makeRE")
              (("4" (split 1)
                (("1" (expand "eval")
                  (("1" (case "reflexive?(le_r)")
                    (("1" (expand "reflexive?") (("1" (inst?) nil nil))
                      nil)
                     ("2" (hide-all-but 1)
                      (("2" (use "le_r_total_order")
                        (("2" (grind) nil nil)) nil))
                      nil))
                    nil))
                  nil)
                 ("2" (replace -3 :hide? t)
                  (("2" (expand "eval" 1 1)
                    (("2" (expand "FtoR" 1 4)
                      (("2" (expand "eval" 1 1)
                        (("2" (expand "FtoR" 1 2)
                          (("2" (rewrite "subtractive_inverse")
                            (("2" (rewrite "abs_zero")
                              (("2"
                                (expand "eval" 1 1)
                                (("2"
                                  (assert)
                                  (("2"
                                    (case "reflexive?(le_r)")
                                    (("1"
                                      (expand "reflexive?")
                                      (("1" (inst?) nil nil))
                                      nil)
                                     ("2"
                                      (hide-all-but 1)
                                      (("2"
                                        (use "le_r_total_order")
                                        (("2" (grind) nil nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil)
           ("5" (expand "makeRE") (("5" (grind) nil nil)) nil)
           ("6" (expand "makeRE")
            (("6" (skeep) (("6" (grind) nil nil)) nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((correctResultAndError? const-decl "bool"
     accumulated_roundoff_error nil)
    (makeRE const-decl "ResultAndErrorExprPair"
     accumulated_roundoff_error nil)
    (FtoR formal-const-decl "[FloatingPointNumber -> RealNumber]"
     accumulated_roundoff_error nil)
    (FloatingPointNumber formal-nonempty-type-decl nil
     accumulated_roundoff_error nil)
    (RealNumber formal-nonempty-type-decl nil
     accumulated_roundoff_error nil)
    (Operator formal-nonempty-type-decl nil accumulated_roundoff_error
     nil)
    (appearsFree? def-decl "bool" expressions nil)
    (appears? const-decl "bool" expressions nil)
    (NoLocalVars? const-decl "bool" expressions nil)
    (operatorUnderAnalysis? formal-const-decl
     "{p: PRED[Operator] | EXISTS (op: Operator): p(op)}"
     accumulated_roundoff_error nil)
    (PRED type-eq-decl nil defined_types nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (bounded_by?_fpaexpr const-decl "bool" expressions_semantics nil)
    (FPAExpr type-decl nil expressions nil)
    (FPVariable? adt-recognizer-decl "[FPAExpr -> boolean]" expressions
     nil)
    (<< adt-def-decl "(strict_well_founded?[FPAExpr])" expressions nil)
    (fpVarIndex const-decl "nat" expressions_semantics nil)
    (bounded_by? const-decl "bool" u_local_environment nil)
    (RAExpr type-decl nil expressions nil)
    (RVariable? adt-recognizer-decl "[RAExpr -> boolean]" expressions
     nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (strict_well_founded? const-decl "bool" orders nil)
    (<< adt-def-decl "(strict_well_founded?[RAExpr])" expressions nil)
    (rVarIndex const-decl "nat" expressions_semantics nil)
    (FtoR const-decl "{rle: RLocalEnvironment |
         size(fle) = size(rle) AND
          (FORALL (i: below(size(rle))): get(rle)(i) = FtoR(get(fle)(i)))}"
     expressions_semantics nil)
    (pred type-eq-decl nil defined_types nil)
    (strict_total_order? const-decl "bool" orders nil)
    (lt_r formal-const-decl "(strict_total_order?[RealNumber])"
     accumulated_roundoff_error nil)
    (restrict const-decl "R" restrict nil)
    (applyFun_r formal-const-decl
     "[[Operator, RealNumber, RealNumber] -> RealNumber]"
     accumulated_roundoff_error nil)
    (lt_fp formal-const-decl
     "(strict_total_order?[FloatingPointNumber])"
     accumulated_roundoff_error nil)
    (applyFun_fp formal-const-decl
     "[[Operator, FloatingPointNumber, FloatingPointNumber] ->
   FloatingPointNumber]" accumulated_roundoff_error nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (RConstant? adt-recognizer-decl "[RAExpr -> boolean]" expressions
     nil)
    (RConstant adt-constructor-decl "[RNumber -> (RConstant?)]"
     expressions nil)
    (zero_r formal-const-decl "RealNumber" accumulated_roundoff_error
     nil)
    (FtoR def-decl "RAExpr" expressions nil)
    (FtoR const-decl "InducedREnv(fpEnv)" expressions_semantics nil)
    (abs_zero formula-decl nil accumulated_roundoff_error nil)
    (FPEnvironment nonempty-type-eq-decl nil expressions_semantics nil)
    (FPNumber nonempty-type-eq-decl nil expressions nil)
    (ParameterIndex nonempty-type-eq-decl nil expressions nil)
    (subtractive_inverse formula-decl nil accumulated_roundoff_error
     nil)
    (eval def-decl "FPNumber" expressions_semantics nil)
    (eval def-decl "RNumber" expressions_semantics nil)
    (total_order? const-decl "bool" orders nil)
    (dichotomous? const-decl "bool" orders nil)
    (partial_order? const-decl "bool" orders nil)
    (antisymmetric? const-decl "bool" relations nil)
    (preorder? const-decl "bool" orders nil)
    (transitive? const-decl "bool" relations nil)
    (le const-decl "bool" le "orders/")
    (le_r_total_order formula-decl nil le_r nil)
    (reflexive? const-decl "bool" relations nil)
    (le_r const-decl "bool" le_r nil)
    (RParameter? adt-recognizer-decl "[RAExpr -> boolean]" expressions
     nil)
    (RParameter adt-constructor-decl
     "[ParameterIndex -> (RParameter?)]" expressions nil)
    (symbolic_accumulated_error_bound? const-decl "bool"
     accumulated_roundoff_error nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   shostak))
 (precisa_symbolic_error_TCC9 0
  (precisa_symbolic_error_TCC9-1 nil 3756216926
   ("" (skeep* :preds? t)
    (("" (expand "bounded_by?_fpaexpr")
      (("" (replace -6 :hide? t)
        (("" (rewrite "input_esem_th.evaluable_in_fpaexpr_def_op")
          (("" (assert) nil nil)) nil))
        nil))
      nil))
    nil)
   ((bounded_by?_fpaexpr const-decl "bool" expressions_semantics nil)
    (evaluable_in_fpaexpr_def_op formula-decl nil expressions_semantics
     nil)
    (FPAExpr type-decl nil expressions nil)
    (FPVariable? adt-recognizer-decl "[FPAExpr -> boolean]" expressions
     nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (fpVarIndex const-decl "nat" expressions_semantics nil)
    (strict_well_founded? const-decl "bool" orders nil)
    (<< adt-def-decl "(strict_well_founded?[FPAExpr])" expressions nil)
    (LocalEnvironment nonempty-type-decl nil u_local_environment nil)
    (FPLocalEnvironment type-eq-decl nil expressions_semantics nil)
    (Operator formal-nonempty-type-decl nil accumulated_roundoff_error
     nil)
    (PRED type-eq-decl nil defined_types nil)
    (operatorUnderAnalysis? formal-const-decl
     "{p: PRED[Operator] | EXISTS (op: Operator): p(op)}"
     accumulated_roundoff_error nil)
    (RealNumber formal-nonempty-type-decl nil
     accumulated_roundoff_error nil)
    (pred type-eq-decl nil defined_types nil)
    (strict_total_order? const-decl "bool" orders nil)
    (lt_r formal-const-decl "(strict_total_order?[RealNumber])"
     accumulated_roundoff_error nil)
    (restrict const-decl "R" restrict nil)
    (applyFun_r formal-const-decl
     "[[Operator, RealNumber, RealNumber] -> RealNumber]"
     accumulated_roundoff_error nil)
    (FloatingPointNumber formal-nonempty-type-decl nil
     accumulated_roundoff_error nil)
    (lt_fp formal-const-decl
     "(strict_total_order?[FloatingPointNumber])"
     accumulated_roundoff_error nil)
    (applyFun_fp formal-const-decl
     "[[Operator, FloatingPointNumber, FloatingPointNumber] ->
   FloatingPointNumber]" accumulated_roundoff_error nil)
    (FtoR formal-const-decl "[FloatingPointNumber -> RealNumber]"
     accumulated_roundoff_error nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   shostak))
 (precisa_symbolic_error_TCC10 1
  (precisa_symbolic_error_TCC10-2 "" 3757072072
   ("" (skeep* :preds? t)
    (("" (expand "correctResultAndError?")
      (("" (split 1)
        (("1" (expand "NoLocalVars?")
          (("1" (expand "aerrByOp_ve")
            (("1" (expand "makeRE")
              (("1" (skeep 1)
                (("1" (use "aerrByOp_does_not_add_locals")
                  (("1" (assert)
                    (("1" (hide -2)
                      (("1" (split -1)
                        (("1" (inst -8 "rlocal") nil nil)
                         ("2" (inst -7 "rlocal") nil nil)
                         ("3" (inst -3 "rlocal") nil nil)
                         ("4" (inst -2 "rlocal") nil nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (expand "aerrByOp_ve")
          (("2" (expand "makeRE")
            (("2" (rewrite "NoLocalVars?_r_op") nil nil)) nil))
          nil)
         ("3" (expand "symbolic_accumulated_error_bound?")
          (("3" (flatten)
            (("3" (split 1)
              (("1" (expand "aerrByOp_ve")
                (("1" (expand "makeRE")
                  (("1" (rewrite "aerrByOp_evaluable") nil nil)) nil))
                nil)
               ("2" (expand "aerrByOp_ve")
                (("2" (expand "makeRE")
                  (("2"
                    (name-replace "error"
                     "aerrByOp(op)(value(err1), error(err1), value(err2),
                           error(err2))")
                    (("2" (skeep)
                      (("2" (replace -14 :hide? t)
                        (("2" (inst -4 "fpParamEnv")
                          (("2" (inst -10 "fpParamEnv")
                            (("2" (flatten)
                              (("2"
                                (expand "error")
                                (("2"
                                  (case
                                   " eval(FtoR(fpParamEnv), FtoR(fpLocalEnv))(aerrByOp(op)
                         (value(err1), error(err1), value(err2),
                          error(err2))) =  eval(FtoR(fpParamEnv), FtoR(fpLocalEnv))(aerrByOp(op)
                         (FtoR(exp1), error(err1), FtoR(exp2),
                          error(err2)))")
                                  (("1"
                                    (replace -1 :hide? t)
                                    (("1"
                                      (use "aerrByOp_definition")
                                      (("1" (assert) nil nil))
                                      nil))
                                    nil)
                                   ("2"
                                    (hide 2)
                                    (("2"
                                      (use
                                       "aerrByOp_functional_on_param_evaluation")
                                      (("2"
                                        (assert)
                                        (("2"
                                          (hide 2)
                                          (("2"
                                            (insteep -)
                                            (("2"
                                              (insteep -)
                                              (("2"
                                                (assert)
                                                (("2"
                                                  (rewrite
                                                   "evaluable_in_fpaexpr_def_op")
                                                  (("2"
                                                    (flatten)
                                                    (("2"
                                                      (split 1)
                                                      (("1"
                                                        (use
                                                         "evaluable_in_expr_FtoR")
                                                        (("1"
                                                          (assert)
                                                          nil
                                                          nil))
                                                        nil)
                                                       ("2"
                                                        (use
                                                         "evaluable_in_expr_FtoR")
                                                        (("2"
                                                          (assert)
                                                          nil
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil)
                                   ("3"
                                    (rewrite "aerrByOp_evaluable")
                                    (("1"
                                      (hide 3)
                                      (("1"
                                        (hide 2)
                                        (("1"
                                          (use
                                           "evaluable_in_expr_FtoR")
                                          (("1"
                                            (assert)
                                            (("1"
                                              (rewrite
                                               "evaluable_in_fpaexpr_def_op")
                                              nil
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil)
                                     ("2"
                                      (hide 2 3)
                                      (("2"
                                        (use "evaluable_in_expr_FtoR")
                                        (("2"
                                          (assert)
                                          (("2"
                                            (rewrite
                                             "evaluable_in_fpaexpr_def_op")
                                            nil
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil)
                                   ("4"
                                    (rewrite "aerrByOp_evaluable")
                                    nil
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("4" (expand "aerrByOp_ve")
          (("4" (expand "makeRE")
            (("4" (rewrite "evaluable_in_raexpr_def_op")
              (("4" (split 1)
                (("1" (rewrite "no_local_vars_r_evaluable_in" 1) nil
                  nil)
                 ("2" (rewrite "no_local_vars_r_evaluable_in" 1) nil
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("5" (expand "aerrByOp_ve")
          (("5" (expand "makeRE")
            (("5" (skeep)
              (("5" (insteep -5)
                (("5" (insteep -10) (("5" (grind) nil nil)) nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((LocalEnvironment nonempty-type-decl nil u_local_environment nil)
    (FPLocalEnvironment type-eq-decl nil expressions_semantics nil)
    (bounded_by?_fpaexpr const-decl "bool" expressions_semantics nil)
    (le_r const-decl "bool" le_r nil)
    (le const-decl "bool" le "orders/")
    (RVariable? adt-recognizer-decl "[RAExpr -> boolean]" expressions
     nil)
    (RParameter? adt-recognizer-decl "[RAExpr -> boolean]" expressions
     nil)
    (index shared-adt-accessor-decl
           "[{x: RAExpr | RVariable?(x) OR RParameter?(x)} -> DeBruijnIndex]"
           expressions nil)
    (maxFreeLocalIndex_RAExpr def-decl "{maxInd: upfrom(-1) |
         IF EXISTS (local: (RVariable?)): subterm(local, rexpr)
           THEN (EXISTS (local: (RVariable?) | subterm(local, rexpr)):
                   index(local) = maxInd)
                 AND
                 (FORALL (local: (RVariable?) | subterm(local, rexpr)):
                    index(local) <= maxInd)
         ELSE maxInd = -1
         ENDIF}" expressions nil)
    (<< adt-def-decl "(strict_well_founded?[RAExpr])" expressions nil)
    (rVarIndex const-decl "nat" expressions_semantics nil)
    (FtoR const-decl "{rle: RLocalEnvironment |
         size(fle) = size(rle) AND
          (FORALL (i: below(size(rle))): get(rle)(i) = FtoR(get(fle)(i)))}"
     expressions_semantics nil)
    (bounded_by? const-decl "bool" u_local_environment nil)
    (RAExpr type-decl nil expressions nil)
    (make_context_fpaexpr const-decl "fp_local_env.EvaluationContext"
     expressions_semantics nil)
    (<< adt-def-decl "(strict_well_founded?[FPAExpr])" expressions nil)
    (maxFreeLocalIndex def-decl "{maxInd: upfrom(-1) |
         IF EXISTS (local: (FPVariable?)): subterm(local, expr)
           THEN (EXISTS (local: (FPVariable?) | subterm(local, expr)):
                   index(local) = maxInd)
                 AND
                 (FORALL (local: (FPVariable?) | subterm(local, expr)):
                    index(local) <= maxInd)
         ELSE maxInd = -1
         ENDIF}" expressions nil)
    (index shared-adt-accessor-decl
           "[{x: FPAExpr | FPVariable?(x) OR FPParameter?(x)} -> DeBruijnIndex]"
           expressions nil)
    (DeBruijnIndex nonempty-type-eq-decl nil expressions nil)
    (FPParameter? adt-recognizer-decl "[FPAExpr -> boolean]"
     expressions nil)
    (fpVarIndex const-decl "nat" expressions_semantics nil)
    (FPVariable? adt-recognizer-decl "[FPAExpr -> boolean]" expressions
     nil)
    (FPAExpr type-decl nil expressions nil)
    (<< const-decl "[EvaluationContext, EvaluationContext -> bool]"
     u_local_environment nil))
   shostak)
  (precisa_symbolic_error_TCC10-1 nil 3756216926
   ("" (termination-tcc) nil nil)
   ((NOT const-decl "[bool -> bool]" booleans nil)
    (LocalEnvironment nonempty-type-decl nil u_local_environment nil)
    (FPLocalEnvironment type-eq-decl nil expressions_semantics nil)
    (bounded_by?_fpaexpr const-decl "bool" expressions_semantics nil)
    (symbolic_accumulated_error_bound? const-decl "bool"
     accumulated_roundoff_error nil)
    (le_r const-decl "bool" le_r nil)
    (le const-decl "bool" le "orders/")
    (RVariable? adt-recognizer-decl "[RAExpr -> boolean]" expressions
     nil)
    (<< adt-def-decl "(strict_well_founded?[RAExpr])" expressions nil)
    (rVarIndex const-decl "nat" expressions_semantics nil)
    (FtoR const-decl "{rle: RLocalEnvironment |
         size(fle) = size(rle) AND
          (FORALL (i: below(size(rle))): get(rle)(i) = FtoR(get(fle)(i)))}"
     expressions_semantics nil)
    (appears? const-decl "bool" expressions nil)
    (correctResultAndError? const-decl "bool"
     accumulated_roundoff_error nil)
    (bounded_by? const-decl "bool" u_local_environment nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (ResultAndErrorExprPair type-eq-decl nil accumulated_roundoff_error
     nil)
    (NoLocalVars? const-decl "bool" expressions nil)
    (RAExpr type-decl nil expressions nil)
    (FtoR formal-const-decl "[FloatingPointNumber -> RealNumber]"
     accumulated_roundoff_error nil)
    (applyFun_fp formal-const-decl
     "[[Operator, FloatingPointNumber, FloatingPointNumber] ->
   FloatingPointNumber]" accumulated_roundoff_error nil)
    (lt_fp formal-const-decl
     "(strict_total_order?[FloatingPointNumber])"
     accumulated_roundoff_error nil)
    (FloatingPointNumber formal-nonempty-type-decl nil
     accumulated_roundoff_error nil)
    (applyFun_r formal-const-decl
     "[[Operator, RealNumber, RealNumber] -> RealNumber]"
     accumulated_roundoff_error nil)
    (restrict const-decl "R" restrict nil)
    (lt_r formal-const-decl "(strict_total_order?[RealNumber])"
     accumulated_roundoff_error nil)
    (strict_total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (RealNumber formal-nonempty-type-decl nil
     accumulated_roundoff_error nil)
    (operatorUnderAnalysis? formal-const-decl
     "{p: PRED[Operator] | EXISTS (op: Operator): p(op)}"
     accumulated_roundoff_error nil)
    (PRED type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (Operator formal-nonempty-type-decl nil accumulated_roundoff_error
     nil)
    (make_context_fpaexpr const-decl "fp_local_env.EvaluationContext"
     expressions_semantics nil)
    (<< adt-def-decl "(strict_well_founded?[FPAExpr])" expressions nil)
    (strict_well_founded? const-decl "bool" orders nil)
    (fpVarIndex const-decl "nat" expressions_semantics nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (FPVariable? adt-recognizer-decl "[FPAExpr -> boolean]" expressions
     nil)
    (FPAExpr type-decl nil expressions nil)
    (<< const-decl "[EvaluationContext, EvaluationContext -> bool]"
     u_local_environment nil))
   nil))
 (precisa_symbolic_error_TCC11 0
  (precisa_symbolic_error_TCC11-3 "" 3757151836
   ("" (skeep* :preds? t)
    (("" (expand "correctResultAndError?")
      (("" (split 1)
        (("1" (expand "NoLocalVars?")
          (("1" (expand "aerrByOp_ve")
            (("1" (expand "makeRE")
              (("1" (skeep 1)
                (("1" (use "appears?_analysis_local_input_locals")
                  (("1" (assert)
                    (("1" (skeep :preds? t)
                      (("1" (use "aerrByOp_does_not_add_locals")
                        (("1" (assert)
                          (("1" (split -1)
                            (("1"
                              (use "appears?_analysis_iRToAR_rexpr")
                              (("1"
                                (assert)
                                (("1" (inst? -13) nil nil))
                                nil))
                              nil)
                             ("2" (inst? -11) nil nil)
                             ("3"
                              (use "appears?_analysis_iRToAR_rexpr")
                              (("3"
                                (assert)
                                (("3" (inst? -8) nil nil))
                                nil))
                              nil)
                             ("4" (inst? -6) nil nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (expand "aerrByOp_ve")
          (("2" (expand "makeRE")
            (("2" (rewrite "NoLocalVars?_r_op") nil nil)) nil))
          nil)
         ("3" (expand "symbolic_accumulated_error_bound?")
          (("3" (flatten)
            (("3" (split 1)
              (("1" (expand "aerrByOp_ve")
                (("1" (expand "makeRE")
                  (("1" (rewrite "aerrByOp_evaluable") nil nil)) nil))
                nil)
               ("2" (expand "aerrByOp_ve")
                (("2" (expand "makeRE")
                  (("2"
                    (name-replace "error"
                     "aerrByOp(op)(value(err1), error(err1), value(err2),
                                       error(err2))")
                    (("2" (skeep)
                      (("2" (replace -15 :hide? t)
                        (("2" (inst -4 "fpParamEnv")
                          (("2" (inst -10 "fpParamEnv")
                            (("2" (flatten)
                              (("2"
                                (expand "error")
                                (("2"
                                  (case
                                   " analysis_esem_th.eval
                           (iRToAR_par(input_esem_th.FtoR(fpParamEnv)),
                            iRToAR_env(input_esem_th.FtoR(fpLocalEnv)))
                           (aerrByOp(op)
                                               (value(err1), error(err1), value(err2),
                                                error(err2))) =  analysis_esem_th.eval
                           (iRToAR_par(input_esem_th.FtoR(fpParamEnv)),
                            iRToAR_env(input_esem_th.FtoR(fpLocalEnv)))
                           (aerrByOp(op)
                                               (FtoR(exp1), error(err1), FtoR(exp2),
                                                error(err2)))")
                                  (("1"
                                    (replace -1 :hide? t)
                                    (("1"
                                      (use "aerrByOp_definition")
                                      (("1" (assert) nil nil)
                                       ("2"
                                        (hide-all-but (-3 1))
                                        (("2"
                                          (expand "bounded_by?_raexpr")
                                          (("2" (propax) nil nil))
                                          nil))
                                        nil)
                                       ("3"
                                        (expand "bounded_by?_raexpr")
                                        (("3" (propax) nil nil))
                                        nil))
                                      nil))
                                    nil)
                                   ("2"
                                    (hide 2)
                                    (("2"
                                      (lemma
                                       "aerrByOp_functional_on_param_evaluation")
                                      (("2"
                                        (inst? -1 :where 1)
                                        (("2"
                                          (inst
                                           -1
                                           "FtoR(exp1)"
                                           "FtoR(exp2)"
                                           "error(err1)"
                                           "error(err2)"
                                           "_"
                                           "_")
                                          (("2"
                                            (inst
                                             -1
                                             "input_esem_th.FtoR(fpLocalEnv)"
                                             "input_esem_th.FtoR(fpParamEnv)")
                                            (("2"
                                              (assert)
                                              (("2"
                                                (split -1)
                                                (("1" (propax) nil nil)
                                                 ("2" (propax) nil nil)
                                                 ("3" (propax) nil nil)
                                                 ("4" (propax) nil nil)
                                                 ("5" (propax) nil nil)
                                                 ("6"
                                                  (hide 2)
                                                  (("6"
                                                    (insteep -)
                                                    (("6"
                                                      (insteep -)
                                                      (("6"
                                                        (assert)
                                                        (("6"
                                                          (expand
                                                           "bounded_by?_fpaexpr")
                                                          (("6"
                                                            (use
                                                             "input_esem_th.evaluable_in_expr_FtoR")
                                                            (("6"
                                                              (assert)
                                                              (("6"
                                                                (rewrite
                                                                 "input_esem_th.evaluable_in_fpaexpr_def_op")
                                                                nil
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil)
                                                 ("7" (propax) nil nil)
                                                 ("8"
                                                  (hide 2)
                                                  (("8"
                                                    (expand
                                                     "bounded_by?_fpaexpr")
                                                    (("8"
                                                      (use
                                                       "input_esem_th.evaluable_in_expr_FtoR")
                                                      (("8"
                                                        (rewrite
                                                         "input_esem_th.evaluable_in_fpaexpr_def_op")
                                                        (("8"
                                                          (assert)
                                                          nil
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil)
                                                 ("9" (propax) nil nil)
                                                 ("10"
                                                  (insteep -)
                                                  (("10"
                                                    (insteep -)
                                                    (("10"
                                                      (assert)
                                                      nil
                                                      nil))
                                                    nil))
                                                  nil)
                                                 ("11"
                                                  (insteep -)
                                                  (("11"
                                                    (insteep -)
                                                    (("11"
                                                      (assert)
                                                      nil
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil)
                                   ("3"
                                    (rewrite "aerrByOp_evaluable")
                                    (("1"
                                      (hide 3)
                                      (("1"
                                        (hide 2)
                                        (("1"
                                          (use
                                           "input_esem_th.evaluable_in_expr_FtoR")
                                          (("1"
                                            (assert)
                                            (("1"
                                              (expand
                                               "bounded_by?_fpaexpr")
                                              (("1"
                                                (rewrite
                                                 "input_esem_th.evaluable_in_fpaexpr_def_op")
                                                nil
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil)
                                     ("2"
                                      (hide 2 3)
                                      (("2"
                                        (use
                                         "input_esem_th.evaluable_in_expr_FtoR")
                                        (("2"
                                          (assert)
                                          (("2"
                                            (expand
                                             "bounded_by?_fpaexpr")
                                            (("2"
                                              (rewrite
                                               "input_esem_th.evaluable_in_fpaexpr_def_op")
                                              nil
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil)
                                   ("4"
                                    (rewrite "aerrByOp_evaluable")
                                    nil
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("4" (expand "aerrByOp_ve")
          (("4" (expand "makeRE")
            (("4" (rewrite "input_esem_th.evaluable_in_raexpr_def_op")
              (("4" (split 1)
                (("1"
                  (rewrite "input_esem_th.no_local_vars_r_evaluable_in"
                   1)
                  nil nil)
                 ("2"
                  (rewrite "input_esem_th.no_local_vars_r_evaluable_in"
                   1)
                  nil nil))
                nil))
              nil))
            nil))
          nil)
         ("5" (expand "aerrByOp_ve")
          (("5" (expand "makeRE")
            (("5" (skeep)
              (("5" (insteep -5)
                (("5" (insteep -10) (("5" (grind) nil nil)) nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((correctResultAndError? const-decl "bool"
     accumulated_roundoff_error nil)
    (appears? const-decl "bool" expressions nil)
    (le const-decl "bool" le "orders/")
    (le_r const-decl "bool" le_r nil)
    (evaluable_in_raexpr_def_op formula-decl nil expressions_semantics
     nil)
    (no_local_vars_r_evaluable_in formula-decl nil
     expressions_semantics nil)
    (symbolic_accumulated_error_bound? const-decl "bool"
     accumulated_roundoff_error nil)
    (FtoR const-decl "{rle: RLocalEnvironment |
         size(fle) = size(rle) AND
          (FORALL (i: below(size(rle))): get(rle)(i) = FtoR(get(fle)(i)))}"
     expressions_semantics nil)
    (FtoR def-decl "RAExpr" expressions nil)
    (get const-decl "T" u_local_environment nil)
    (below type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (size const-decl "nat" u_local_environment nil)
    (RLocalEnvironment type-eq-decl nil expressions_semantics nil)
    (<< adt-def-decl "(strict_well_founded?[RAExpr])" expressions nil)
    (rVarIndex const-decl "nat" expressions_semantics nil)
    (aerrByOp_evaluable formula-decl nil accumulated_roundoff_error
     nil)
    (FPEnvironment nonempty-type-eq-decl nil expressions_semantics nil)
    (FPNumber nonempty-type-eq-decl nil expressions nil)
    (ParameterIndex nonempty-type-eq-decl nil expressions nil)
    (iRToAR_env def-decl
     "{arLocalEnv: analysis_esem_th.RLocalEnvironment |
         size(rLocalEnv) = size(arLocalEnv)}" two_level_expressions
     nil)
    (FtoR const-decl "InducedREnv(fpEnv)" expressions_semantics nil)
    (InducedREnv nonempty-type-eq-decl nil expressions_semantics nil)
    (iRToAR_par const-decl "analysis_esem_th.REnvironment"
     two_level_expressions nil)
    (eval def-decl "RNumber" expressions_semantics nil)
    (REnvironment nonempty-type-eq-decl nil expressions_semantics nil)
    (RNumber nonempty-type-eq-decl nil expressions nil)
    (aerrByOp_definition formula-decl nil accumulated_roundoff_error
     nil)
    (err2 skolem-const-decl
     "(correctResultAndError?(fpLocalEnv, exp2))"
     accumulated_roundoff_error nil)
    (exp2 skolem-const-decl
     "FPAExpr[(operatorUnderAnalysis?), RealNumber, FloatingPointNumber, FtoR]"
     accumulated_roundoff_error nil)
    (err1 skolem-const-decl
     "(correctResultAndError?(fpLocalEnv, exp1))"
     accumulated_roundoff_error nil)
    (exp1 skolem-const-decl
     "FPAExpr[(operatorUnderAnalysis?), RealNumber, FloatingPointNumber, FtoR]"
     accumulated_roundoff_error nil)
    (fpLocalEnv skolem-const-decl "input_esem_th
    [(operatorUnderAnalysis?), RealNumber, lt_r,
     restrict
         [[Operator, RealNumber, RealNumber],
          [(operatorUnderAnalysis?), RealNumber, RealNumber], RealNumber]
         (applyFun_r),
     FloatingPointNumber, lt_fp,
     restrict
         [[Operator, FloatingPointNumber, FloatingPointNumber],
          [(operatorUnderAnalysis?), FloatingPointNumber,
           FloatingPointNumber],
          FloatingPointNumber]
         (applyFun_fp),
     FtoR].FPLocalEnvironment" accumulated_roundoff_error nil)
    (bounded_by?_raexpr const-decl "bool" expressions_semantics nil)
    (aerrByOp_functional_on_param_evaluation formula-decl nil
     accumulated_roundoff_error nil)
    (bounded_by?_fpaexpr const-decl "bool" expressions_semantics nil)
    (evaluable_in_fpaexpr_def_op formula-decl nil expressions_semantics
     nil)
    (evaluable_in_expr_FtoR formula-decl nil expressions_semantics nil)
    (error skolem-const-decl
           "RAExpr[Operator, RealNumber, FloatingPointNumber, FtoR]"
           accumulated_roundoff_error nil)
    (NoLocalVars?_r_op formula-decl nil expressions nil)
    (NoLocalVars? const-decl "bool" expressions nil)
    (makeRE const-decl "ResultAndErrorExprPair"
     accumulated_roundoff_error nil)
    (appears?_analysis_local_input_locals formula-decl nil
     two_level_expressions nil)
    (Operator formal-nonempty-type-decl nil accumulated_roundoff_error
     nil)
    (PRED type-eq-decl nil defined_types nil)
    (operatorUnderAnalysis? formal-const-decl
     "{p: PRED[Operator] | EXISTS (op: Operator): p(op)}"
     accumulated_roundoff_error nil)
    (RealNumber formal-nonempty-type-decl nil
     accumulated_roundoff_error nil)
    (pred type-eq-decl nil defined_types nil)
    (strict_total_order? const-decl "bool" orders nil)
    (lt_r formal-const-decl "(strict_total_order?[RealNumber])"
     accumulated_roundoff_error nil)
    (applyFun_r formal-const-decl
     "[[Operator, RealNumber, RealNumber] -> RealNumber]"
     accumulated_roundoff_error nil)
    (FloatingPointNumber formal-nonempty-type-decl nil
     accumulated_roundoff_error nil)
    (lt_fp formal-const-decl
     "(strict_total_order?[FloatingPointNumber])"
     accumulated_roundoff_error nil)
    (applyFun_fp formal-const-decl
     "[[Operator, FloatingPointNumber, FloatingPointNumber] ->
   FloatingPointNumber]" accumulated_roundoff_error nil)
    (FtoR formal-const-decl "[FloatingPointNumber -> RealNumber]"
     accumulated_roundoff_error nil)
    (bounded_by? const-decl "bool" u_local_environment nil)
    (LocalEnvironment nonempty-type-decl nil u_local_environment nil)
    (<< adt-def-decl "(strict_well_founded?[FPAExpr])" expressions nil)
    (strict_well_founded? const-decl "bool" orders nil)
    (fpVarIndex const-decl "nat" expressions_semantics nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (FPVariable? adt-recognizer-decl "[FPAExpr -> boolean]" expressions
     nil)
    (FPAExpr type-decl nil expressions nil)
    (FPLocalEnvironment type-eq-decl nil expressions_semantics nil)
    (restrict const-decl "R" restrict nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (ResultAndErrorExprPair type-eq-decl nil accumulated_roundoff_error
     nil)
    (aerrByOp formal-const-decl "[(operatorUnderAnalysis?) ->
   [input_expr_th.RAExpr, analysis_expr_th.RAExpr, input_expr_th.RAExpr,
    analysis_expr_th.RAExpr ->
      analysis_expr_th.RAExpr]]" accumulated_roundoff_error nil)
    (RVariable? adt-recognizer-decl "[RAExpr -> boolean]" expressions
     nil)
    (RAExpr type-decl nil expressions nil)
    (appears?_analysis_iRToAR_rexpr formula-decl nil
     two_level_expressions nil)
    (IRExpr type-eq-decl nil two_level_expressions nil)
    (index shared-adt-accessor-decl
           "[{x: RAExpr | RVariable?(x) OR RParameter?(x)} -> DeBruijnIndex]"
           expressions nil)
    (DeBruijnIndex nonempty-type-eq-decl nil expressions nil)
    (RParameter? adt-recognizer-decl "[RAExpr -> boolean]" expressions
     nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (iRToAR def-decl "analysis_expr_th.RAExpr" two_level_expressions
     nil)
    (aerrByOp_does_not_add_locals formula-decl nil
     accumulated_roundoff_error nil)
    (rvariable_irtoar_rlocal application-judgement
     "(analysis_expr_th.RVariable?)" accumulated_roundoff_error nil)
    (aerrByOp_ve const-decl "ResultAndErrorExprPair"
     accumulated_roundoff_error nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   shostak)
  (precisa_symbolic_error_TCC11-2 nil 3756660187
   ("" (termination-tcc) nil nil)
   ((LocalEnvironment nonempty-type-decl nil u_local_environment nil)
    (FPLocalEnvironment type-eq-decl nil expressions_semantics nil)
    (FPOperator? adt-recognizer-decl "[FPAExpr -> boolean]" expressions
     nil)
    (FPOperator adt-constructor-decl
     "[[Operator, FPAExpr, FPAExpr] -> (FPOperator?)]" expressions nil)
    (fpVarIndex const-decl "nat" expressions_semantics nil)
    (maxFreeLocalIndex def-decl "{maxInd: upfrom(-1) |
         IF EXISTS (local: (FPVariable?)): subterm(local, expr)
           THEN (EXISTS (local: (FPVariable?) | subterm(local, expr)):
                   index(local) = maxInd)
                 AND
                 (FORALL (local: (FPVariable?) | subterm(local, expr)):
                    index(local) <= maxInd)
         ELSE maxInd = -1
         ENDIF}" expressions nil)
    (index shared-adt-accessor-decl
           "[{x: FPAExpr | FPVariable?(x) OR FPParameter?(x)} -> DeBruijnIndex]"
           expressions nil)
    (DeBruijnIndex nonempty-type-eq-decl nil expressions nil)
    (FPParameter? adt-recognizer-decl "[FPAExpr -> boolean]"
     expressions nil)
    (FPVariable? adt-recognizer-decl "[FPAExpr -> boolean]" expressions
     nil)
    (FPAExpr type-decl nil expressions nil)
    (bounded_by? const-decl "bool" u_local_environment nil)
    (bounded_by?_fpaexpr const-decl "bool" expressions_semantics nil)
    (<< adt-def-decl "(strict_well_founded?[FPAExpr])" expressions
     nil))
   shostak)
  (precisa_symbolic_error_TCC11-1 nil 3756216926
   ("" (skeep* :preds? t)
    (("" (use "evaluable_in_fpaexpr_def_op") (("" (assert) nil nil))
      nil))
    nil)
   ((evaluable_in_fpaexpr_def_op formula-decl nil expressions_semantics
     nil)
    (FPAExpr type-decl nil expressions nil)
    (FPLocalEnvironment type-eq-decl nil expressions_semantics nil)
    (LocalEnvironment nonempty-type-decl nil u_local_environment nil)
    (<< adt-def-decl "(strict_well_founded?[FPAExpr])" expressions nil)
    (maxFreeLocalIndex def-decl "{maxInd: upfrom(-1) |
         IF EXISTS (local: (FPVariable?)): subterm(local, expr)
           THEN (EXISTS (local: (FPVariable?) | subterm(local, expr)):
                   index(local) = maxInd)
                 AND
                 (FORALL (local: (FPVariable?) | subterm(local, expr)):
                    index(local) <= maxInd)
         ELSE maxInd = -1
         ENDIF}" expressions nil)
    (index shared-adt-accessor-decl
           "[{x: FPAExpr | FPVariable?(x) OR FPParameter?(x)} -> DeBruijnIndex]"
           expressions nil)
    (DeBruijnIndex nonempty-type-eq-decl nil expressions nil)
    (FPParameter? adt-recognizer-decl "[FPAExpr -> boolean]"
     expressions nil)
    (fpVarIndex const-decl "nat" expressions_semantics nil)
    (FPVariable? adt-recognizer-decl "[FPAExpr -> boolean]" expressions
     nil))
   nil))
 (precisa_symbolic_error_TCC12 0
  (precisa_symbolic_error_TCC12-1 nil 3756216926
   ("" (termination-tcc) nil nil)
   ((NOT const-decl "[bool -> bool]" booleans nil)
    (LocalEnvironment nonempty-type-decl nil u_local_environment nil)
    (FPLocalEnvironment type-eq-decl nil expressions_semantics nil)
    (exp2!1 skolem-const-decl
     "FPAExpr[(operatorUnderAnalysis?), RealNumber, FloatingPointNumber, FtoR]"
     accumulated_roundoff_error nil)
    (v!1 skolem-const-decl
     "{v: (FPVariable?) | v = exp1!1 OR v << exp1!1}"
     accumulated_roundoff_error nil)
    (exp1!1 skolem-const-decl
     "FPAExpr[(operatorUnderAnalysis?), RealNumber, FloatingPointNumber, FtoR]"
     accumulated_roundoff_error nil)
    (FPOperator? adt-recognizer-decl "[FPAExpr -> boolean]" expressions
     nil)
    (FPOperator adt-constructor-decl
     "[[Operator, FPAExpr, FPAExpr] -> (FPOperator?)]" expressions nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (applyFun_fp formal-const-decl
     "[[Operator, FloatingPointNumber, FloatingPointNumber] ->
   FloatingPointNumber]" accumulated_roundoff_error nil)
    (lt_fp formal-const-decl
     "(strict_total_order?[FloatingPointNumber])"
     accumulated_roundoff_error nil)
    (applyFun_r formal-const-decl
     "[[Operator, RealNumber, RealNumber] -> RealNumber]"
     accumulated_roundoff_error nil)
    (restrict const-decl "R" restrict nil)
    (lt_r formal-const-decl "(strict_total_order?[RealNumber])"
     accumulated_roundoff_error nil)
    (strict_total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (fpVarIndex const-decl "nat" expressions_semantics nil)
    (strict_well_founded? const-decl "bool" orders nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (FPVariable? adt-recognizer-decl "[FPAExpr -> boolean]" expressions
     nil)
    (FPAExpr type-decl nil expressions nil)
    (bounded_by? const-decl "bool" u_local_environment nil)
    (bounded_by?_fpaexpr const-decl "bool" expressions_semantics nil)
    (<< adt-def-decl "(strict_well_founded?[FPAExpr])" expressions nil)
    (Operator formal-nonempty-type-decl nil accumulated_roundoff_error
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (PRED type-eq-decl nil defined_types nil)
    (operatorUnderAnalysis? formal-const-decl
     "{p: PRED[Operator] | EXISTS (op: Operator): p(op)}"
     accumulated_roundoff_error nil)
    (RealNumber formal-nonempty-type-decl nil
     accumulated_roundoff_error nil)
    (FloatingPointNumber formal-nonempty-type-decl nil
     accumulated_roundoff_error nil)
    (FtoR formal-const-decl "[FloatingPointNumber -> RealNumber]"
     accumulated_roundoff_error nil))
   shostak))
 (precisa_symbolic_error_TCC13 0
  (precisa_symbolic_error_TCC13-1 nil 3757114431
   ("" (termination-tcc) nil nil)
   ((NOT const-decl "[bool -> bool]" booleans nil)
    (LocalEnvironment nonempty-type-decl nil u_local_environment nil)
    (FPLocalEnvironment type-eq-decl nil expressions_semantics nil)
    (bounded_by?_fpaexpr const-decl "bool" expressions_semantics nil)
    (bounded_by? const-decl "bool" u_local_environment nil)
    (FtoR formal-const-decl "[FloatingPointNumber -> RealNumber]"
     accumulated_roundoff_error nil)
    (applyFun_fp formal-const-decl
     "[[Operator, FloatingPointNumber, FloatingPointNumber] ->
   FloatingPointNumber]" accumulated_roundoff_error nil)
    (lt_fp formal-const-decl
     "(strict_total_order?[FloatingPointNumber])"
     accumulated_roundoff_error nil)
    (FloatingPointNumber formal-nonempty-type-decl nil
     accumulated_roundoff_error nil)
    (applyFun_r formal-const-decl
     "[[Operator, RealNumber, RealNumber] -> RealNumber]"
     accumulated_roundoff_error nil)
    (restrict const-decl "R" restrict nil)
    (lt_r formal-const-decl "(strict_total_order?[RealNumber])"
     accumulated_roundoff_error nil)
    (strict_total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (RealNumber formal-nonempty-type-decl nil
     accumulated_roundoff_error nil)
    (operatorUnderAnalysis? formal-const-decl
     "{p: PRED[Operator] | EXISTS (op: Operator): p(op)}"
     accumulated_roundoff_error nil)
    (PRED type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (Operator formal-nonempty-type-decl nil accumulated_roundoff_error
     nil)
    (make_context_fpaexpr const-decl "fp_local_env.EvaluationContext"
     expressions_semantics nil)
    (<< adt-def-decl "(strict_well_founded?[FPAExpr])" expressions nil)
    (strict_well_founded? const-decl "bool" orders nil)
    (fpVarIndex const-decl "nat" expressions_semantics nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (FPVariable? adt-recognizer-decl "[FPAExpr -> boolean]" expressions
     nil)
    (FPAExpr type-decl nil expressions nil)
    (<< const-decl "[EvaluationContext, EvaluationContext -> bool]"
     u_local_environment nil))
   nil))
 (optimizer_TCC1 0
  (optimizer_TCC1-1 nil 3756210679
   ("" (use "optimizer_existence")
    (("" (skeep :preds? t)
      (("" (inst 1 "optimizer")
        (("" (split 1)
          (("1" (skeep* :preds? t)
            (("1" (expand "bounded_by?_raexpr")
              (("1" (propax) nil nil)) nil))
            nil)
           ("2" (skeep* :preds? t)
            (("2" (typepred "optimizer(x1)") (("2" (assert) nil nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((TRUE const-decl "bool" booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (optimizer skolem-const-decl
     "[rLocalEnv: analysis_esem_th.RLocalEnvironment,
 rexpr: {rexpr: analysis_expr_th.RAExpr | bounded_by?(rLocalEnv)(rexpr)} ->
   (upperBound?(rLocalEnv, rexpr))]" accumulated_roundoff_error nil)
    (upperBound? const-decl "bool" accumulated_roundoff_error nil)
    (bounded_by? const-decl "bool" u_local_environment nil)
    (bounded_by?_raexpr const-decl "bool" expressions_semantics nil)
    (LocalEnvironment nonempty-type-decl nil u_local_environment nil)
    (<< adt-def-decl "(strict_well_founded?[RAExpr])" expressions nil)
    (strict_well_founded? const-decl "bool" orders nil)
    (rVarIndex const-decl "nat" expressions_semantics nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (RVariable? adt-recognizer-decl "[RAExpr -> boolean]" expressions
     nil)
    (RAExpr type-decl nil expressions nil)
    (RLocalEnvironment type-eq-decl nil expressions_semantics nil)
    (FtoR formal-const-decl "[FloatingPointNumber -> RealNumber]"
     accumulated_roundoff_error nil)
    (applyFun_fp formal-const-decl
     "[[Operator, FloatingPointNumber, FloatingPointNumber] ->
   FloatingPointNumber]" accumulated_roundoff_error nil)
    (lt_fp formal-const-decl
     "(strict_total_order?[FloatingPointNumber])"
     accumulated_roundoff_error nil)
    (FloatingPointNumber formal-nonempty-type-decl nil
     accumulated_roundoff_error nil)
    (applyFun_r formal-const-decl
     "[[Operator, RealNumber, RealNumber] -> RealNumber]"
     accumulated_roundoff_error nil)
    (lt_r formal-const-decl "(strict_total_order?[RealNumber])"
     accumulated_roundoff_error nil)
    (strict_total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (RealNumber formal-nonempty-type-decl nil
     accumulated_roundoff_error nil)
    (Operator formal-nonempty-type-decl nil accumulated_roundoff_error
     nil)
    (optimizer_existence formula-decl nil accumulated_roundoff_error
     nil))
   shostak))
 (accumulated_error_bound?_TCC1 0
  (accumulated_error_bound?_TCC1-1 nil 3756210679
   ("" (skosimp* :preds? t)
    (("" (use "input_esem_th.evaluable_in_expr_FtoR")
      (("" (assert)
        (("" (expand "consistentLocalEnvironments?")
          (("" (propax) nil nil)) nil))
        nil))
      nil))
    nil)
   ((evaluable_in_expr_FtoR formula-decl nil expressions_semantics nil)
    (ParameterIndex nonempty-type-eq-decl nil expressions nil)
    (FPNumber nonempty-type-eq-decl nil expressions nil)
    (Range type-eq-decl nil expressions_semantics nil)
    (InputRestriction type-eq-decl nil expressions_semantics nil)
    (FPEnvironment nonempty-type-eq-decl nil expressions_semantics nil)
    (validInput? const-decl "bool" expressions_semantics nil)
    (ValidInput type-eq-decl nil expressions_semantics nil)
    (RAExpr type-decl nil expressions nil)
    (RVariable? adt-recognizer-decl "[RAExpr -> boolean]" expressions
     nil)
    (rVarIndex const-decl "nat" expressions_semantics nil)
    (<< adt-def-decl "(strict_well_founded?[RAExpr])" expressions nil)
    (RLocalEnvironment type-eq-decl nil expressions_semantics nil)
    (consistentLocalEnvironments? const-decl "bool"
     expressions_semantics nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (Operator formal-nonempty-type-decl nil accumulated_roundoff_error
     nil)
    (PRED type-eq-decl nil defined_types nil)
    (operatorUnderAnalysis? formal-const-decl
     "{p: PRED[Operator] | EXISTS (op: Operator): p(op)}"
     accumulated_roundoff_error nil)
    (RealNumber formal-nonempty-type-decl nil
     accumulated_roundoff_error nil)
    (FloatingPointNumber formal-nonempty-type-decl nil
     accumulated_roundoff_error nil)
    (FtoR formal-const-decl "[FloatingPointNumber -> RealNumber]"
     accumulated_roundoff_error nil)
    (FPAExpr type-decl nil expressions nil)
    (FPVariable? adt-recognizer-decl "[FPAExpr -> boolean]" expressions
     nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (pred type-eq-decl nil defined_types nil)
    (strict_total_order? const-decl "bool" orders nil)
    (lt_r formal-const-decl "(strict_total_order?[RealNumber])"
     accumulated_roundoff_error nil)
    (restrict const-decl "R" restrict nil)
    (applyFun_r formal-const-decl
     "[[Operator, RealNumber, RealNumber] -> RealNumber]"
     accumulated_roundoff_error nil)
    (lt_fp formal-const-decl
     "(strict_total_order?[FloatingPointNumber])"
     accumulated_roundoff_error nil)
    (applyFun_fp formal-const-decl
     "[[Operator, FloatingPointNumber, FloatingPointNumber] ->
   FloatingPointNumber]" accumulated_roundoff_error nil)
    (fpVarIndex const-decl "nat" expressions_semantics nil)
    (strict_well_founded? const-decl "bool" orders nil)
    (<< adt-def-decl "(strict_well_founded?[FPAExpr])" expressions nil)
    (LocalEnvironment nonempty-type-decl nil u_local_environment nil)
    (bounded_by? const-decl "bool" u_local_environment nil)
    (FPLocalEnvironment type-eq-decl nil expressions_semantics nil))
   shostak))
 (accumulated_error_TCC1 0
  (accumulated_error_TCC1-1 nil 3752326880
   ("" (skosimp* :preds? t)
    (("" (expand "bounded_by?_fpaexpr") (("" (propax) nil nil)) nil))
    nil)
   ((bounded_by?_fpaexpr const-decl "bool" expressions_semantics nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (Operator formal-nonempty-type-decl nil accumulated_roundoff_error
     nil)
    (PRED type-eq-decl nil defined_types nil)
    (operatorUnderAnalysis? formal-const-decl
     "{p: PRED[Operator] | EXISTS (op: Operator): p(op)}"
     accumulated_roundoff_error nil)
    (RealNumber formal-nonempty-type-decl nil
     accumulated_roundoff_error nil)
    (FloatingPointNumber formal-nonempty-type-decl nil
     accumulated_roundoff_error nil)
    (FtoR formal-const-decl "[FloatingPointNumber -> RealNumber]"
     accumulated_roundoff_error nil)
    (FPAExpr type-decl nil expressions nil)
    (FPVariable? adt-recognizer-decl "[FPAExpr -> boolean]" expressions
     nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (pred type-eq-decl nil defined_types nil)
    (strict_total_order? const-decl "bool" orders nil)
    (lt_r formal-const-decl "(strict_total_order?[RealNumber])"
     accumulated_roundoff_error nil)
    (restrict const-decl "R" restrict nil)
    (applyFun_r formal-const-decl
     "[[Operator, RealNumber, RealNumber] -> RealNumber]"
     accumulated_roundoff_error nil)
    (lt_fp formal-const-decl
     "(strict_total_order?[FloatingPointNumber])"
     accumulated_roundoff_error nil)
    (applyFun_fp formal-const-decl
     "[[Operator, FloatingPointNumber, FloatingPointNumber] ->
   FloatingPointNumber]" accumulated_roundoff_error nil)
    (fpVarIndex const-decl "nat" expressions_semantics nil)
    (strict_well_founded? const-decl "bool" orders nil)
    (<< adt-def-decl "(strict_well_founded?[FPAExpr])" expressions nil)
    (LocalEnvironment nonempty-type-decl nil u_local_environment nil)
    (bounded_by? const-decl "bool" u_local_environment nil)
    (FPLocalEnvironment type-eq-decl nil expressions_semantics nil))
   shostak))
 (accumulated_error_TCC2 0
  (accumulated_error_TCC2-2 "" 3757154555
   ("" (skosimp* :preds? t)
    (("" (typepred "precisa_symbolic_error(fpLocalEnv!1, expr!1)")
      (("" (expand "correctResultAndError?")
        (("" (expand "symbolic_accumulated_error_bound?")
          (("" (flatten)
            (("" (expand "bounded_by?_raexpr") (("" (propax) nil nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((precisa_symbolic_error def-decl
     "(correctResultAndError?(fpLocalEnv, expr))"
     accumulated_roundoff_error nil)
    (correctResultAndError? const-decl "bool"
     accumulated_roundoff_error nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (ResultAndErrorExprPair type-eq-decl nil accumulated_roundoff_error
     nil)
    (bounded_by?_fpaexpr const-decl "bool" expressions_semantics nil)
    (NoLocalVars? const-decl "bool" expressions nil)
    (RAExpr type-decl nil expressions nil)
    (symbolic_accumulated_error_bound? const-decl "bool"
     accumulated_roundoff_error nil)
    (bounded_by?_raexpr const-decl "bool" expressions_semantics nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (Operator formal-nonempty-type-decl nil accumulated_roundoff_error
     nil)
    (PRED type-eq-decl nil defined_types nil)
    (operatorUnderAnalysis? formal-const-decl
     "{p: PRED[Operator] | EXISTS (op: Operator): p(op)}"
     accumulated_roundoff_error nil)
    (RealNumber formal-nonempty-type-decl nil
     accumulated_roundoff_error nil)
    (FloatingPointNumber formal-nonempty-type-decl nil
     accumulated_roundoff_error nil)
    (FtoR formal-const-decl "[FloatingPointNumber -> RealNumber]"
     accumulated_roundoff_error nil)
    (FPAExpr type-decl nil expressions nil)
    (FPVariable? adt-recognizer-decl "[FPAExpr -> boolean]" expressions
     nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (pred type-eq-decl nil defined_types nil)
    (strict_total_order? const-decl "bool" orders nil)
    (lt_r formal-const-decl "(strict_total_order?[RealNumber])"
     accumulated_roundoff_error nil)
    (restrict const-decl "R" restrict nil)
    (applyFun_r formal-const-decl
     "[[Operator, RealNumber, RealNumber] -> RealNumber]"
     accumulated_roundoff_error nil)
    (lt_fp formal-const-decl
     "(strict_total_order?[FloatingPointNumber])"
     accumulated_roundoff_error nil)
    (applyFun_fp formal-const-decl
     "[[Operator, FloatingPointNumber, FloatingPointNumber] ->
   FloatingPointNumber]" accumulated_roundoff_error nil)
    (fpVarIndex const-decl "nat" expressions_semantics nil)
    (strict_well_founded? const-decl "bool" orders nil)
    (<< adt-def-decl "(strict_well_founded?[FPAExpr])" expressions nil)
    (LocalEnvironment nonempty-type-decl nil u_local_environment nil)
    (bounded_by? const-decl "bool" u_local_environment nil)
    (FPLocalEnvironment type-eq-decl nil expressions_semantics nil))
   shostak)
  (accumulated_error_TCC2-1 nil 3752326880
   ("" (skeep* :preds? t)
    (("" (expand "accumulated_error_bound?")
      ((""
        (with-tccs
         (typepred
          "optimizer(FtoR(fpLocalEnv),error(precisa_symbolic_error(fpLocalEnv, expr)))"))
        (("" (expand "upperBound?")
          (("" (typepred "precisa_symbolic_error(fpLocalEnv, expr)")
            (("" (expand "correctResultAndError?")
              (("" (expand "symbolic_accumulated_error_bound?")
                (("" (flatten)
                  (("" (split 1)
                    (("1"
                      (inst -7
                       "LAMBDA(i:ParameterIndex): (# lb:=zero_r,ub:=zero_r#)"
                       "LAMBDA(i:ParameterIndex):zero_r")
                      (("1"
                        (inst -4 "LAMBDA(i:ParameterIndex):zero_fp")
                        (("1" (flatten)
                          (("1"
                            (case "FtoR(LAMBDA (i: ParameterIndex): zero_fp) = LAMBDA (i: ParameterIndex): zero_r")
                            (("1" (replace -1 :hide? t)
                              (("1"
                                (hide-all-but (-4 -8 1))
                                (("1"
                                  (case "transitive?(le_r)")
                                  (("1"
                                    (expand "transitive?")
                                    (("1"
                                      (inst? -1 :where 1)
                                      (("1"
                                        (inst? -1 :where -2)
                                        (("1" (assert) nil nil))
                                        nil))
                                      nil))
                                    nil)
                                   ("2"
                                    (hide-all-but 1)
                                    (("2"
                                      (use "le_r_total_order")
                                      (("2" (grind) nil nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil)
                             ("2" (hide-all-but 1)
                              (("2"
                                (expand "FtoR")
                                (("2" (apply-extensionality) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil)
                       ("2" (hide-all-but 1)
                        (("2" (expand "rValidInput?")
                          (("2" (skeep 1)
                            (("2" (case "reflexive?(le_r)")
                              (("1"
                                (expand "reflexive?")
                                (("1"
                                  (inst?)
                                  (("1" (assert) nil nil))
                                  nil))
                                nil)
                               ("2"
                                (use "le_r_total_order")
                                (("2" (grind) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil)
                     ("2" (skeep :preds? t)
                      (("2"
                        (inst -9 "FtoR(inputRest)" "FtoR(fpParamEnv)")
                        (("1" (inst -6 "fpParamEnv")
                          (("1" (flatten)
                            (("1" (hide-all-but (-10 -7 1))
                              (("1"
                                (case "transitive?(le_r)")
                                (("1"
                                  (expand "transitive?")
                                  (("1"
                                    (inst? -1 :where 1)
                                    (("1"
                                      (inst
                                       -1
                                       "eval(FtoR(fpParamEnv), FtoR(fpLocalEnv))
                                   (error(precisa_symbolic_error(fpLocalEnv, expr)))")
                                      (("1"
                                        (assert)
                                        (("1"
                                          (case
                                           "FtoR(fpLocalEnv) = rLocalEnv")
                                          (("1" (assert) nil nil)
                                           ("2"
                                            (use
                                             "consistent_local_environments_eq")
                                            (("2" (assert) nil nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil)
                                 ("2"
                                  (hide-all-but 1)
                                  (("2"
                                    (use "le_r_total_order")
                                    (("2" (grind) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil)
                         ("2" (hide-all-but 1)
                          (("2" (use "valid_input_ftor")
                            (("2" (assert) nil nil)) nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((bounded_by?_fpaexpr const-decl "bool" expressions_semantics nil)
    (RAExpr type-decl nil expressions nil)
    (FPAExpr type-decl nil expressions nil)
    (FPVariable? adt-recognizer-decl "[FPAExpr -> boolean]" expressions
     nil)
    (fpVarIndex const-decl "nat" expressions_semantics nil)
    (FPParameter? adt-recognizer-decl "[FPAExpr -> boolean]"
     expressions nil)
    (DeBruijnIndex nonempty-type-eq-decl nil expressions nil)
    (index shared-adt-accessor-decl
           "[{x: FPAExpr | FPVariable?(x) OR FPParameter?(x)} -> DeBruijnIndex]"
           expressions nil)
    (maxFreeLocalIndex def-decl "{maxInd: upfrom(-1) |
         IF EXISTS (local: (FPVariable?)): subterm(local, expr)
           THEN (EXISTS (local: (FPVariable?) | subterm(local, expr)):
                   index(local) = maxInd)
                 AND
                 (FORALL (local: (FPVariable?) | subterm(local, expr)):
                    index(local) <= maxInd)
         ELSE maxInd = -1
         ENDIF}" expressions nil)
    (<< adt-def-decl "(strict_well_founded?[FPAExpr])" expressions nil)
    (LocalEnvironment nonempty-type-decl nil u_local_environment nil)
    (bounded_by? const-decl "bool" u_local_environment nil)
    (FPLocalEnvironment type-eq-decl nil expressions_semantics nil))
   shostak))
 (accumulated_error_TCC3 0
  (accumulated_error_TCC3-2 "" 3757156684
   ("" (skosimp* :preds? t)
    (("" (expand "accumulated_error_bound?")
      ((""
        (with-tccs
         (typepred "optimizer(iRToAR_env
                                         (input_esem_th
                                          [(operatorUnderAnalysis?),
                                           RealNumber,
                                           lt_r,
                                           restrict
                                           [[Operator,
                                             RealNumber,
                                             RealNumber],
                                            [(operatorUnderAnalysis?),
                                             RealNumber,
                                             RealNumber],
                                            RealNumber]
                                           (applyFun_r),
                                           FloatingPointNumber,
                                           lt_fp,
                                           restrict
                                           [[Operator,
                                             FloatingPointNumber,
                                             FloatingPointNumber],
                                            [(operatorUnderAnalysis?),
                                             FloatingPointNumber,
                                             FloatingPointNumber],
                                            FloatingPointNumber]
                                           (applyFun_fp),
                                           FtoR].FtoR
                                          (fpLocalEnv!1)),
                                         error
                                         (precisa_symbolic_error
                                          (fpLocalEnv!1, expr!1)))"))
        (("" (expand "upperBound?")
          ((""
            (typepred "precisa_symbolic_error(fpLocalEnv!1, expr!1)")
            (("1" (expand "correctResultAndError?")
              (("1" (expand "symbolic_accumulated_error_bound?")
                (("1" (flatten)
                  (("1" (split 1)
                    (("1"
                      (inst -7
                       "LAMBDA(i:analysis_expr_th.ParameterIndex): (# lb:=zero_r,ub:=zero_r#)"
                       "iRToAR_par(LAMBDA(i:input_expr_th.ParameterIndex):zero_r)")
                      (("1"
                        (inst -4
                         "LAMBDA(i:input_expr_th.ParameterIndex):zero_fp")
                        (("1" (flatten)
                          (("1"
                            (case "input_esem_th.FtoR(LAMBDA (i: input_expr_th.ParameterIndex): zero_fp) = LAMBDA (i: input_expr_th.ParameterIndex): zero_r")
                            (("1" (replace -1 :hide? t)
                              (("1"
                                (hide-all-but (-4 -8 1))
                                (("1"
                                  (case "transitive?(le_r)")
                                  (("1"
                                    (expand "transitive?")
                                    (("1"
                                      (inst? -1 :where 1)
                                      (("1"
                                        (inst? -1 :where -2)
                                        (("1" (assert) nil nil))
                                        nil))
                                      nil))
                                    nil)
                                   ("2"
                                    (hide-all-but 1)
                                    (("2"
                                      (use "le_r_total_order")
                                      (("2" (grind) nil nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil)
                             ("2" (hide-all-but 1)
                              (("2"
                                (expand "FtoR")
                                (("2" (apply-extensionality) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil)
                       ("2" (hide-all-but 1)
                        (("2" (expand "rValidInput?")
                          (("2" (skeep 1)
                            (("2" (rewrite "iRToAR_par_def")
                              (("2"
                                (case "reflexive?(le_r)")
                                (("1"
                                  (expand "reflexive?")
                                  (("1"
                                    (inst?)
                                    (("1" (assert) nil nil))
                                    nil))
                                  nil)
                                 ("2"
                                  (use "le_r_total_order")
                                  (("2" (grind) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil)
                     ("2" (skeep :preds? t)
                      (("2"
                        (inst -8
                         "iRToAR_res(input_esem_th.FtoR(inputRest))"
                         "iRToAR_par(input_esem_th.FtoR(fpParamEnv))")
                        (("1" (inst -5 "fpParamEnv")
                          (("1" (flatten)
                            (("1" (hide-all-but (-9 -6 1))
                              (("1"
                                (case "transitive?(le_r)")
                                (("1"
                                  (expand "transitive?")
                                  (("1"
                                    (inst? -1 :where 1)
                                    (("1"
                                      (inst
                                       -1
                                       "analysis_esem_th.eval
               (iRToAR_par(input_esem_th.FtoR(fpParamEnv)),
                iRToAR_env(input_esem_th.FtoR(fpLocalEnv!1)))
               (error(precisa_symbolic_error(fpLocalEnv!1, expr!1)))")
                                      (("1"
                                        (assert)
                                        (("1"
                                          (case
                                           "input_esem_th.FtoR(fpLocalEnv!1) = rLocalEnv")
                                          (("1" (assert) nil nil)
                                           ("2"
                                            (use
                                             "input_esem_th.consistent_local_environments_eq")
                                            (("2" (assert) nil nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil)
                                 ("2"
                                  (hide-all-but 1)
                                  (("2"
                                    (use "le_r_total_order")
                                    (("2" (grind) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil)
                         ("2" (hide-all-but (-1 1))
                          (("2" (use "input_esem_th.valid_input_ftor")
                            (("2" (assert)
                              (("2"
                                (hide -2)
                                (("2"
                                  (use "iRToAR_res_rValidInput")
                                  (("2" (assert) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (expand "bounded_by?_fpaexpr")
              (("2" (propax) nil nil)) nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((accumulated_error_bound? const-decl "bool"
     accumulated_roundoff_error nil)
    (iRToAR_res_rValidInput formula-decl nil two_level_expressions nil)
    (valid_input_ftor formula-decl nil expressions_semantics nil)
    (consistent_local_environments_eq formula-decl nil
     expressions_semantics nil)
    (abs formal-const-decl "[RealNumber -> RealNumber]"
         accumulated_roundoff_error nil)
    (minus formal-const-decl "[RealNumber, RealNumber -> RealNumber]"
     accumulated_roundoff_error nil)
    (eval def-decl "FPNumber" expressions_semantics nil)
    (fpParamEnv skolem-const-decl "ValidInput
    [(operatorUnderAnalysis?), RealNumber, lt_r,
     restrict
         [[Operator, RealNumber, RealNumber],
          [(operatorUnderAnalysis?), RealNumber, RealNumber], RealNumber]
         (applyFun_r),
     FloatingPointNumber, lt_fp,
     restrict
         [[Operator, FloatingPointNumber, FloatingPointNumber],
          [(operatorUnderAnalysis?), FloatingPointNumber,
           FloatingPointNumber],
          FloatingPointNumber]
         (applyFun_fp),
     FtoR](inputRest)" accumulated_roundoff_error nil)
    (inputRest skolem-const-decl "InputRestriction
    [(operatorUnderAnalysis?), RealNumber, lt_r,
     restrict
         [[Operator, RealNumber, RealNumber],
          [(operatorUnderAnalysis?), RealNumber, RealNumber], RealNumber]
         (applyFun_r),
     FloatingPointNumber, lt_fp,
     restrict
         [[Operator, FloatingPointNumber, FloatingPointNumber],
          [(operatorUnderAnalysis?), FloatingPointNumber,
           FloatingPointNumber],
          FloatingPointNumber]
         (applyFun_fp),
     FtoR]" accumulated_roundoff_error nil)
    (FtoR const-decl "RInputRestriction" expressions_semantics nil)
    (iRToAR_res const-decl "analysis_esem_th.RInputRestriction"
     two_level_expressions nil)
    (RNumber nonempty-type-eq-decl nil expressions nil)
    (RRange type-eq-decl nil expressions_semantics nil)
    (RInputRestriction type-eq-decl nil expressions_semantics nil)
    (REnvironment nonempty-type-eq-decl nil expressions_semantics nil)
    (rValidInput? const-decl "bool" expressions_semantics nil)
    (iRToAR_par const-decl "analysis_esem_th.REnvironment"
     two_level_expressions nil)
    (RValidInput type-eq-decl nil expressions_semantics nil)
    (ftor_zero_fp formula-decl nil accumulated_roundoff_error nil)
    (transitive? const-decl "bool" relations nil)
    (eval def-decl "RNumber" expressions_semantics nil)
    (le_r_total_order formula-decl nil le_r nil)
    (total_order? const-decl "bool" orders nil)
    (dichotomous? const-decl "bool" orders nil)
    (partial_order? const-decl "bool" orders nil)
    (antisymmetric? const-decl "bool" relations nil)
    (preorder? const-decl "bool" orders nil)
    (reflexive? const-decl "bool" relations nil)
    (le const-decl "bool" le "orders/")
    (FtoR const-decl "InducedREnv(fpEnv)" expressions_semantics nil)
    (InducedREnv nonempty-type-eq-decl nil expressions_semantics nil)
    (zero_fp formal-const-decl "FloatingPointNumber"
     accumulated_roundoff_error nil)
    (iRToAR_par_def formula-decl nil two_level_expressions nil)
    (symbolic_accumulated_error_bound? const-decl "bool"
     accumulated_roundoff_error nil)
    (consistentLocalEnvironments? const-decl "bool"
     expressions_semantics nil)
    (ValidInput type-eq-decl nil expressions_semantics nil)
    (validInput? const-decl "bool" expressions_semantics nil)
    (FPEnvironment nonempty-type-eq-decl nil expressions_semantics nil)
    (InputRestriction type-eq-decl nil expressions_semantics nil)
    (Range type-eq-decl nil expressions_semantics nil)
    (FPNumber nonempty-type-eq-decl nil expressions nil)
    (ParameterIndex nonempty-type-eq-decl nil expressions nil)
    (optimizer const-decl "(upperBound?(rLocalEnv, rexpr))"
     accumulated_roundoff_error nil)
    (upperBound? const-decl "bool" accumulated_roundoff_error nil)
    (zero_r formal-const-decl "RealNumber" accumulated_roundoff_error
     nil)
    (le_r const-decl "bool" le_r nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (precisa_symbolic_error def-decl
     "(correctResultAndError?(fpLocalEnv, expr))"
     accumulated_roundoff_error nil)
    (correctResultAndError? const-decl "bool"
     accumulated_roundoff_error nil)
    (NoLocalVars? const-decl "bool" expressions nil)
    (ResultAndErrorExprPair type-eq-decl nil accumulated_roundoff_error
     nil)
    (FtoR const-decl "{rle: RLocalEnvironment |
         size(fle) = size(rle) AND
          (FORALL (i: below(size(rle))): get(rle)(i) = FtoR(get(fle)(i)))}"
     expressions_semantics nil)
    (FtoR def-decl "RAExpr" expressions nil)
    (get const-decl "T" u_local_environment nil)
    (below type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (iRToAR_env def-decl
     "{arLocalEnv: analysis_esem_th.RLocalEnvironment |
         size(rLocalEnv) = size(arLocalEnv)}" two_level_expressions
     nil)
    (size const-decl "nat" u_local_environment nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (bounded_by?_raexpr const-decl "bool" expressions_semantics nil)
    (RLocalEnvironment type-eq-decl nil expressions_semantics nil)
    (<< adt-def-decl "(strict_well_founded?[RAExpr])" expressions nil)
    (rVarIndex const-decl "nat" expressions_semantics nil)
    (RVariable? adt-recognizer-decl "[RAExpr -> boolean]" expressions
     nil)
    (RAExpr type-decl nil expressions nil)
    (bounded_by?_fpaexpr const-decl "bool" expressions_semantics nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (bijective? const-decl "bool" functions nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (TRUE const-decl "bool" booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (Operator formal-nonempty-type-decl nil accumulated_roundoff_error
     nil)
    (PRED type-eq-decl nil defined_types nil)
    (operatorUnderAnalysis? formal-const-decl
     "{p: PRED[Operator] | EXISTS (op: Operator): p(op)}"
     accumulated_roundoff_error nil)
    (RealNumber formal-nonempty-type-decl nil
     accumulated_roundoff_error nil)
    (FloatingPointNumber formal-nonempty-type-decl nil
     accumulated_roundoff_error nil)
    (FtoR formal-const-decl "[FloatingPointNumber -> RealNumber]"
     accumulated_roundoff_error nil)
    (FPAExpr type-decl nil expressions nil)
    (FPVariable? adt-recognizer-decl "[FPAExpr -> boolean]" expressions
     nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (pred type-eq-decl nil defined_types nil)
    (strict_total_order? const-decl "bool" orders nil)
    (lt_r formal-const-decl "(strict_total_order?[RealNumber])"
     accumulated_roundoff_error nil)
    (restrict const-decl "R" restrict nil)
    (applyFun_r formal-const-decl
     "[[Operator, RealNumber, RealNumber] -> RealNumber]"
     accumulated_roundoff_error nil)
    (lt_fp formal-const-decl
     "(strict_total_order?[FloatingPointNumber])"
     accumulated_roundoff_error nil)
    (applyFun_fp formal-const-decl
     "[[Operator, FloatingPointNumber, FloatingPointNumber] ->
   FloatingPointNumber]" accumulated_roundoff_error nil)
    (fpVarIndex const-decl "nat" expressions_semantics nil)
    (strict_well_founded? const-decl "bool" orders nil)
    (<< adt-def-decl "(strict_well_founded?[FPAExpr])" expressions nil)
    (LocalEnvironment nonempty-type-decl nil u_local_environment nil)
    (bounded_by? const-decl "bool" u_local_environment nil)
    (FPLocalEnvironment type-eq-decl nil expressions_semantics nil))
   shostak)
  (accumulated_error_TCC3-1 nil 3757099122 ("" (subtype-tcc) nil nil)
   nil shostak))
 (accumulated_error_correct 0
  (accumulated_error_correct-1 nil 3752326884
   ("" (skeep*) (("" (assert) nil nil)) nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   shostak)))

