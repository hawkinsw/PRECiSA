(nasalib_float_instantiation
 (lt_fp_TCC1 0
  (lt_fp_TCC1-1 nil 3756753980
   ("" (expand "strict_total_order?")
    (("" (expand "strict_order?")
      (("" (split 1)
        (("1" (expand "irreflexive?")
          (("1" (skeep)
            (("1" (use "FltCorrect") (("1" (grind) nil nil)) nil))
            nil))
          nil)
         ("2" (expand "transitive?")
          (("2" (skeep)
            (("2" (rewrite "FltCorrect")
              (("2" (rewrite "FltCorrect")
                (("2" (rewrite "FltCorrect") (("2" (assert) nil nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("3" (expand "trichotomous?")
          (("3" (skeep)
            (("3" (case "FtoR(x) = FtoR(y)")
              (("1" (hide-all-but (-1 3))
                (("1" (use "FcanonicUnique")
                  (("1" (inst -1 "b") (("1" (assert) nil nil)) nil))
                  nil))
                nil)
               ("2" (rewrite "FltCorrect")
                (("2" (rewrite "FltCorrect") (("2" (assert) nil nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((strict_order? const-decl "bool" orders nil)
    (trichotomous? const-decl "bool" orders nil)
    (FtoR const-decl "real" float "float/")
    (= const-decl "[T, T -> boolean]" equalities nil)
    (FcanonicUnique formula-decl nil float "float/")
    (transitive? const-decl "bool" relations nil)
    (irreflexive? const-decl "bool" relations nil)
    (FltCorrect formula-decl nil float "float/")
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (> const-decl "bool" reals nil)
    (above nonempty-type-eq-decl nil integers nil)
    (radix formal-const-decl "above(1)" nasalib_float_instantiation
     nil)
    (FloatingPointNumber type-eq-decl nil nasalib_float_instantiation
     nil)
    (b formal-const-decl "Format" nasalib_float_instantiation nil)
    (Fcanonic? const-decl "bool" float "float/")
    (Format type-eq-decl nil float "float/")
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (float type-eq-decl nil float "float/")
    (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil)
    (expt def-decl "real" exponentiation nil)
    (^ const-decl "real" exponentiation nil)
    (Fminus const-decl "float" float "float/")
    (Flt? const-decl "bool" float "float/")
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (posrat_div_posrat_is_posrat application-judgement "posrat"
     rationals nil)
    (posnat_expt application-judgement "posnat" exponentiation nil)
    (int_min application-judgement "{k: int | k <= i AND k <= j}"
     real_defs nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (nnrat_exp application-judgement "nnrat" exponentiation nil)
    (rat_times_rat_is_rat application-judgement "rat" rationals nil)
    (rat_minus_rat_is_rat application-judgement "rat" rationals nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (mult_divides1 application-judgement "(divides(n))" divides nil)
    (mult_divides2 application-judgement "(divides(m))" divides nil)
    (strict_total_order? const-decl "bool" orders nil))
   nil))
 (IMP_accum_err_add_TCC1 0
  (IMP_accum_err_add_TCC1-1 nil 3757424589
   ("" (use "round_even_closest") nil nil)
   ((round_even_closest formula-decl nil nasalib_float_instantiation
     nil))
   nil))
 (IMP_accum_err_add_TCC2 0
  (IMP_accum_err_add_TCC2-1 nil 3757424589
   ("" (use "round_rounded_mode") nil nil)
   ((round_rounded_mode formula-decl nil nasalib_float_instantiation
     nil))
   nil))
 (applyFun_fp_TCC1 0
  (applyFun_fp_TCC1-1 nil 3757161980
   ("" (skeep :preds? t)
    (("" (use "ClosestRNDF_FtoR_inverse")
      (("" (lemma "Closest_int_exact_rep")
        (("" (inst -1 "b" "round" "RtoF" "2")
          (("1" (expand "exactly_representable")
            (("1" (assert) nil nil)) nil)
           ("2" (expand "vNum")
            (("2" (typepred "radix")
              (("2" (typepred "Prec(b)")
                (("2" (case "abs(2)=2")
                  (("1" (replace -1 :hide? t)
                    (("1" (hide-all-but (-1 -2 1))
                      (("1" (expand ">")
                        (("1" (expand "^")
                          (("1" (assert)
                            (("1" (use "increasing_expt_aux")
                              (("1"
                                (expand ">")
                                (("1" (grind-reals) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("2" (expand "abs") (("2" (propax) nil nil)) nil))
                  nil))
                nil))
              nil))
            nil)
           ("3" (skeep)
            (("3" (typepred "RtoF")
              (("3" (typepred "round")
                (("3" (inst -1 "r" "RtoF(r)")
                  (("3" (assert) (("3" (inst? -1) nil nil)) nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((ClosestRNDF_FtoR_inverse formula-decl nil float "float/")
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (> const-decl "bool" reals nil)
    (above nonempty-type-eq-decl nil integers nil)
    (radix formal-const-decl "above(1)" nasalib_float_instantiation
     nil)
    (b formal-const-decl "Format" nasalib_float_instantiation nil)
    (Format type-eq-decl nil float "float/")
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (RtoF formal-const-decl "CanonicRoundingFun(b, round)"
     nasalib_float_instantiation nil)
    (CanonicRoundingFun type-eq-decl nil float "float/")
    (Fcanonic? const-decl "bool" float "float/")
    (RNDF type-eq-decl nil float "float/")
    (round formal-const-decl "ClosestRoundingPred(b)"
           nasalib_float_instantiation nil)
    (ClosestRoundingPred type-eq-decl nil float "float/")
    (Closest? const-decl "bool" float "float/")
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (Rounding type-eq-decl nil float "float/")
    (Fbounded? const-decl "bool" float "float/")
    (float type-eq-decl nil float "float/")
    (nzint_abs_is_pos application-judgement "{j: posint | j >= i}"
     real_defs nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (<= const-decl "bool" reals nil) (>= const-decl "bool" reals nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs
         nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (vNum const-decl "posnat" float "float/")
    (exactly_representable const-decl "bool" float "float/")
    (NOT const-decl "[bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (^ const-decl "real" exponentiation nil)
    (increasing_expt_aux formula-decl nil exponentiation nil)
    (posreal nonempty-type-eq-decl nil real_types nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posnat_expt application-judgement "posnat" exponentiation nil)
    (posrat_div_posrat_is_posrat application-judgement "posrat"
     rationals nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (Closest_int_exact_rep formula-decl nil float "float/"))
   nil))
 (applyFun_fp_TCC2 0
  (applyFun_fp_TCC2-1 nil 3757161980
   ("" (skeep)
    (("" (typepred "Fadd(arg1,arg2)")
      (("" (use "FabsCanonic") (("" (assert) nil nil)) nil)) nil))
    nil)
   ((FloatingPointNumber type-eq-decl nil nasalib_float_instantiation
     nil)
    (Fadd const-decl
     "{f3: (Fcanonic?(b)) | Closest?(b)(FtoR(f1) + FtoR(f2), f3)}"
     cr_add "float/")
    (RtoF formal-const-decl "CanonicRoundingFun(b, round)"
     nasalib_float_instantiation nil)
    (CanonicRoundingFun type-eq-decl nil float "float/")
    (RNDF type-eq-decl nil float "float/")
    (round formal-const-decl "ClosestRoundingPred(b)"
           nasalib_float_instantiation nil)
    (ClosestRoundingPred type-eq-decl nil float "float/")
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (Rounding type-eq-decl nil float "float/")
    (FtoR const-decl "real" float "float/")
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (Closest? const-decl "bool" float "float/")
    (Fbounded? const-decl "bool" float "float/")
    (b formal-const-decl "Format" nasalib_float_instantiation nil)
    (Fcanonic? const-decl "bool" float "float/")
    (float type-eq-decl nil float "float/")
    (Format type-eq-decl nil float "float/")
    (radix formal-const-decl "above(1)" nasalib_float_instantiation
     nil)
    (> const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (above nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (FabsCanonic formula-decl nil float "float/"))
   nil))
 (zero_fp_TCC1 0
  (zero_fp_TCC1-1 nil 3756754148
   ("" (expand "float_pair")
    (("" (expand "Fcanonic?")
      (("" (flatten)
        (("" (expand "Fsubnormal?")
          (("" (split 2) (("1" (grind) nil nil) ("2" (grind) nil nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((Fcanonic? const-decl "bool" float "float/")
    (mult_divides1 application-judgement "(divides(n))" divides nil)
    (mult_divides2 application-judgement "(divides(m))" divides nil)
    (Fsubnormal? const-decl "bool" float "float/")
    (int_times_even_is_even application-judgement "even_int" integers
     nil)
    (nnint_times_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (posint_times_posint_is_posint application-judgement "posint"
     integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (minus_nzint_is_nzint application-judgement "nzint" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (posrat_div_posrat_is_posrat application-judgement "posrat"
     rationals nil)
    (posnat_expt application-judgement "posnat" exponentiation nil)
    (posint_exp application-judgement "posint" exponentiation nil)
    (int_abs_is_nonneg application-judgement "{j: nonneg_int | j >= i}"
     real_defs nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (minus_int_is_int application-judgement "int" integers nil)
    (Fnormal? const-decl "bool" float "float/")
    (Fbounded? const-decl "bool" float "float/")
    (vNum const-decl "posnat" float "float/")
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (> const-decl "bool" reals nil)
    (above nonempty-type-eq-decl nil integers nil)
    (radix formal-const-decl "above(1)" nasalib_float_instantiation
     nil)
    (^ const-decl "real" exponentiation nil)
    (expt def-decl "real" exponentiation nil)
    (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs
         nil)
    (float_pair const-decl "float" float "float/"))
   nil))
 (IMP_linear_ineq_zero_beta_TCC1 0
  (IMP_linear_ineq_zero_beta_TCC1-1 nil 3756755128
   ("" (skeep :preds? t)
    (("" (use "FcanonicOpp") (("" (assert) nil nil)) nil)) nil)
   ((FcanonicOpp formula-decl nil float "float/")
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (> const-decl "bool" reals nil)
    (above nonempty-type-eq-decl nil integers nil)
    (radix formal-const-decl "above(1)" nasalib_float_instantiation
     nil)
    (FloatingPointNumber type-eq-decl nil nasalib_float_instantiation
     nil)
    (Fcanonic? const-decl "bool" float "float/")
    (float type-eq-decl nil float "float/")
    (b formal-const-decl "Format" nasalib_float_instantiation nil)
    (Format type-eq-decl nil float "float/")
    (nat nonempty-type-eq-decl nil naturalnumbers nil))
   nil))
 (IMP_linear_ineq_zero_beta_TCC2 0
  (IMP_linear_ineq_zero_beta_TCC2-1 nil 3756755128
   ("" (skeep :preds? t)
    (("" (use "FltCorrect")
      (("" (assert)
        (("" (expand "lt_fp")
          (("" (assert)
            (("" (replace -1 :hide? t) (("" (propax) nil nil)) nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((FltCorrect formula-decl nil float "float/")
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (> const-decl "bool" reals nil)
    (above nonempty-type-eq-decl nil integers nil)
    (radix formal-const-decl "above(1)" nasalib_float_instantiation
     nil)
    (FloatingPointNumber type-eq-decl nil nasalib_float_instantiation
     nil)
    (b formal-const-decl "Format" nasalib_float_instantiation nil)
    (Fcanonic? const-decl "bool" float "float/")
    (Format type-eq-decl nil float "float/")
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (float type-eq-decl nil float "float/")
    (lt_fp const-decl "(strict_total_order?[FloatingPointNumber])"
     nasalib_float_instantiation nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil))
   nil))
 (IMP_linear_ineq_zero_beta_TCC3 0
  (IMP_linear_ineq_zero_beta_TCC3-1 nil 3756755128
   ("" (assuming-tcc) nil nil)
   ((radix formal-const-decl "above(1)" nasalib_float_instantiation
     nil)
    (above nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (float_pair const-decl "float" float "float/")
    (zero_fp const-decl "FloatingPointNumber"
     nasalib_float_instantiation nil)
    (FtoR const-decl "real" float "float/")
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (nnrat_exp application-judgement "nnrat" exponentiation nil)
    (nnrat_times_nnrat_is_nnrat application-judgement "nonneg_rat"
     rationals nil)
    (minus_int_is_int application-judgement "int" integers nil)
    (mult_divides1 application-judgement "(divides(n))" divides nil)
    (mult_divides2 application-judgement "(divides(m))" divides nil))
   nil))
 (IMP_linear_ineq_zero_beta_TCC4 0
  (IMP_linear_ineq_zero_beta_TCC4-1 nil 3756755128
   ("" (assuming-tcc) nil nil)
   ((radix formal-const-decl "above(1)" nasalib_float_instantiation
     nil)
    (above nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (Fopp const-decl "float" float "float/")
    (FtoR const-decl "real" float "float/")
    (rat_times_rat_is_rat application-judgement "rat" rationals nil)
    (posrat_exp application-judgement "posrat" exponentiation nil)
    (nnrat_exp application-judgement "nnrat" exponentiation nil)
    (minus_int_is_int application-judgement "int" integers nil)
    (mult_divides1 application-judgement "(divides(n))" divides nil)
    (mult_divides2 application-judgement "(divides(m))" divides nil))
   nil))
 (IMP_linear_ineq_zero_beta_TCC5 0
  (IMP_linear_ineq_zero_beta_TCC5-1 nil 3756755128
   ("" (assuming-tcc) nil nil)
   ((radix formal-const-decl "above(1)" nasalib_float_instantiation
     nil)
    (above nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (float_pair const-decl "float" float "float/")
    (zero_fp const-decl "FloatingPointNumber"
     nasalib_float_instantiation nil)
    (Fopp const-decl "float" float "float/")
    (minus_int_is_int application-judgement "int" integers nil)
    (mult_divides1 application-judgement "(divides(n))" divides nil)
    (mult_divides2 application-judgement "(divides(m))" divides nil))
   nil))
 (IMP_linear_ineq_zero_beta_TCC6 0
  (IMP_linear_ineq_zero_beta_TCC6-1 nil 3756755128
   ("" (assuming-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (minus_odd_is_odd application-judgement "odd_int" integers nil)
    (real_minus_real_is_real application-judgement "real" reals nil))
   nil))
 (IMP_linear_ineq_zero_beta_TCC7 0
  (IMP_linear_ineq_zero_beta_TCC7-1 nil 3756755128
   ("" (skeep :preds? t)
    (("" (grind)
      (("" (expand "le_r")
        (("" (expand "le") (("" (grind) nil nil)) nil)) nil))
      nil))
    nil)
   ((real_minus_real_is_real application-judgement "real" reals nil)
    (le const-decl "bool" le "orders/")
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (le_r const-decl "bool" le_r nil))
   nil))
 (IMP_linear_ineq_zero_beta_TCC8 0
  (IMP_linear_ineq_zero_beta_TCC8-1 nil 3756755128
   ("" (le-tcc) nil nil)
   ((le const-decl "bool" le "orders/")
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (minus_real_is_real application-judgement "real" reals nil)
    (le_r const-decl "bool" le_r nil))
   nil))
 (IMP_linear_ineq_zero_beta_TCC9 0
  (IMP_linear_ineq_zero_beta_TCC9-1 nil 3756755128
   ("" (skeep :preds? t)
    (("" (expand "le_r")
      (("" (expand "le") (("" (grind) nil nil)) nil)) nil))
    nil)
   ((le_r const-decl "bool" le_r nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (le const-decl "bool" le "orders/"))
   shostak))
 (IMP_linear_ineq_zero_beta_TCC10 0
  (IMP_linear_ineq_zero_beta_TCC10-1 nil 3756755128
   ("" (assuming-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_minus_real_is_real application-judgement "real" reals nil))
   nil))
 (IMP_linear_ineq_zero_beta_TCC11 0
  (IMP_linear_ineq_zero_beta_TCC11-1 nil 3756755128
   ("" (assuming-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_minus_real_is_real application-judgement "real" reals nil))
   nil))
 (IMP_linear_ineq_zero_beta_TCC12 0
  (IMP_linear_ineq_zero_beta_TCC12-1 nil 3756755128
   ("" (assuming-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil))
   nil))
 (IMP_linear_ineq_zero_beta_TCC13 0
  (IMP_linear_ineq_zero_beta_TCC13-1 nil 3756755128
   ("" (assuming-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (minus_real_is_real application-judgement "real" reals nil)
    (real_minus_real_is_real application-judgement "real" reals nil))
   nil))
 (IMP_linear_ineq_zero_beta_TCC14 0
  (IMP_linear_ineq_zero_beta_TCC14-1 nil 3756755128
   ("" (assuming-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (minus_real_is_real application-judgement "real" reals nil)
    (real_minus_real_is_real application-judgement "real" reals nil))
   nil))
 (IMP_linear_ineq_zero_beta_TCC15 0
  (IMP_linear_ineq_zero_beta_TCC15-1 nil 3756755128
   ("" (assuming-tcc) nil nil)
   ((real_minus_real_is_real application-judgement "real" reals nil))
   nil))
 (IMP_linear_ineq_zero_beta_TCC16 0
  (IMP_linear_ineq_zero_beta_TCC16-1 nil 3756755128
   ("" (assuming-tcc) nil nil) nil nil))
 (IMP_linear_ineq_zero_beta_TCC17 0
  (IMP_linear_ineq_zero_beta_TCC17-1 nil 3756755128
   ("" (skeep :preds? t)
    (("" (expand "le_r")
      (("" (expand "le") (("" (grind) nil nil)) nil)) nil))
    nil)
   ((le_r const-decl "bool" le_r nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs
         nil)
    (le const-decl "bool" le "orders/"))
   shostak))
 (IMP_linear_ineq_zero_beta_TCC18 0
  (IMP_linear_ineq_zero_beta_TCC18-1 nil 3756755128
   ("" (assuming-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs
         nil)
    (int_abs_is_nonneg application-judgement "{j: nonneg_int | j >= i}"
     real_defs nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil))
   nil))
 (IMP_linear_ineq_zero_beta_TCC19 0
  (IMP_linear_ineq_zero_beta_TCC19-1 nil 3756755128 ("" (tcc$))
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs
         nil))
   nil))
 (IMP_linear_ineq_zero_beta_TCC20 0
  (IMP_linear_ineq_zero_beta_TCC20-1 nil 3756755128
   ("" (skeep :preds? t)
    (("" (expand "le_r")
      (("" (expand "le") (("" (grind) nil nil)) nil)) nil))
    nil)
   ((le_r const-decl "bool" le_r nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs
         nil)
    (le const-decl "bool" le "orders/"))
   shostak))
 (IMP_linear_ineq_zero_beta_TCC21 0
  (IMP_linear_ineq_zero_beta_TCC21-1 nil 3756755128
   ("" (assuming-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (minus_real_is_real application-judgement "real" reals nil))
   nil))
 (IMP_linear_ineq_zero_beta_TCC22 0
  (IMP_linear_ineq_zero_beta_TCC22-1 nil 3756755128
   ("" (assuming-tcc) nil nil)
   ((minus_real_is_real application-judgement "real" reals nil)) nil))
 (IMP_linear_ineq_zero_beta_TCC23 0
  (IMP_linear_ineq_zero_beta_TCC23-1 nil 3756755128
   ("" (skeep :preds? t)
    (("" (expand "le_r")
      (("" (expand "le") (("" (grind) nil nil)) nil)) nil))
    nil)
   ((le_r const-decl "bool" le_r nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (minus_real_is_real application-judgement "real" reals nil)
    (le const-decl "bool" le "orders/"))
   shostak))
 (IMP_two_level_expressions_TCC1 0
  (IMP_two_level_expressions_TCC1-1 nil 3757177407
   ("" (inst 1 "add")
    (("" (expand "operatorUnderAnalysis?") (("" (propax) nil nil))
      nil))
    nil)
   ((operatorUnderAnalysis? const-decl "bool"
     nasalib_float_instantiation nil)
    (add adt-constructor-decl "(add?)" nasalib_float_instantiation nil)
    (add? adt-recognizer-decl "[Operator -> boolean]"
     nasalib_float_instantiation nil)
    (boolean nonempty-type-decl nil booleans nil)
    (Operator type-decl nil nasalib_float_instantiation nil))
   nil))
 (aerrByOp_TCC1 0
  (aerrByOp_TCC1-1 nil 3757161980
   ("" (skeep :preds? t)
    (("" (expand "operatorUnderAnalysis?") (("" (assert) nil nil))
      nil))
    nil)
   ((operatorUnderAnalysis? const-decl "bool"
     nasalib_float_instantiation nil))
   nil))
 (addErrExpr_TCC1 0
  (addErrExpr_TCC1-1 nil 3757196735 ("" (subtype-tcc) nil nil)
   ((operatorUnderAnalysis? const-decl "bool"
     nasalib_float_instantiation nil))
   nil))
 (addErrExpr_j 0
  (addErrExpr_j-1 nil 3757196735
   ("" (skeep* :preds? t)
    (("" (expand "addErrExpr")
      (("" (expand "aerrByOp")
        (("" (assert)
          ((""
            (case "EXISTS (op: Operator): operatorUnderAnalysis?(op)")
            (("1" (rewrite "evaluable_in_raexpr_def_op")
              (("1" (split 1)
                (("1" (rewrite "evaluable_in_raexpr_def_op") nil nil)
                 ("2" (rewrite "evaluable_in_raexpr_def_op")
                  (("2" (split 1)
                    (("1" (rewrite "evaluable_in_raexpr_def_op")
                      (("1" (split 1)
                        (("1"
                          (use "evaluable_rLocalEnv_evaluable_iRToAR_env")
                          (("1" (assert) nil nil)) nil)
                         ("2"
                          (use "evaluable_rLocalEnv_evaluable_iRToAR_env")
                          (("2" (assert) nil nil)) nil))
                        nil))
                      nil)
                     ("2" (rewrite "evaluable_in_raexpr_def_op") nil
                      nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (inst 1 "add")
              (("2" (expand "operatorUnderAnalysis?")
                (("2" (propax) nil nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((addErrExpr const-decl "ARExpr" nasalib_float_instantiation nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (evaluable_in_raexpr_def_op formula-decl nil expressions_semantics
     nil)
    (RAExpr type-decl nil expressions nil)
    (RVariable? adt-recognizer-decl "[RAExpr -> boolean]" expressions
     nil)
    (>= const-decl "bool" reals nil)
    (rVarIndex const-decl "nat" expressions_semantics nil)
    (strict_well_founded? const-decl "bool" orders nil)
    (<< adt-def-decl "(strict_well_founded?[RAExpr])" expressions nil)
    (LocalEnvironment nonempty-type-decl nil u_local_environment nil)
    (RLocalEnvironment type-eq-decl nil expressions_semantics nil)
    (RealNumber type-eq-decl nil nasalib_float_instantiation nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (size const-decl "nat" u_local_environment nil)
    (iRToAR_env def-decl
     "{arLocalEnv: analysis_esem_th.RLocalEnvironment |
         size(rLocalEnv) = size(arLocalEnv)}" two_level_expressions
     nil)
    (IRLocalEnv type-eq-decl nil two_level_expressions nil)
    (ROperator? adt-recognizer-decl "[RAExpr -> boolean]" expressions
     nil)
    (ROperator adt-constructor-decl
     "[[Operator, RAExpr, RAExpr] -> (ROperator?)]" expressions nil)
    (add? adt-recognizer-decl "[Operator -> boolean]"
     nasalib_float_instantiation nil)
    (add adt-constructor-decl "(add?)" nasalib_float_instantiation nil)
    (ARExpr type-eq-decl nil two_level_expressions nil)
    (AbsAdd? adt-recognizer-decl "[Operator -> boolean]"
     nasalib_float_instantiation nil)
    (AbsAdd adt-constructor-decl "(AbsAdd?)"
     nasalib_float_instantiation nil)
    (iRToAR def-decl "analysis_expr_th.RAExpr" two_level_expressions
     nil)
    (IRExpr type-eq-decl nil two_level_expressions nil)
    (AddUlp2? adt-recognizer-decl "[Operator -> boolean]"
     nasalib_float_instantiation nil)
    (AddUlp2 adt-constructor-decl "(AddUlp2?)"
     nasalib_float_instantiation nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (applyFun_r const-decl "real" nasalib_float_instantiation nil)
    (int nonempty-type-eq-decl nil integers nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (> const-decl "bool" reals nil)
    (above nonempty-type-eq-decl nil integers nil)
    (radix formal-const-decl "above(1)" nasalib_float_instantiation
     nil)
    (float type-eq-decl nil float "float/")
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (Format type-eq-decl nil float "float/")
    (Fcanonic? const-decl "bool" float "float/")
    (b formal-const-decl "Format" nasalib_float_instantiation nil)
    (FloatingPointNumber type-eq-decl nil nasalib_float_instantiation
     nil)
    (pred type-eq-decl nil defined_types nil)
    (strict_total_order? const-decl "bool" orders nil)
    (lt_fp const-decl "(strict_total_order?[FloatingPointNumber])"
     nasalib_float_instantiation nil)
    (applyFun_fp const-decl "FloatingPointNumber"
     nasalib_float_instantiation nil)
    (restrict const-decl "R" restrict nil)
    (FtoR const-decl "real" float "float/")
    (evaluable_rLocalEnv_evaluable_iRToAR_env formula-decl nil
     two_level_expressions nil)
    (operatorUnderAnalysis? const-decl "bool"
     nasalib_float_instantiation nil)
    (Operator type-decl nil nasalib_float_instantiation nil)
    (aerrByOp const-decl "ARExpr" nasalib_float_instantiation nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil))
 (addErrVal_TCC1 0
  (addErrVal_TCC1-1 nil 3757196735
   ("" (skeep* :preds? t)
    (("" (use "input_esem_th.evaluable_in_expr_FtoR")
      (("" (assert) nil nil)) nil))
    nil)
   ((evaluable_in_expr_FtoR formula-decl nil expressions_semantics nil)
    (Operator type-decl nil nasalib_float_instantiation nil)
    (operatorUnderAnalysis? const-decl "bool"
     nasalib_float_instantiation nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (RealNumber type-eq-decl nil nasalib_float_instantiation nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (restrict const-decl "R" restrict nil)
    (applyFun_r const-decl "real" nasalib_float_instantiation nil)
    (int nonempty-type-eq-decl nil integers nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (> const-decl "bool" reals nil)
    (above nonempty-type-eq-decl nil integers nil)
    (radix formal-const-decl "above(1)" nasalib_float_instantiation
     nil)
    (float type-eq-decl nil float "float/")
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (Format type-eq-decl nil float "float/")
    (Fcanonic? const-decl "bool" float "float/")
    (b formal-const-decl "Format" nasalib_float_instantiation nil)
    (FloatingPointNumber type-eq-decl nil nasalib_float_instantiation
     nil)
    (pred type-eq-decl nil defined_types nil)
    (strict_total_order? const-decl "bool" orders nil)
    (lt_fp const-decl "(strict_total_order?[FloatingPointNumber])"
     nasalib_float_instantiation nil)
    (applyFun_fp const-decl "FloatingPointNumber"
     nasalib_float_instantiation nil)
    (FtoR const-decl "real" float "float/")
    (bounded_by? const-decl "bool" u_local_environment nil)
    (IFExpr type-eq-decl nil two_level_expressions nil)
    (FtoR def-decl "RAExpr" expressions nil)
    (get const-decl "T" u_local_environment nil)
    (below type-eq-decl nil naturalnumbers nil)
    (IFPLocalEnv type-eq-decl nil two_level_expressions nil)
    (size const-decl "nat" u_local_environment nil)
    (<< adt-def-decl "(strict_well_founded?[FPAExpr])" expressions nil)
    (fpVarIndex const-decl "nat" expressions_semantics nil)
    (FPVariable? adt-recognizer-decl "[FPAExpr -> boolean]" expressions
     nil)
    (FPAExpr type-decl nil expressions nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (RLocalEnvironment type-eq-decl nil expressions_semantics nil)
    (LocalEnvironment nonempty-type-decl nil u_local_environment nil)
    (<< adt-def-decl "(strict_well_founded?[RAExpr])" expressions nil)
    (strict_well_founded? const-decl "bool" orders nil)
    (rVarIndex const-decl "nat" expressions_semantics nil)
    (>= const-decl "bool" reals nil)
    (RVariable? adt-recognizer-decl "[RAExpr -> boolean]" expressions
     nil)
    (RAExpr type-decl nil expressions nil)
    (FPLocalEnvironment type-eq-decl nil expressions_semantics nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil))
 (addErrVal_TCC2 0
  (addErrVal_TCC2-1 nil 3757419753 ("" (subtype-tcc) nil nil)
   ((NOT const-decl "[bool -> bool]" booleans nil)
    (LocalEnvironment nonempty-type-decl nil u_local_environment nil)
    (RLocalEnvironment type-eq-decl nil expressions_semantics nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (size const-decl "nat" u_local_environment nil)
    (iRToAR_env def-decl
     "{arLocalEnv: analysis_esem_th.RLocalEnvironment |
         size(rLocalEnv) = size(arLocalEnv)}" two_level_expressions
     nil)
    (FPAExpr type-decl nil expressions nil)
    (FPVariable? adt-recognizer-decl "[FPAExpr -> boolean]" expressions
     nil)
    (fpVarIndex const-decl "nat" expressions_semantics nil)
    (<< adt-def-decl "(strict_well_founded?[FPAExpr])" expressions nil)
    (FPLocalEnvironment type-eq-decl nil expressions_semantics nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (below type-eq-decl nil naturalnumbers nil)
    (get const-decl "T" u_local_environment nil)
    (FtoR def-decl "RAExpr" expressions nil)
    (IFPLocalEnv type-eq-decl nil two_level_expressions nil)
    (ARExpr type-eq-decl nil two_level_expressions nil)
    (ParameterIndex nonempty-type-eq-decl nil expressions nil)
    (RNumber nonempty-type-eq-decl nil expressions nil)
    (REnvironment nonempty-type-eq-decl nil expressions_semantics nil)
    (FPNumber nonempty-type-eq-decl nil expressions nil)
    (IFPEnvironment type-eq-decl nil two_level_expressions nil)
    (InducedREnv nonempty-type-eq-decl nil expressions_semantics nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posrat_exp application-judgement "posrat" exponentiation nil)
    (nnrat_exp application-judgement "nnrat" exponentiation nil)
    (FtoR const-decl "real" float "float/")
    (applyFun_fp const-decl "FloatingPointNumber"
     nasalib_float_instantiation nil)
    (lt_fp const-decl "(strict_total_order?[FloatingPointNumber])"
     nasalib_float_instantiation nil)
    (strict_total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (FloatingPointNumber type-eq-decl nil nasalib_float_instantiation
     nil)
    (b formal-const-decl "Format" nasalib_float_instantiation nil)
    (Fcanonic? const-decl "bool" float "float/")
    (Format type-eq-decl nil float "float/")
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (float type-eq-decl nil float "float/")
    (radix formal-const-decl "above(1)" nasalib_float_instantiation
     nil)
    (above nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (applyFun_r const-decl "real" nasalib_float_instantiation nil)
    (restrict const-decl "R" restrict nil)
    (< const-decl "bool" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (RealNumber type-eq-decl nil nasalib_float_instantiation nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (operatorUnderAnalysis? const-decl "bool"
     nasalib_float_instantiation nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (Operator type-decl nil nasalib_float_instantiation nil)
    (FtoR const-decl "{rle: RLocalEnvironment |
         size(fle) = size(rle) AND
          (FORALL (i: below(size(rle))): get(rle)(i) = FtoR(get(fle)(i)))}"
     expressions_semantics nil)
    (rVarIndex const-decl "nat" expressions_semantics nil)
    (<< adt-def-decl "(strict_well_founded?[RAExpr])" expressions nil)
    (strict_well_founded? const-decl "bool" orders nil)
    (>= const-decl "bool" reals nil)
    (RVariable? adt-recognizer-decl "[RAExpr -> boolean]" expressions
     nil)
    (RAExpr type-decl nil expressions nil)
    (bounded_by? const-decl "bool" u_local_environment nil)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (mult_divides1 application-judgement "(divides(n))" divides nil)
    (mult_divides2 application-judgement "(divides(m))" divides nil))
   nil))
 (addErrVal_TCC3 0
  (addErrVal_TCC3-1 nil 3757419753
   ("" (skeep* :preds? t)
    (("" (use "input_esem_th.evaluable_in_expr_FtoR")
      (("" (assert) nil nil)) nil))
    nil)
   ((evaluable_in_expr_FtoR formula-decl nil expressions_semantics nil)
    (Operator type-decl nil nasalib_float_instantiation nil)
    (operatorUnderAnalysis? const-decl "bool"
     nasalib_float_instantiation nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (RealNumber type-eq-decl nil nasalib_float_instantiation nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (restrict const-decl "R" restrict nil)
    (applyFun_r const-decl "real" nasalib_float_instantiation nil)
    (int nonempty-type-eq-decl nil integers nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (> const-decl "bool" reals nil)
    (above nonempty-type-eq-decl nil integers nil)
    (radix formal-const-decl "above(1)" nasalib_float_instantiation
     nil)
    (float type-eq-decl nil float "float/")
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (Format type-eq-decl nil float "float/")
    (Fcanonic? const-decl "bool" float "float/")
    (b formal-const-decl "Format" nasalib_float_instantiation nil)
    (FloatingPointNumber type-eq-decl nil nasalib_float_instantiation
     nil)
    (pred type-eq-decl nil defined_types nil)
    (strict_total_order? const-decl "bool" orders nil)
    (lt_fp const-decl "(strict_total_order?[FloatingPointNumber])"
     nasalib_float_instantiation nil)
    (applyFun_fp const-decl "FloatingPointNumber"
     nasalib_float_instantiation nil)
    (FtoR const-decl "real" float "float/")
    (bounded_by? const-decl "bool" u_local_environment nil)
    (IFExpr type-eq-decl nil two_level_expressions nil)
    (FtoR def-decl "RAExpr" expressions nil)
    (get const-decl "T" u_local_environment nil)
    (below type-eq-decl nil naturalnumbers nil)
    (IFPLocalEnv type-eq-decl nil two_level_expressions nil)
    (size const-decl "nat" u_local_environment nil)
    (<< adt-def-decl "(strict_well_founded?[FPAExpr])" expressions nil)
    (fpVarIndex const-decl "nat" expressions_semantics nil)
    (FPVariable? adt-recognizer-decl "[FPAExpr -> boolean]" expressions
     nil)
    (FPAExpr type-decl nil expressions nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (RLocalEnvironment type-eq-decl nil expressions_semantics nil)
    (LocalEnvironment nonempty-type-decl nil u_local_environment nil)
    (<< adt-def-decl "(strict_well_founded?[RAExpr])" expressions nil)
    (strict_well_founded? const-decl "bool" orders nil)
    (rVarIndex const-decl "nat" expressions_semantics nil)
    (>= const-decl "bool" reals nil)
    (RVariable? adt-recognizer-decl "[RAExpr -> boolean]" expressions
     nil)
    (RAExpr type-decl nil expressions nil)
    (FPLocalEnvironment type-eq-decl nil expressions_semantics nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil)
    (real_minus_real_is_real application-judgement "real" reals nil))
   nil))
 (addErrVal_TCC4 0
  (addErrVal_TCC4-1 nil 3757419753 ("" (subtype-tcc) nil nil)
   ((NOT const-decl "[bool -> bool]" booleans nil)
    (LocalEnvironment nonempty-type-decl nil u_local_environment nil)
    (RLocalEnvironment type-eq-decl nil expressions_semantics nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (size const-decl "nat" u_local_environment nil)
    (iRToAR_env def-decl
     "{arLocalEnv: analysis_esem_th.RLocalEnvironment |
         size(rLocalEnv) = size(arLocalEnv)}" two_level_expressions
     nil)
    (FPAExpr type-decl nil expressions nil)
    (FPVariable? adt-recognizer-decl "[FPAExpr -> boolean]" expressions
     nil)
    (fpVarIndex const-decl "nat" expressions_semantics nil)
    (<< adt-def-decl "(strict_well_founded?[FPAExpr])" expressions nil)
    (FPLocalEnvironment type-eq-decl nil expressions_semantics nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (below type-eq-decl nil naturalnumbers nil)
    (get const-decl "T" u_local_environment nil)
    (FtoR def-decl "RAExpr" expressions nil)
    (IFPLocalEnv type-eq-decl nil two_level_expressions nil)
    (ARExpr type-eq-decl nil two_level_expressions nil)
    (IFExpr type-eq-decl nil two_level_expressions nil)
    (ParameterIndex nonempty-type-eq-decl nil expressions nil)
    (RNumber nonempty-type-eq-decl nil expressions nil)
    (REnvironment nonempty-type-eq-decl nil expressions_semantics nil)
    (FPNumber nonempty-type-eq-decl nil expressions nil)
    (IFPEnvironment type-eq-decl nil two_level_expressions nil)
    (InducedREnv nonempty-type-eq-decl nil expressions_semantics nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (ifpLocalEnv!1 skolem-const-decl "IFPLocalEnv
    [Operator, (operatorUnderAnalysis?), RealNumber, <, applyFun_r,
     FloatingPointNumber, lt_fp, applyFun_fp,
     restrict[float[radix], FloatingPointNumber, real](FtoR)]"
     nasalib_float_instantiation nil)
    (are2!1 skolem-const-decl
     "{are2 | bounded_by?(iRToAR_env(FtoR(ifpLocalEnv!1)))(are2)}"
     nasalib_float_instantiation nil)
    (v!1 skolem-const-decl
     "{v: (RVariable?) | v = are2!1 OR v << are2!1}"
     nasalib_float_instantiation nil)
    (are1!1 skolem-const-decl
     "{are1 | bounded_by?(iRToAR_env(FtoR(ifpLocalEnv!1)))(are1)}"
     nasalib_float_instantiation nil)
    (FtoR const-decl "real" float "float/")
    (applyFun_fp const-decl "FloatingPointNumber"
     nasalib_float_instantiation nil)
    (lt_fp const-decl "(strict_total_order?[FloatingPointNumber])"
     nasalib_float_instantiation nil)
    (strict_total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (FloatingPointNumber type-eq-decl nil nasalib_float_instantiation
     nil)
    (b formal-const-decl "Format" nasalib_float_instantiation nil)
    (Fcanonic? const-decl "bool" float "float/")
    (Format type-eq-decl nil float "float/")
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (float type-eq-decl nil float "float/")
    (radix formal-const-decl "above(1)" nasalib_float_instantiation
     nil)
    (above nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (applyFun_r const-decl "real" nasalib_float_instantiation nil)
    (restrict const-decl "R" restrict nil)
    (< const-decl "bool" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (RealNumber type-eq-decl nil nasalib_float_instantiation nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (operatorUnderAnalysis? const-decl "bool"
     nasalib_float_instantiation nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (Operator type-decl nil nasalib_float_instantiation nil)
    (FtoR const-decl "{rle: RLocalEnvironment |
         size(fle) = size(rle) AND
          (FORALL (i: below(size(rle))): get(rle)(i) = FtoR(get(fle)(i)))}"
     expressions_semantics nil)
    (le const-decl "bool" le "orders/")
    (le_r const-decl "bool" le_r nil)
    (rVarIndex const-decl "nat" expressions_semantics nil)
    (<< adt-def-decl "(strict_well_founded?[RAExpr])" expressions nil)
    (strict_well_founded? const-decl "bool" orders nil)
    (>= const-decl "bool" reals nil)
    (RVariable? adt-recognizer-decl "[RAExpr -> boolean]" expressions
     nil)
    (RAExpr type-decl nil expressions nil)
    (bounded_by? const-decl "bool" u_local_environment nil)
    (nnrat_exp application-judgement "nnrat" exponentiation nil)
    (posrat_exp application-judgement "posrat" exponentiation nil)
    (rat_times_rat_is_rat application-judgement "rat" rationals nil)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (mult_divides1 application-judgement "(divides(n))" divides nil)
    (mult_divides2 application-judgement "(divides(m))" divides nil))
   nil))
 (addErrVal_TCC5 0
  (addErrVal_TCC5-1 nil 3757419753
   ("" (skeep* :preds? t)
    (("" (use "input_esem_th.evaluable_in_fpaexpr_def_op")
      (("" (assert) nil nil)) nil))
    nil)
   ((evaluable_in_fpaexpr_def_op formula-decl nil expressions_semantics
     nil)
    (Operator type-decl nil nasalib_float_instantiation nil)
    (operatorUnderAnalysis? const-decl "bool"
     nasalib_float_instantiation nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (RealNumber type-eq-decl nil nasalib_float_instantiation nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (restrict const-decl "R" restrict nil)
    (applyFun_r const-decl "real" nasalib_float_instantiation nil)
    (int nonempty-type-eq-decl nil integers nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (> const-decl "bool" reals nil)
    (above nonempty-type-eq-decl nil integers nil)
    (radix formal-const-decl "above(1)" nasalib_float_instantiation
     nil)
    (float type-eq-decl nil float "float/")
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (Format type-eq-decl nil float "float/")
    (Fcanonic? const-decl "bool" float "float/")
    (b formal-const-decl "Format" nasalib_float_instantiation nil)
    (FloatingPointNumber type-eq-decl nil nasalib_float_instantiation
     nil)
    (pred type-eq-decl nil defined_types nil)
    (strict_total_order? const-decl "bool" orders nil)
    (lt_fp const-decl "(strict_total_order?[FloatingPointNumber])"
     nasalib_float_instantiation nil)
    (applyFun_fp const-decl "FloatingPointNumber"
     nasalib_float_instantiation nil)
    (FtoR const-decl "real" float "float/")
    (add adt-constructor-decl "(add?)" nasalib_float_instantiation nil)
    (add? adt-recognizer-decl "[Operator -> boolean]"
     nasalib_float_instantiation nil)
    (bounded_by? const-decl "bool" u_local_environment nil)
    (IFExpr type-eq-decl nil two_level_expressions nil)
    (IFPLocalEnv type-eq-decl nil two_level_expressions nil)
    (FPLocalEnvironment type-eq-decl nil expressions_semantics nil)
    (LocalEnvironment nonempty-type-decl nil u_local_environment nil)
    (<< adt-def-decl "(strict_well_founded?[FPAExpr])" expressions nil)
    (strict_well_founded? const-decl "bool" orders nil)
    (fpVarIndex const-decl "nat" expressions_semantics nil)
    (>= const-decl "bool" reals nil)
    (FPVariable? adt-recognizer-decl "[FPAExpr -> boolean]" expressions
     nil)
    (FPAExpr type-decl nil expressions nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil)
    (real_minus_real_is_real application-judgement "real" reals nil))
   nil))
 (addErrVal_TCC6 0
  (addErrVal_TCC6-1 nil 3757419753
   ("" (skeep* :preds? t)
    (("" (use "input_esem_th.evaluable_in_expr_FtoR")
      (("" (assert)
        (("" (use "input_esem_th.evaluable_in_fpaexpr_def_op")
          (("" (assert) nil nil)) nil))
        nil))
      nil))
    nil)
   ((evaluable_in_expr_FtoR formula-decl nil expressions_semantics nil)
    (Operator type-decl nil nasalib_float_instantiation nil)
    (operatorUnderAnalysis? const-decl "bool"
     nasalib_float_instantiation nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (RealNumber type-eq-decl nil nasalib_float_instantiation nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (restrict const-decl "R" restrict nil)
    (applyFun_r const-decl "real" nasalib_float_instantiation nil)
    (int nonempty-type-eq-decl nil integers nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (> const-decl "bool" reals nil)
    (above nonempty-type-eq-decl nil integers nil)
    (radix formal-const-decl "above(1)" nasalib_float_instantiation
     nil)
    (float type-eq-decl nil float "float/")
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (Format type-eq-decl nil float "float/")
    (Fcanonic? const-decl "bool" float "float/")
    (b formal-const-decl "Format" nasalib_float_instantiation nil)
    (FloatingPointNumber type-eq-decl nil nasalib_float_instantiation
     nil)
    (pred type-eq-decl nil defined_types nil)
    (strict_total_order? const-decl "bool" orders nil)
    (lt_fp const-decl "(strict_total_order?[FloatingPointNumber])"
     nasalib_float_instantiation nil)
    (applyFun_fp const-decl "FloatingPointNumber"
     nasalib_float_instantiation nil)
    (FtoR const-decl "real" float "float/")
    (bounded_by? const-decl "bool" u_local_environment nil)
    (IFExpr type-eq-decl nil two_level_expressions nil)
    (add adt-constructor-decl "(add?)" nasalib_float_instantiation nil)
    (add? adt-recognizer-decl "[Operator -> boolean]"
     nasalib_float_instantiation nil)
    (FPOperator adt-constructor-decl
     "[[Operator, FPAExpr, FPAExpr] -> (FPOperator?)]" expressions nil)
    (FPOperator? adt-recognizer-decl "[FPAExpr -> boolean]" expressions
     nil)
    (FtoR def-decl "RAExpr" expressions nil)
    (get const-decl "T" u_local_environment nil)
    (below type-eq-decl nil naturalnumbers nil)
    (IFPLocalEnv type-eq-decl nil two_level_expressions nil)
    (size const-decl "nat" u_local_environment nil)
    (<< adt-def-decl "(strict_well_founded?[FPAExpr])" expressions nil)
    (fpVarIndex const-decl "nat" expressions_semantics nil)
    (FPVariable? adt-recognizer-decl "[FPAExpr -> boolean]" expressions
     nil)
    (FPAExpr type-decl nil expressions nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (RLocalEnvironment type-eq-decl nil expressions_semantics nil)
    (LocalEnvironment nonempty-type-decl nil u_local_environment nil)
    (<< adt-def-decl "(strict_well_founded?[RAExpr])" expressions nil)
    (strict_well_founded? const-decl "bool" orders nil)
    (rVarIndex const-decl "nat" expressions_semantics nil)
    (>= const-decl "bool" reals nil)
    (RVariable? adt-recognizer-decl "[RAExpr -> boolean]" expressions
     nil)
    (RAExpr type-decl nil expressions nil)
    (FPLocalEnvironment type-eq-decl nil expressions_semantics nil)
    (evaluable_in_fpaexpr_def_op formula-decl nil expressions_semantics
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil)
    (real_minus_real_is_real application-judgement "real" reals nil))
   nil))
 (addErrVal_TCC7 0
  (addErrVal_TCC7-1 nil 3757419753
   ("" (skeep* :preds? t)
    (("" (with-tccs (use "addErrExpr_j"))
      (("" (assert)
        (("" (hide 2)
          (("" (split 1)
            (("1" (use "input_esem_th.evaluable_in_expr_FtoR")
              (("1" (assert) nil nil)) nil)
             ("2" (use "input_esem_th.evaluable_in_expr_FtoR")
              (("2" (assert) nil nil)) nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (bijective? const-decl "bool" functions nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (operatorUnderAnalysis? const-decl "bool"
     nasalib_float_instantiation nil)
    (Operator type-decl nil nasalib_float_instantiation nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (RealNumber type-eq-decl nil nasalib_float_instantiation nil)
    (int nonempty-type-eq-decl nil integers nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (> const-decl "bool" reals nil)
    (above nonempty-type-eq-decl nil integers nil)
    (radix formal-const-decl "above(1)" nasalib_float_instantiation
     nil)
    (float type-eq-decl nil float "float/")
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (Format type-eq-decl nil float "float/")
    (Fcanonic? const-decl "bool" float "float/")
    (b formal-const-decl "Format" nasalib_float_instantiation nil)
    (FloatingPointNumber type-eq-decl nil nasalib_float_instantiation
     nil)
    (restrict const-decl "R" restrict nil)
    (FtoR const-decl "real" float "float/")
    (RAExpr type-decl nil expressions nil)
    (< const-decl "bool" reals nil)
    (applyFun_r const-decl "real" nasalib_float_instantiation nil)
    (pred type-eq-decl nil defined_types nil)
    (strict_total_order? const-decl "bool" orders nil)
    (lt_fp const-decl "(strict_total_order?[FloatingPointNumber])"
     nasalib_float_instantiation nil)
    (applyFun_fp const-decl "FloatingPointNumber"
     nasalib_float_instantiation nil)
    (ARExpr type-eq-decl nil two_level_expressions nil)
    (RVariable? adt-recognizer-decl "[RAExpr -> boolean]" expressions
     nil)
    (>= const-decl "bool" reals nil)
    (rVarIndex const-decl "nat" expressions_semantics nil)
    (strict_well_founded? const-decl "bool" orders nil)
    (<< adt-def-decl "(strict_well_founded?[RAExpr])" expressions nil)
    (LocalEnvironment nonempty-type-decl nil u_local_environment nil)
    (bounded_by? const-decl "bool" u_local_environment nil)
    (RLocalEnvironment type-eq-decl nil expressions_semantics nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (size const-decl "nat" u_local_environment nil)
    (iRToAR_env def-decl
     "{arLocalEnv: analysis_esem_th.RLocalEnvironment |
         size(rLocalEnv) = size(arLocalEnv)}" two_level_expressions
     nil)
    (FPAExpr type-decl nil expressions nil)
    (FPVariable? adt-recognizer-decl "[FPAExpr -> boolean]" expressions
     nil)
    (fpVarIndex const-decl "nat" expressions_semantics nil)
    (<< adt-def-decl "(strict_well_founded?[FPAExpr])" expressions nil)
    (FPLocalEnvironment type-eq-decl nil expressions_semantics nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (below type-eq-decl nil naturalnumbers nil)
    (get const-decl "T" u_local_environment nil)
    (FtoR def-decl "RAExpr" expressions nil)
    (FtoR const-decl "{rle: RLocalEnvironment |
         size(fle) = size(rle) AND
          (FORALL (i: below(size(rle))): get(rle)(i) = FtoR(get(fle)(i)))}"
     expressions_semantics nil)
    (IFPLocalEnv type-eq-decl nil two_level_expressions nil)
    (IRExpr type-eq-decl nil two_level_expressions nil)
    (IFExpr type-eq-decl nil two_level_expressions nil)
    (IRLocalEnv type-eq-decl nil two_level_expressions nil)
    (addErrExpr_j judgement-tcc nil nasalib_float_instantiation nil)
    (evaluable_in_expr_FtoR formula-decl nil expressions_semantics nil)
    (addErrExpr_j application-judgement "{res: ARExpr |
         FORALL (irLocalEnv):
           bounded_by?(irLocalEnv)(ire1) AND
            bounded_by?(iRToAR_env(irLocalEnv))(are1) AND
             bounded_by?(irLocalEnv)(ire2) AND
              bounded_by?(iRToAR_env(irLocalEnv))(are2)
            IMPLIES bounded_by?(iRToAR_env(irLocalEnv))(res)}"
     nasalib_float_instantiation nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil))
 (addErrVal_TCC8 0
  (addErrVal_TCC8-1 nil 3757419753
   ("" (skeep* :preds? t)
    (("" (case "EXISTS (op: Operator): (operatorUnderAnalysis?)(op)")
      (("1" (expand "eval" 1 1)
        (("1" (expand "applyFun_fp")
          (("1" (expand "FtoR" 1 4)
            (("1" (expand "eval" 1 3)
              (("1" (expand "applyFun_r" :assert? none)
                (("1" (lift-if 1)
                  (("1" (split 1)
                    (("1" (expand "addErrExpr")
                      (("1" (expand "aerrByOp")
                        (("1" (assert)
                          (("1" (expand "eval" 1 5)
                            (("1" (expand "applyFun_r")
                              (("1"
                                (expand "eval" 1 5)
                                (("1"
                                  (expand "applyFun_r")
                                  (("1"
                                    (expand "eval" 1 7)
                                    (("1"
                                      (expand "applyFun_r")
                                      (("1"
                                        (expand "eval" 1 7)
                                        (("1"
                                          (expand "applyFun_r")
                                          (("1"
                                            (expand "eval" 1 7)
                                            (("1"
                                              (expand "applyFun_r")
                                              (("1"
                                                (invoke
                                                 (name-replace
                                                  "f1"
                                                  "%1")
                                                 (! -6 1 1 1 1))
                                                (("1"
                                                  (invoke
                                                   (name-replace
                                                    "r1"
                                                    "%1")
                                                   (! -6 1 1 2))
                                                  (("1"
                                                    (invoke
                                                     (name-replace
                                                      "e1"
                                                      "%1")
                                                     (! -6 2))
                                                    (("1"
                                                      (invoke
                                                       (name-replace
                                                        "f2"
                                                        "%1")
                                                       (! -7 1 1 1 1))
                                                      (("1"
                                                        (invoke
                                                         (name-replace
                                                          "r2"
                                                          "%1")
                                                         (! -7 1 1 2))
                                                        (("1"
                                                          (invoke
                                                           (name-replace
                                                            "e2"
                                                            "%1")
                                                           (! -7 2))
                                                          (("1"
                                                            (invoke
                                                             (case
                                                              "%1 = r1 ")
                                                             (!
                                                              1
                                                              2
                                                              3
                                                              1
                                                              1
                                                              3
                                                              1
                                                              1))
                                                            (("1"
                                                              (replace
                                                               -1
                                                               :hide?
                                                               t)
                                                              (("1"
                                                                (invoke
                                                                 (case
                                                                  "%1 = r2 ")
                                                                 (!
                                                                  1
                                                                  2
                                                                  3
                                                                  1
                                                                  1
                                                                  3
                                                                  1
                                                                  2))
                                                                (("1"
                                                                  (replace
                                                                   -1
                                                                   :hide?
                                                                   t)
                                                                  (("1"
                                                                    (case
                                                                     "FORALL(x,y:real): le_r[real, <](x,y) = (x <= y)")
                                                                    (("1"
                                                                      (inst?
                                                                       -1
                                                                       :where
                                                                       1
                                                                       :copy?
                                                                       y)
                                                                      (("1"
                                                                        (replace
                                                                         -2
                                                                         :hide?
                                                                         t)
                                                                        (("1"
                                                                          (inst?
                                                                           -1
                                                                           :where
                                                                           -8
                                                                           :copy?
                                                                           y)
                                                                          (("1"
                                                                            (replace
                                                                             -2
                                                                             :hide?
                                                                             t)
                                                                            (("1"
                                                                              (inst?
                                                                               -1
                                                                               :where
                                                                               -7)
                                                                              (("1"
                                                                                (replace
                                                                                 -1
                                                                                 :hide?
                                                                                 t)
                                                                                (("1"
                                                                                  (lemma
                                                                                   "accum_err_bound")
                                                                                  (("1"
                                                                                    (insteep)
                                                                                    (("1"
                                                                                      (expand
                                                                                       "add_aerr_bound")
                                                                                      (("1"
                                                                                        (expand
                                                                                         "add_ulp_bound")
                                                                                        (("1"
                                                                                          (assert)
                                                                                          nil
                                                                                          nil))
                                                                                        nil))
                                                                                      nil)
                                                                                     ("2"
                                                                                      (grind-reals)
                                                                                      nil
                                                                                      nil)
                                                                                     ("3"
                                                                                      (grind-reals)
                                                                                      nil
                                                                                      nil))
                                                                                    nil))
                                                                                  nil))
                                                                                nil))
                                                                              nil))
                                                                            nil))
                                                                          nil))
                                                                        nil))
                                                                      nil)
                                                                     ("2"
                                                                      (hide-all-but
                                                                       1)
                                                                      (("2"
                                                                        (grind)
                                                                        nil
                                                                        nil))
                                                                      nil))
                                                                    nil))
                                                                  nil)
                                                                 ("2"
                                                                  (hide-all-but
                                                                   1)
                                                                  (("2"
                                                                    (expand
                                                                     "r2")
                                                                    (("2"
                                                                      (use
                                                                       "eval_input_analysis_eq")
                                                                      (("2"
                                                                        (assert)
                                                                        nil
                                                                        nil))
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil)
                                                             ("2"
                                                              (hide-all-but
                                                               1)
                                                              (("2"
                                                                (expand
                                                                 "r1")
                                                                (("2"
                                                                  (rewrite
                                                                   "eval_input_analysis_eq")
                                                                  nil
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil)
                     ("2" (assert) nil nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (hide-all-but 1)
        (("2" (inst 1 "add")
          (("2" (expand "operatorUnderAnalysis?")
            (("2" (propax) nil nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((operatorUnderAnalysis? const-decl "bool"
     nasalib_float_instantiation nil)
    (Operator type-decl nil nasalib_float_instantiation nil)
    (applyFun_fp const-decl "FloatingPointNumber"
     nasalib_float_instantiation nil)
    (eval def-decl "RNumber" expressions_semantics nil)
    (posreal_div_posreal_is_posreal application-judgement "posreal"
     real_types nil)
    (addErrExpr const-decl "ARExpr" nasalib_float_instantiation nil)
    (FtoR const-decl "{rle: RLocalEnvironment |
         size(fle) = size(rle) AND
          (FORALL (i: below(size(rle))): get(rle)(i) = FtoR(get(fle)(i)))}"
     expressions_semantics nil)
    (get const-decl "T" u_local_environment nil)
    (below type-eq-decl nil naturalnumbers nil)
    (size const-decl "nat" u_local_environment nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (FtoR const-decl "InducedREnv(fpEnv)" expressions_semantics nil)
    (InducedREnv nonempty-type-eq-decl nil expressions_semantics nil)
    (RLocalEnvironment type-eq-decl nil expressions_semantics nil)
    (<< adt-def-decl "(strict_well_founded?[RAExpr])" expressions nil)
    (rVarIndex const-decl "nat" expressions_semantics nil)
    (RVariable? adt-recognizer-decl "[RAExpr -> boolean]" expressions
     nil)
    (RAExpr type-decl nil expressions nil)
    (REnvironment nonempty-type-eq-decl nil expressions_semantics nil)
    (RNumber nonempty-type-eq-decl nil expressions nil)
    (r1 skolem-const-decl "RNumber
    [(operatorUnderAnalysis?), RealNumber, FloatingPointNumber,
     restrict[float[radix], FloatingPointNumber, real](FtoR)]"
     nasalib_float_instantiation nil)
    (eval_input_analysis_eq formula-decl nil two_level_expressions nil)
    (r2 skolem-const-decl "RNumber
    [(operatorUnderAnalysis?), RealNumber, FloatingPointNumber,
     restrict[float[radix], FloatingPointNumber, real](FtoR)]"
     nasalib_float_instantiation nil)
    (le const-decl "bool" le "orders/")
    (mult_divides1 application-judgement "(divides(n))" divides nil)
    (mult_divides2 application-judgement "(divides(m))" divides nil)
    (ulp const-decl "posreal" float "float/")
    (posreal nonempty-type-eq-decl nil real_types nil)
    (/ const-decl "[numfield, nznum -> numfield]" number_fields nil)
    (nznum nonempty-type-eq-decl nil number_fields nil)
    (/= const-decl "boolean" notequal nil)
    (Fadd const-decl
     "{f3: (Fcanonic?(b)) | Closest?(b)(FtoR(f1) + FtoR(f2), f3)}"
     cr_add "float/")
    (RtoF formal-const-decl "CanonicRoundingFun(b, round)"
     nasalib_float_instantiation nil)
    (CanonicRoundingFun type-eq-decl nil float "float/")
    (RNDF type-eq-decl nil float "float/")
    (round formal-const-decl "ClosestRoundingPred(b)"
           nasalib_float_instantiation nil)
    (ClosestRoundingPred type-eq-decl nil float "float/")
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (Rounding type-eq-decl nil float "float/")
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (Closest? const-decl "bool" float "float/")
    (Fbounded? const-decl "bool" float "float/")
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs
         nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (accum_err_bound formula-decl nil accum_err_add "float/")
    (add_aerr_bound const-decl "nonneg_real" accum_err_add "float/")
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (add_ulp_bound const-decl "nonneg_real" accum_err_add "float/")
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (e1 skolem-const-decl "RNumber
    [Operator, real, FloatingPointNumber,
     restrict[float[radix], FloatingPointNumber, real](FtoR)]"
     nasalib_float_instantiation nil)
    (e2 skolem-const-decl "RNumber
    [Operator, real, FloatingPointNumber,
     restrict[float[radix], FloatingPointNumber, real](FtoR)]"
     nasalib_float_instantiation nil)
    (minus_odd_is_odd application-judgement "odd_int" integers nil)
    (<= const-decl "bool" reals nil) (le_r const-decl "bool" le_r nil)
    (iRToAR def-decl "analysis_expr_th.RAExpr" two_level_expressions
     nil)
    (ARExpr type-eq-decl nil two_level_expressions nil)
    (iRToAR_env def-decl
     "{arLocalEnv: analysis_esem_th.RLocalEnvironment |
         size(rLocalEnv) = size(arLocalEnv)}" two_level_expressions
     nil)
    (iRToAR_par const-decl "analysis_esem_th.REnvironment"
     two_level_expressions nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int nonempty-type-eq-decl nil integers nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (> const-decl "bool" reals nil)
    (above nonempty-type-eq-decl nil integers nil)
    (radix formal-const-decl "above(1)" nasalib_float_instantiation
     nil)
    (float type-eq-decl nil float "float/")
    (= const-decl "[T, T -> boolean]" equalities nil)
    (>= const-decl "bool" reals nil)
    (RealNumber type-eq-decl nil nasalib_float_instantiation nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (Format type-eq-decl nil float "float/")
    (Fcanonic? const-decl "bool" float "float/")
    (b formal-const-decl "Format" nasalib_float_instantiation nil)
    (FloatingPointNumber type-eq-decl nil nasalib_float_instantiation
     nil)
    (restrict const-decl "R" restrict nil)
    (FtoR const-decl "real" float "float/")
    (ParameterIndex nonempty-type-eq-decl nil expressions nil)
    (FPNumber nonempty-type-eq-decl nil expressions nil)
    (< const-decl "bool" reals nil)
    (pred type-eq-decl nil defined_types nil)
    (strict_total_order? const-decl "bool" orders nil)
    (lt_fp const-decl "(strict_total_order?[FloatingPointNumber])"
     nasalib_float_instantiation nil)
    (FPEnvironment nonempty-type-eq-decl nil expressions_semantics nil)
    (FPAExpr type-decl nil expressions nil)
    (FPVariable? adt-recognizer-decl "[FPAExpr -> boolean]" expressions
     nil)
    (fpVarIndex const-decl "nat" expressions_semantics nil)
    (strict_well_founded? const-decl "bool" orders nil)
    (<< adt-def-decl "(strict_well_founded?[FPAExpr])" expressions nil)
    (LocalEnvironment nonempty-type-decl nil u_local_environment nil)
    (FPLocalEnvironment type-eq-decl nil expressions_semantics nil)
    (bounded_by? const-decl "bool" u_local_environment nil)
    (IFPEnvironment type-eq-decl nil two_level_expressions nil)
    (IFPLocalEnv type-eq-decl nil two_level_expressions nil)
    (IFExpr type-eq-decl nil two_level_expressions nil)
    (aerrByOp const-decl "ARExpr" nasalib_float_instantiation nil)
    (applyFun_r const-decl "real" nasalib_float_instantiation nil)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (FtoR def-decl "RAExpr" expressions nil)
    (eval def-decl "FPNumber" expressions_semantics nil)
    (add adt-constructor-decl "(add?)" nasalib_float_instantiation nil)
    (add? adt-recognizer-decl "[Operator -> boolean]"
     nasalib_float_instantiation nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil)
    (real_minus_real_is_real application-judgement "real" reals nil))
   nil))
 (IMP_accumulated_roundoff_error_TCC1 0
  (IMP_accumulated_roundoff_error_TCC1-1 nil 3757161980
   ("" (subtype-tcc) nil nil) nil nil))
 (IMP_accumulated_roundoff_error_TCC2 0
  (IMP_accumulated_roundoff_error_TCC2-1 nil 3757161980
   ("" (subtype-tcc) nil nil)
   ((int_abs_is_nonneg application-judgement "{j: nonneg_int | j >= i}"
     real_defs nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs
         nil))
   nil))
 (IMP_accumulated_roundoff_error_TCC3 0
  (IMP_accumulated_roundoff_error_TCC3-1 nil 3757161980
   ("" (skeep* :preds? t)
    (("" (expand "aerrByOp")
      (("" (expand "operatorUnderAnalysis?")
        (("" (assert)
          (("" (expand "appears?")
            (("" (expand "appearsFree?" -3)
              (("" (split -3)
                (("1" (expand "appearsFree?" -1)
                  (("1" (split -1)
                    (("1" (propax) nil nil) ("2" (propax) nil nil))
                    nil))
                  nil)
                 ("2" (expand "appearsFree?" -1)
                  (("2" (split -1)
                    (("1" (expand "appearsFree?" -1)
                      (("1" (split -1)
                        (("1" (propax) nil nil) ("2" (propax) nil nil))
                        nil))
                      nil)
                     ("2" (expand "appearsFree?" -1)
                      (("2" (split -1)
                        (("1" (propax) nil nil) ("2" (propax) nil nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((aerrByOp const-decl "ARExpr" nasalib_float_instantiation nil)
    (appearsFree? def-decl "bool" expressions nil)
    (appears? const-decl "bool" expressions nil)
    (operatorUnderAnalysis? const-decl "bool"
     nasalib_float_instantiation nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil))
 (IMP_accumulated_roundoff_error_TCC4 0
  (IMP_accumulated_roundoff_error_TCC4-2 "" 3757354723
   ("" (skeep)
    (("" (lemma "addErrExpr_j")
      (("" (expand "addErrExpr")
        (("" (typepred "operator")
          (("" (expand "operatorUnderAnalysis?")
            (("" (replace -1 :hide? t)
              (("" (inst? -1 :where 1) (("" (assert) nil nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((addErrExpr_j judgement-tcc nil nasalib_float_instantiation nil)
    (operatorUnderAnalysis? const-decl "bool"
     nasalib_float_instantiation nil)
    (Operator type-decl nil nasalib_float_instantiation nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (RLocalEnvironment type-eq-decl nil expressions_semantics nil)
    (IRLocalEnv type-eq-decl nil two_level_expressions nil)
    (LocalEnvironment nonempty-type-decl nil u_local_environment nil)
    (<< adt-def-decl "(strict_well_founded?[RAExpr])" expressions nil)
    (strict_well_founded? const-decl "bool" orders nil)
    (rVarIndex const-decl "nat" expressions_semantics nil)
    (>= const-decl "bool" reals nil)
    (RVariable? adt-recognizer-decl "[RAExpr -> boolean]" expressions
     nil)
    (IRExpr type-eq-decl nil two_level_expressions nil)
    (ARExpr type-eq-decl nil two_level_expressions nil)
    (applyFun_fp const-decl "FloatingPointNumber"
     nasalib_float_instantiation nil)
    (lt_fp const-decl "(strict_total_order?[FloatingPointNumber])"
     nasalib_float_instantiation nil)
    (strict_total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (applyFun_r const-decl "real" nasalib_float_instantiation nil)
    (< const-decl "bool" reals nil)
    (RAExpr type-decl nil expressions nil)
    (FtoR const-decl "real" float "float/")
    (restrict const-decl "R" restrict nil)
    (FloatingPointNumber type-eq-decl nil nasalib_float_instantiation
     nil)
    (b formal-const-decl "Format" nasalib_float_instantiation nil)
    (Fcanonic? const-decl "bool" float "float/")
    (Format type-eq-decl nil float "float/")
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (float type-eq-decl nil float "float/")
    (radix formal-const-decl "above(1)" nasalib_float_instantiation
     nil)
    (above nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (RealNumber type-eq-decl nil nasalib_float_instantiation nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (addErrExpr const-decl "ARExpr" nasalib_float_instantiation nil))
   shostak)
  (IMP_accumulated_roundoff_error_TCC4-1 nil 3757161980
   ("" (skeep* :preds? t)
    (("" (expand "aerrByOp")
      (("" (expand "operatorUnderAnalysis?")
        (("" (assert)
          ((""
            (case "EXISTS (op: Operator): operatorUnderAnalysis?(op)")
            (("1" (rewrite "evaluable_in_raexpr_def_op")
              (("1" (split 1)
                (("1" (rewrite "evaluable_in_raexpr_def_op") nil nil)
                 ("2" (rewrite "evaluable_in_raexpr_def_op")
                  (("2" (split 1)
                    (("1" (rewrite "evaluable_in_raexpr_def_op")
                      (("1" (split 1)
                        (("1"
                          (use "evaluable_rLocalEnv_evaluable_iRToAR_env")
                          (("1" (assert) nil nil)) nil)
                         ("2"
                          (use "evaluable_rLocalEnv_evaluable_iRToAR_env")
                          (("2" (assert) nil nil)) nil))
                        nil))
                      nil)
                     ("2" (rewrite "evaluable_in_raexpr_def_op") nil
                      nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (inst 1 "add")
              (("2" (expand "operatorUnderAnalysis?")
                (("2" (propax) nil nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((RLocalEnvironment type-eq-decl nil expressions_semantics nil)
    (IRLocalEnv type-eq-decl nil two_level_expressions nil)
    (LocalEnvironment nonempty-type-decl nil u_local_environment nil)
    (<< adt-def-decl "(strict_well_founded?[RAExpr])" expressions nil)
    (maxFreeLocalIndex_RAExpr def-decl "{maxInd: upfrom(-1) |
         IF EXISTS (local: (RVariable?)): subterm(local, rexpr)
           THEN (EXISTS (local: (RVariable?) | subterm(local, rexpr)):
                   index(local) = maxInd)
                 AND
                 (FORALL (local: (RVariable?) | subterm(local, rexpr)):
                    index(local) <= maxInd)
         ELSE maxInd = -1
         ENDIF}" expressions nil)
    (index shared-adt-accessor-decl
           "[{x: RAExpr | RVariable?(x) OR RParameter?(x)} -> DeBruijnIndex]"
           expressions nil)
    (DeBruijnIndex nonempty-type-eq-decl nil expressions nil)
    (RParameter? adt-recognizer-decl "[RAExpr -> boolean]" expressions
     nil)
    (rVarIndex const-decl "nat" expressions_semantics nil)
    (RVariable? adt-recognizer-decl "[RAExpr -> boolean]" expressions
     nil)
    (IRExpr type-eq-decl nil two_level_expressions nil)
    (ARExpr type-eq-decl nil two_level_expressions nil)
    (RAExpr type-decl nil expressions nil)
    (FtoR const-decl "real" float "float/")
    (Fcanonic? const-decl "bool" float "float/")
    (Format type-eq-decl nil float "float/")
    (float type-eq-decl nil float "float/"))
   nil))
 (IMP_accumulated_roundoff_error_TCC5 0
  (IMP_accumulated_roundoff_error_TCC5-1 nil 3757161980
   ("" (skeep* :preds? t)
    (("" (expand "operatorUnderAnalysis?")
      (("" (expand "aerrByOp")
        (("" (assert)
          (("" (expand "eval" 1)
            (("" (expand "applyFun_r")
              (("" (expand "eval" 1)
                (("" (expand "applyFun_r")
                  (("" (replace -11)
                    (("" (replace -13)
                      (("" (assert)
                        (("" (expand "eval" 1 1)
                          (("" (expand "applyFun_r")
                            (("" (expand "eval" 1 4)
                              ((""
                                (expand "applyFun_r")
                                ((""
                                  (expand "eval" 1 1)
                                  ((""
                                    (expand "applyFun_r")
                                    ((""
                                      (expand "eval" 1 5)
                                      ((""
                                        (expand "applyFun_r")
                                        ((""
                                          (assert)
                                          ((""
                                            (replace -11)
                                            ((""
                                              (replace -13)
                                              ((""
                                                (rewrite
                                                 "eval_input_analysis_eq"
                                                 -10)
                                                ((""
                                                  (rewrite
                                                   "eval_input_analysis_eq"
                                                   -10)
                                                  ((""
                                                    (replace -10)
                                                    ((""
                                                      (rewrite
                                                       "eval_input_analysis_eq"
                                                       -12)
                                                      ((""
                                                        (rewrite
                                                         "eval_input_analysis_eq"
                                                         -12)
                                                        ((""
                                                          (replace -12)
                                                          ((""
                                                            (propax)
                                                            nil
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((operatorUnderAnalysis? const-decl "bool"
     nasalib_float_instantiation nil)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (applyFun_r const-decl "real" nasalib_float_instantiation nil)
    (FtoR const-decl "real" float "float/")
    (restrict const-decl "R" restrict nil)
    (applyFun_fp const-decl "FloatingPointNumber"
     nasalib_float_instantiation nil)
    (lt_fp const-decl "(strict_total_order?[FloatingPointNumber])"
     nasalib_float_instantiation nil)
    (strict_total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (FloatingPointNumber type-eq-decl nil nasalib_float_instantiation
     nil)
    (b formal-const-decl "Format" nasalib_float_instantiation nil)
    (Fcanonic? const-decl "bool" float "float/")
    (Format type-eq-decl nil float "float/")
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (float type-eq-decl nil float "float/")
    (radix formal-const-decl "above(1)" nasalib_float_instantiation
     nil)
    (above nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (< const-decl "bool" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (RealNumber type-eq-decl nil nasalib_float_instantiation nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (Operator type-decl nil nasalib_float_instantiation nil)
    (bounded_by? const-decl "bool" u_local_environment nil)
    (RLocalEnvironment type-eq-decl nil expressions_semantics nil)
    (LocalEnvironment nonempty-type-decl nil u_local_environment nil)
    (<< adt-def-decl "(strict_well_founded?[RAExpr])" expressions nil)
    (strict_well_founded? const-decl "bool" orders nil)
    (rVarIndex const-decl "nat" expressions_semantics nil)
    (RVariable? adt-recognizer-decl "[RAExpr -> boolean]" expressions
     nil)
    (RAExpr type-decl nil expressions nil)
    (REnvironment nonempty-type-eq-decl nil expressions_semantics nil)
    (RNumber nonempty-type-eq-decl nil expressions nil)
    (ParameterIndex nonempty-type-eq-decl nil expressions nil)
    (>= const-decl "bool" reals nil)
    (eval_input_analysis_eq formula-decl nil two_level_expressions nil)
    (posreal_div_posreal_is_posreal application-judgement "posreal"
     real_types nil)
    (eval def-decl "RNumber" expressions_semantics nil)
    (aerrByOp const-decl "ARExpr" nasalib_float_instantiation nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil))
 (IMP_accumulated_roundoff_error_TCC6 0
  (IMP_accumulated_roundoff_error_TCC6-1 nil 3757161980
   ("" (skeep* :preds? t)
    (("" (expand "operatorUnderAnalysis?")
      (("" (replace -5 :hide? t)
        ((""
          (typepred
           "addErrVal(fpParamEnv,fpLocalEnv)(fe1,fe3)(re2,re4)")
          (("" (expand "addErrVal")
            (("" (split -1)
              (("1" (expand "addErrExpr")
                (("1" (split 1)
                  (("1"
                    (case "FORALL(x,y: real): le_r(abs(x),y) IMPLIES le_r(0,y)")
                    (("1" (inst? -1 :where 1)
                      (("1" (inst? -1 :where -2)
                        (("1" (assert) nil nil)) nil)
                       ("2" (hide 2)
                        (("2" (inst 1 "add")
                          (("2" (expand "operatorUnderAnalysis?")
                            (("2" (propax) nil nil)) nil))
                          nil))
                        nil))
                      nil)
                     ("2" (hide-all-but 1) (("2" (grind) nil nil))
                      nil))
                    nil)
                   ("2" (propax) nil nil))
                  nil))
                nil)
               ("2" (propax) nil nil) ("3" (propax) nil nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((operatorUnderAnalysis? const-decl "bool"
     nasalib_float_instantiation nil)
    (addErrVal const-decl "{result: real |
         LET irParamEnv = input_esem_th.FtoR(ifpParamEnv),
             arParamEnv = iRToAR_par(irParamEnv),
             irLocalEnv = input_esem_th.FtoR(ifpLocalEnv),
             arLocalEnv = iRToAR_env(irLocalEnv)
           IN
           le_r(abs(FtoR(input_esem_th.eval
                             (ifpParamEnv, ifpLocalEnv)(ife1))
                     -
                     input_esem_th.eval
                         (irParamEnv, irLocalEnv)(FtoR(ife1))),
                eval(arParamEnv, arLocalEnv)(are1))
            AND
            le_r(abs(FtoR(input_esem_th.eval
                              (ifpParamEnv, ifpLocalEnv)(ife2))
                      -
                      input_esem_th.eval
                          (irParamEnv, irLocalEnv)(FtoR(ife2))),
                 eval(arParamEnv, arLocalEnv)(are2))
            IMPLIES
            LET diff: real =
                  FtoR(input_esem_th.eval
                           (ifpParamEnv, ifpLocalEnv)
                           (FPOperator(add, ife1, ife2)))
                   -
                   input_esem_th.eval
                       (irParamEnv, irLocalEnv)
                       (input_expr_th.FtoR(FPOperator(add, ife1, ife2)))
              IN le_r(abs(diff), result)}" nasalib_float_instantiation
     nil)
    (ARExpr type-eq-decl nil two_level_expressions nil)
    (IFExpr type-eq-decl nil two_level_expressions nil)
    (IFPLocalEnv type-eq-decl nil two_level_expressions nil)
    (IFPEnvironment type-eq-decl nil two_level_expressions nil)
    (add adt-constructor-decl "(add?)" nasalib_float_instantiation nil)
    (add? adt-recognizer-decl "[Operator -> boolean]"
     nasalib_float_instantiation nil)
    (FPOperator adt-constructor-decl
     "[[Operator, FPAExpr, FPAExpr] -> (FPOperator?)]" expressions nil)
    (FPOperator? adt-recognizer-decl "[FPAExpr -> boolean]" expressions
     nil)
    (bounded_by?_raexpr const-decl "bool" expressions_semantics nil)
    (iRToAR_env def-decl
     "{arLocalEnv: analysis_esem_th.RLocalEnvironment |
         size(rLocalEnv) = size(arLocalEnv)}" two_level_expressions
     nil)
    (iRToAR_par const-decl "analysis_esem_th.REnvironment"
     two_level_expressions nil)
    (FtoR const-decl "{rle: RLocalEnvironment |
         size(fle) = size(rle) AND
          (FORALL (i: below(size(rle))): get(rle)(i) = FtoR(get(fle)(i)))}"
     expressions_semantics nil)
    (FtoR def-decl "RAExpr" expressions nil)
    (get const-decl "T" u_local_environment nil)
    (below type-eq-decl nil naturalnumbers nil)
    (size const-decl "nat" u_local_environment nil)
    (FtoR const-decl "InducedREnv(fpEnv)" expressions_semantics nil)
    (InducedREnv nonempty-type-eq-decl nil expressions_semantics nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (eval def-decl "RNumber" expressions_semantics nil)
    (RLocalEnvironment type-eq-decl nil expressions_semantics nil)
    (<< adt-def-decl "(strict_well_founded?[RAExpr])" expressions nil)
    (rVarIndex const-decl "nat" expressions_semantics nil)
    (RVariable? adt-recognizer-decl "[RAExpr -> boolean]" expressions
     nil)
    (RAExpr type-decl nil expressions nil)
    (REnvironment nonempty-type-eq-decl nil expressions_semantics nil)
    (RNumber nonempty-type-eq-decl nil expressions nil)
    (eval def-decl "FPNumber" expressions_semantics nil)
    (bounded_by? const-decl "bool" u_local_environment nil)
    (FPLocalEnvironment type-eq-decl nil expressions_semantics nil)
    (LocalEnvironment nonempty-type-decl nil u_local_environment nil)
    (<< adt-def-decl "(strict_well_founded?[FPAExpr])" expressions nil)
    (strict_well_founded? const-decl "bool" orders nil)
    (fpVarIndex const-decl "nat" expressions_semantics nil)
    (FPVariable? adt-recognizer-decl "[FPAExpr -> boolean]" expressions
     nil)
    (FPAExpr type-decl nil expressions nil)
    (FPEnvironment nonempty-type-eq-decl nil expressions_semantics nil)
    (applyFun_fp const-decl "FloatingPointNumber"
     nasalib_float_instantiation nil)
    (lt_fp const-decl "(strict_total_order?[FloatingPointNumber])"
     nasalib_float_instantiation nil)
    (strict_total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (applyFun_r const-decl "real" nasalib_float_instantiation nil)
    (FPNumber nonempty-type-eq-decl nil expressions nil)
    (ParameterIndex nonempty-type-eq-decl nil expressions nil)
    (restrict const-decl "R" restrict nil)
    (FloatingPointNumber type-eq-decl nil nasalib_float_instantiation
     nil)
    (b formal-const-decl "Format" nasalib_float_instantiation nil)
    (Fcanonic? const-decl "bool" float "float/")
    (Format type-eq-decl nil float "float/")
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (RealNumber type-eq-decl nil nasalib_float_instantiation nil)
    (Operator type-decl nil nasalib_float_instantiation nil)
    (FtoR const-decl "real" float "float/")
    (float type-eq-decl nil float "float/")
    (radix formal-const-decl "above(1)" nasalib_float_instantiation
     nil)
    (above nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (abs const-decl "{n: nonneg_real | n >= m AND n >= -m}" real_defs
         nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (>= const-decl "bool" reals nil) (le_r const-decl "bool" le_r nil)
    (< const-decl "bool" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (le const-decl "bool" le "orders/")
    (mult_divides1 application-judgement "(divides(n))" divides nil)
    (mult_divides2 application-judgement "(divides(m))" divides nil)
    (aerrByOp const-decl "ARExpr" nasalib_float_instantiation nil)
    (IRExpr type-eq-decl nil two_level_expressions nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (addErrExpr const-decl "ARExpr" nasalib_float_instantiation nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil)
    (real_minus_real_is_real application-judgement "real" reals nil))
   nil)))

