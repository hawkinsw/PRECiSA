%
% This theory is an ad-hoc interpretation for u_list_environment.
% Its main goal is to prove the existence of a concrete type that fulfills
% the restrictions imposed by the (implicit and explicit) axioms declared
% in u_local_environment
%
u_local_environment__list_interpretation
[ T             : TYPE+
, variable? 	: PRED[T]
, index     	: [(variable?)->nat]
, <<        	: (strict_well_founded?[T]) ] : THEORY
BEGIN

  IMPORTING structures@more_list_props[T]

  lt: VAR list[T]

  size(env: list[T]): nat = length(env)
  shrink(env: list[T],i: below(size(env))): list[T] = takeFromRight(env,length(env)-(i+1))
  get (env: list[T])(i: below(size(env))): T = nth(env,i)

  bounded_by?(env: list[T])(expr: T): bool
  = FORALL(v:(variable?)|v=expr OR v<<expr): index(v) < size(env)
  
  LocalEnvironment
  : TYPE+
  = { env: list[T] | FORALL(i: below(length(env))):
      bounded_by?(shrink(env,i))(get(env)(i)) }

  env,env1,env2: VAR LocalEnvironment

  shrink_le_j
  : JUDGEMENT
    FORALL(env: LocalEnvironment, i: below(length(env)))
    : shrink(env,i) HAS_TYPE LocalEnvironment

  expr: VAR T

  cons(expr,(env|bounded_by?(env)(expr))): LocalEnvironment = cons(expr,env)
  empty_local_env: LocalEnvironment = null
  get (env: LocalEnvironment)(i: below(size(env))): T = nth(env,i)

  size_cons
  : LEMMA
    FORALL(expr:(bounded_by?(env)))
    : size(env) <= size(cons(expr, env))

  size_cons_def
  : LEMMA
    FORALL(expr:(bounded_by?(env)))
    : size(cons(expr, env)) = 1+size(env)

  size_empty
  : LEMMA
    size(empty_local_env) = 0

  size_shrink
  : LEMMA
    FORALL(i: below(size(env)))
    : size(shrink(env,i)) = size(env) - (i+1)

  shrink_env_monotonocity
  : LEMMA
    FORALL(idx: upto(size(env)) |  NOT idx = 0, expr:(bounded_by?(env)))
    : shrink(cons(expr, env), idx) = shrink(env,idx-1)

  shrink_env_monotonocity__unint
  : LEMMA
    FORALL( env: list[T],
    	    (idx: upto(length(env)) |  NOT idx = 0),
	    expr: T)
    : shrink(cons[T](expr, env), idx) = shrink(env,idx-1)

  shrink_for_last_added
  : LEMMA
    FORALL(expr:(bounded_by?(env)))
    : shrink(cons(expr, env), 0) = env

  shrink_for_last_added_unint
  : LEMMA
    FORALL(expr:T)
    : shrink(cons[T](expr, env), 0) = env

  get_env_monotonicity
  : LEMMA
    FORALL(idx: upto(size(env)) | NOT idx = 0, expr:(bounded_by?(env)))
    : get(cons(expr, env))(idx) = get(env)(idx-1)

  get_env_monotonicity_unint
  : LEMMA
    FORALL( env: list[T],
    	    (idx: upto(length(env)) |  NOT idx = 0),
	    expr: T)
    : get(cons[T](expr, env))(idx) = get(env)(idx-1)

  get_last_added
  : LEMMA
    FORALL(expr:(bounded_by?(env)))
    : get(cons(expr, env))(0) = expr

  IMPORTING structures@more_list_props[T]

  u_local_environment_extensionality
  : LEMMA
    (env1 = env2)
    = ( size(env1) = size(env2) AND FORALL(i: below(size(env1))): get(env1)(i) = get(env2)(i))

  get_shrink
  : LEMMA
    FORALL(j: below(size(env)), i: below(size(shrink(env,j))))
    : get(env)(i+j+1) = get(shrink(env,j))(i)

  %
  
  local_definitions_are_evaluable_in_smaller_env: LEMMA
    FORALL(env: LocalEnvironment,i: below(size(env))):
      bounded_by?(shrink(env,i))(get(env)(i))
  AUTO_REWRITE+ local_definitions_are_evaluable_in_smaller_env

  %

  env_cons_eta: LEMMA
    FORALL (env | 0 < size(env)):
      cons(get(env)(0), shrink(env,0)) = env

  % Induction Scheme

  lenv_induction: LEMMA
    FORALL (p: [LocalEnvironment -> boolean]):
      ( p(empty_local_env) AND
        ( FORALL (env: LocalEnvironment, expr: T | bounded_by?(env)(expr) )
	  : p(env)
	    IMPLIES p(cons(expr, env)) ))
      IMPLIES (FORALL (env: LocalEnvironment): p(env));
  
  %
  % Evaluation Context (used to define eval in expression_semantics)
  %

  EvaluationContext: TYPE = [# expr: T, locals: LocalEnvironment #]

  make_context(expr: T, locals: LocalEnvironment): MACRO EvaluationContext
  = (# expr:=expr, locals:=locals #)

  ;<<: [EvaluationContext,EvaluationContext->bool]
  = LAMBDA(e1,e2: EvaluationContext)
    : size(locals(e1)) < size(locals(e2))
      OR (size(locals(e1)) = size(locals(e2)) AND expr(e1) << expr(e2))

  doublelessp_swf: LEMMA strict_well_founded?[EvaluationContext](<<)

END u_local_environment__list_interpretation
