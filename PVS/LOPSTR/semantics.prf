(semantics
 (IMP_expressions_semantics_TCC1 0
  (IMP_expressions_semantics_TCC1-1 nil 3756637188
   ("" (use "lt_fp_lt_r") nil nil)
   ((lt_fp_lt_r formula-decl nil semantics nil)) nil))
 (evaluable_in_stmt_wellformed_eq 0
  (evaluable_in_stmt_wellformed_eq-1 nil 3754231121
   ("" (expand "bounded_by?") (("" (propax) nil nil)) nil)
   ((bounded_by? const-decl "bool" semantics nil)) shostak))
 (fp_evaluable_in_stmt_evaluable_letin_expr 0
  (fp_evaluable_in_stmt_evaluable_letin_expr-1 nil 3755249905
   ("" (skeep)
    (("" (expand "bounded_by?" -1)
      (("" (use "evaluable_in_fpaexpr_wellformed_eq")
        (("" (replace -1 :hide? t)
          (("" (skeep -1)
            (("" (rewrite "well_formed_def_letin")
              (("" (flatten) (("" (inst?) nil nil)) nil)) nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((bounded_by? const-decl "bool" semantics nil)
    (well_formed_def_letin formula-decl nil program nil)
    (size const-decl "nat" u_local_environment nil)
    (FPStmt type-decl nil program nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (FPAExpr type-decl nil expressions nil)
    (FPVariable? adt-recognizer-decl "[FPAExpr -> boolean]" expressions
     nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (fpVarIndex const-decl "nat" expressions_semantics nil)
    (strict_well_founded? const-decl "bool" orders nil)
    (<< adt-def-decl "(strict_well_founded?[FPAExpr])" expressions nil)
    (LocalEnvironment nonempty-type-decl nil u_local_environment nil)
    (FPLocalEnvironment type-eq-decl nil expressions_semantics nil)
    (FtoR formal-const-decl "[FloatingPointNumber -> RealNumber]"
     semantics nil)
    (applyFun_fp formal-const-decl
     "[[Operator, FloatingPointNumber, FloatingPointNumber] ->
   FloatingPointNumber]" semantics nil)
    (lt_fp formal-const-decl
     "(strict_total_order?[FloatingPointNumber])" semantics nil)
    (FloatingPointNumber formal-nonempty-type-decl nil semantics nil)
    (applyFun_r formal-const-decl
     "[[Operator, RealNumber, RealNumber] -> RealNumber]" semantics
     nil)
    (lt_r formal-const-decl "(strict_total_order?[RealNumber])"
     semantics nil)
    (strict_total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (RealNumber formal-nonempty-type-decl nil semantics nil)
    (Operator formal-nonempty-type-decl nil semantics nil)
    (evaluable_in_fpaexpr_wellformed_eq formula-decl nil
     expressions_semantics nil))
   shostak))
 (fp_evaluable_in_stmt_evaluable_letin_body_TCC1 0
  (fp_evaluable_in_stmt_evaluable_letin_body_TCC1-1 nil 3755693006
   ("" (subtype-tcc) nil nil)
   ((bounded_by? const-decl "bool" semantics nil)) nil))
 (fp_evaluable_in_stmt_evaluable_letin_body 0
  (fp_evaluable_in_stmt_evaluable_letin_body-1 nil 3752595369
   ("" (skeep)
    (("" (expand "bounded_by?")
      (("" (skolem - "n")
        (("" (inst 1 "n")
          (("" (expand "wellFormed?" -1)
            (("" (flatten) (("" (grind) nil nil)) nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((bounded_by? const-decl "bool" semantics nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (<< adt-def-decl "(strict_well_founded?[FPAExpr])" expressions nil)
    (strict_well_founded? const-decl "bool" orders nil)
    (fpVarIndex const-decl "nat" expressions_semantics nil)
    (applyFun_fp formal-const-decl
     "[[Operator, FloatingPointNumber, FloatingPointNumber] ->
   FloatingPointNumber]" semantics nil)
    (lt_fp formal-const-decl
     "(strict_total_order?[FloatingPointNumber])" semantics nil)
    (applyFun_r formal-const-decl
     "[[Operator, RealNumber, RealNumber] -> RealNumber]" semantics
     nil)
    (lt_r formal-const-decl "(strict_total_order?[RealNumber])"
     semantics nil)
    (strict_total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (FPVariable? adt-recognizer-decl "[FPAExpr -> boolean]" expressions
     nil)
    (FPAExpr type-decl nil expressions nil)
    (FtoR formal-const-decl "[FloatingPointNumber -> RealNumber]"
     semantics nil)
    (FloatingPointNumber formal-nonempty-type-decl nil semantics nil)
    (RealNumber formal-nonempty-type-decl nil semantics nil)
    (Operator formal-nonempty-type-decl nil semantics nil)
    (size_cons_def formula-decl nil u_local_environment nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (wellFormed? inductive-decl "bool" program nil))
   shostak))
 (fp_evaluable_in_stmt_evaluable_ite 0
  (fp_evaluable_in_stmt_evaluable_ite-1 nil 3752595369
   ("" (skeep)
    (("" (expand "bounded_by?" -1)
      (("" (use "evaluable_in_wellformed_eq")
        (("" (replace -1 :hide? t)
          (("" (expand "wellFormed?" -1)
            (("" (skeep) (("" (inst 1 "n") nil nil)) nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((bounded_by? const-decl "bool" semantics nil)
    (wellFormed? inductive-decl "bool" program nil)
    (FPAExpr type-decl nil expressions nil)
    (FPVariable? adt-recognizer-decl "[FPAExpr -> boolean]" expressions
     nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (fpVarIndex const-decl "nat" expressions_semantics nil)
    (strict_well_founded? const-decl "bool" orders nil)
    (<< adt-def-decl "(strict_well_founded?[FPAExpr])" expressions nil)
    (LocalEnvironment nonempty-type-decl nil u_local_environment nil)
    (FPLocalEnvironment type-eq-decl nil expressions_semantics nil)
    (FPBExpr type-decl nil expressions nil)
    (FPStmt type-decl nil program nil)
    (IfThenElse? adt-recognizer-decl "[FPStmt -> boolean]" program nil)
    (guard adt-accessor-decl
     "[(IfThenElse?) -> FPBExpr[Operator, RealNumber, FloatingPointNumber, FtoR]]"
     program nil)
    (FtoR formal-const-decl "[FloatingPointNumber -> RealNumber]"
     semantics nil)
    (applyFun_fp formal-const-decl
     "[[Operator, FloatingPointNumber, FloatingPointNumber] ->
   FloatingPointNumber]" semantics nil)
    (lt_fp formal-const-decl
     "(strict_total_order?[FloatingPointNumber])" semantics nil)
    (FloatingPointNumber formal-nonempty-type-decl nil semantics nil)
    (applyFun_r formal-const-decl
     "[[Operator, RealNumber, RealNumber] -> RealNumber]" semantics
     nil)
    (lt_r formal-const-decl "(strict_total_order?[RealNumber])"
     semantics nil)
    (strict_total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (RealNumber formal-nonempty-type-decl nil semantics nil)
    (Operator formal-nonempty-type-decl nil semantics nil)
    (evaluable_in_wellformed_eq formula-decl nil expressions_semantics
     nil))
   shostak))
 (r_evaluable_in_stmt_evaluable_ite 0
  (r_evaluable_in_stmt_evaluable_ite-1 nil 3752595369
   ("" (skeep)
    (("" (use "fp_evaluable_in_stmt_evaluable_ite")
      (("" (assert)
        (("" (lemma "evaluable_in_fp_evaluable_in_r")
          (("" (inst -1 "fpLocalEnv" "rLocalEnv" "guard(ite)")
            (("" (assert) nil nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((fp_evaluable_in_stmt_evaluable_ite formula-decl nil semantics nil)
    (IfThenElse? adt-recognizer-decl "[FPStmt -> boolean]" program nil)
    (FPStmt type-decl nil program nil)
    (FPLocalEnvironment type-eq-decl nil expressions_semantics nil)
    (LocalEnvironment nonempty-type-decl nil u_local_environment nil)
    (<< adt-def-decl "(strict_well_founded?[FPAExpr])" expressions nil)
    (strict_well_founded? const-decl "bool" orders nil)
    (fpVarIndex const-decl "nat" expressions_semantics nil)
    (applyFun_fp formal-const-decl
     "[[Operator, FloatingPointNumber, FloatingPointNumber] ->
   FloatingPointNumber]" semantics nil)
    (lt_fp formal-const-decl
     "(strict_total_order?[FloatingPointNumber])" semantics nil)
    (applyFun_r formal-const-decl
     "[[Operator, RealNumber, RealNumber] -> RealNumber]" semantics
     nil)
    (lt_r formal-const-decl "(strict_total_order?[RealNumber])"
     semantics nil)
    (strict_total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (FPVariable? adt-recognizer-decl "[FPAExpr -> boolean]" expressions
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (FPAExpr type-decl nil expressions nil)
    (FtoR formal-const-decl "[FloatingPointNumber -> RealNumber]"
     semantics nil)
    (FloatingPointNumber formal-nonempty-type-decl nil semantics nil)
    (RealNumber formal-nonempty-type-decl nil semantics nil)
    (Operator formal-nonempty-type-decl nil semantics nil)
    (evaluable_in_fp_evaluable_in_r formula-decl nil
     expressions_semantics nil)
    (guard adt-accessor-decl
     "[(IfThenElse?) -> FPBExpr[Operator, RealNumber, FloatingPointNumber, FtoR]]"
     program nil)
    (FPBExpr type-decl nil expressions nil)
    (consistentLocalEnvironments? const-decl "bool"
     expressions_semantics nil)
    (RLocalEnvironment type-eq-decl nil expressions_semantics nil)
    (<< adt-def-decl "(strict_well_founded?[RAExpr])" expressions nil)
    (rVarIndex const-decl "nat" expressions_semantics nil)
    (RVariable? adt-recognizer-decl "[RAExpr -> boolean]" expressions
     nil)
    (RAExpr type-decl nil expressions nil))
   shostak))
 (fp_evaluable_in_stmt_evaluable_ite_then 0
  (fp_evaluable_in_stmt_evaluable_ite_then-1 nil 3752595370
   ("" (skeep* :preds? t)
    (("" (use "evaluable_in_stmt_wellformed_eq")
      (("" (replace -1 :hide? t)
        (("" (use "evaluable_in_stmt_wellformed_eq")
          (("" (replace -1 :hide? t)
            (("" (skeep)
              (("" (inst 1 "n")
                (("" (lemma "well_formed_ite_then")
                  ((""
                    (inst -1 "n" "size(fpLocalEnv)" "guard(ite)"
                     "thenBranch(ite)" "elseBranch(ite)")
                    (("" (assert)
                      ((""
                        (case "ite = ITE(guard(ite), thenBranch(ite), elseBranch(ite))")
                        (("1" (assert) nil nil)
                         ("2" (apply-extensionality) nil nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((evaluable_in_stmt_wellformed_eq formula-decl nil semantics nil)
    (IfThenElse? adt-recognizer-decl "[FPStmt -> boolean]" program nil)
    (FPStmt type-decl nil program nil)
    (FPLocalEnvironment type-eq-decl nil expressions_semantics nil)
    (LocalEnvironment nonempty-type-decl nil u_local_environment nil)
    (<< adt-def-decl "(strict_well_founded?[FPAExpr])" expressions nil)
    (strict_well_founded? const-decl "bool" orders nil)
    (fpVarIndex const-decl "nat" expressions_semantics nil)
    (applyFun_fp formal-const-decl
     "[[Operator, FloatingPointNumber, FloatingPointNumber] ->
   FloatingPointNumber]" semantics nil)
    (lt_fp formal-const-decl
     "(strict_total_order?[FloatingPointNumber])" semantics nil)
    (applyFun_r formal-const-decl
     "[[Operator, RealNumber, RealNumber] -> RealNumber]" semantics
     nil)
    (lt_r formal-const-decl "(strict_total_order?[RealNumber])"
     semantics nil)
    (strict_total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (FPVariable? adt-recognizer-decl "[FPAExpr -> boolean]" expressions
     nil)
    (FPAExpr type-decl nil expressions nil)
    (FtoR formal-const-decl "[FloatingPointNumber -> RealNumber]"
     semantics nil)
    (FloatingPointNumber formal-nonempty-type-decl nil semantics nil)
    (RealNumber formal-nonempty-type-decl nil semantics nil)
    (Operator formal-nonempty-type-decl nil semantics nil)
    (thenBranch adt-accessor-decl "[(IfThenElse?) -> FPStmt]" program
     nil)
    (well_formed_ite_then formula-decl nil program nil)
    (FPStmt_ITE_extensionality formula-decl nil program nil)
    (ITE adt-constructor-decl
     "[[FPBExpr[Operator, RealNumber, FloatingPointNumber, FtoR], FPStmt,
  FPStmt] ->
   (IfThenElse?)]" program nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (elseBranch adt-accessor-decl "[(IfThenElse?) -> FPStmt]" program
     nil)
    (guard adt-accessor-decl
     "[(IfThenElse?) -> FPBExpr[Operator, RealNumber, FloatingPointNumber, FtoR]]"
     program nil)
    (FPBExpr type-decl nil expressions nil)
    (size const-decl "nat" u_local_environment nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   shostak))
 (fp_evaluable_in_stmt_evaluable_ite_else 0
  (fp_evaluable_in_stmt_evaluable_ite_else-2 nil 3754231361
   ("" (skeep* :preds? t)
    (("" (use "evaluable_in_stmt_wellformed_eq")
      (("" (replace -1 :hide? t)
        (("" (use "evaluable_in_stmt_wellformed_eq")
          (("" (replace -1 :hide? t)
            (("" (skeep)
              (("" (inst 1 "n")
                (("" (lemma "well_formed_ite_else")
                  ((""
                    (inst -1 "n" "size(fpLocalEnv)" "guard(ite)"
                     "thenBranch(ite)" "elseBranch(ite)")
                    (("" (assert)
                      ((""
                        (case "ite = ITE(guard(ite), thenBranch(ite), elseBranch(ite))")
                        (("1" (assert) nil nil)
                         ("2" (apply-extensionality) nil nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((evaluable_in_stmt_wellformed_eq formula-decl nil semantics nil)
    (IfThenElse? adt-recognizer-decl "[FPStmt -> boolean]" program nil)
    (FPStmt type-decl nil program nil)
    (FPLocalEnvironment type-eq-decl nil expressions_semantics nil)
    (LocalEnvironment nonempty-type-decl nil u_local_environment nil)
    (<< adt-def-decl "(strict_well_founded?[FPAExpr])" expressions nil)
    (strict_well_founded? const-decl "bool" orders nil)
    (fpVarIndex const-decl "nat" expressions_semantics nil)
    (applyFun_fp formal-const-decl
     "[[Operator, FloatingPointNumber, FloatingPointNumber] ->
   FloatingPointNumber]" semantics nil)
    (lt_fp formal-const-decl
     "(strict_total_order?[FloatingPointNumber])" semantics nil)
    (applyFun_r formal-const-decl
     "[[Operator, RealNumber, RealNumber] -> RealNumber]" semantics
     nil)
    (lt_r formal-const-decl "(strict_total_order?[RealNumber])"
     semantics nil)
    (strict_total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (FPVariable? adt-recognizer-decl "[FPAExpr -> boolean]" expressions
     nil)
    (FPAExpr type-decl nil expressions nil)
    (FtoR formal-const-decl "[FloatingPointNumber -> RealNumber]"
     semantics nil)
    (FloatingPointNumber formal-nonempty-type-decl nil semantics nil)
    (RealNumber formal-nonempty-type-decl nil semantics nil)
    (Operator formal-nonempty-type-decl nil semantics nil)
    (elseBranch adt-accessor-decl "[(IfThenElse?) -> FPStmt]" program
     nil)
    (well_formed_ite_else formula-decl nil program nil)
    (FPStmt_ITE_extensionality formula-decl nil program nil)
    (ITE adt-constructor-decl
     "[[FPBExpr[Operator, RealNumber, FloatingPointNumber, FtoR], FPStmt,
  FPStmt] ->
   (IfThenElse?)]" program nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (thenBranch adt-accessor-decl "[(IfThenElse?) -> FPStmt]" program
     nil)
    (guard adt-accessor-decl
     "[(IfThenElse?) -> FPBExpr[Operator, RealNumber, FloatingPointNumber, FtoR]]"
     program nil)
    (FPBExpr type-decl nil expressions nil)
    (size const-decl "nat" u_local_environment nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil)
  (fp_evaluable_in_stmt_evaluable_ite_else-1 nil 3752595370
   ("" (skeep :but "stmt")
    (("" (induct "stmt")
      (("1" (grind) nil nil)
       ("2" (skolem 1 ("guard" "then_branch" "else_branch"))
        (("2" (flatten)
          (("2" (skeep* :preds? t)
            (("2" (expand "subterm" -2)
              (("2" (expand "bounded_by?" -5)
                (("2" (flatten)
                  (("2" (assert)
                    (("2" (split -2)
                      (("1" (grind) nil nil)
                       ("2" (inst -3 "ite") nil nil)
                       ("3" (inst -4 "ite") nil nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("3" (grind) nil nil)
       ("4" (skolem 1 ("aexpr" "body"))
        (("4" (flatten)
          (("4" (expand "bounded_by?" -2)
            (("4" (flatten)
              (("4" (assert)
                (("4" (skeep* :preds? t)
                  (("4" (inst -3 "ite")
                    (("4" (expand "subterm" -2)
                      (("4" (propax) nil nil)) nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((FPStmt type-decl nil program nil)
    (FPAExpr type-decl nil expressions nil)
    (FPLocalEnvironment type-eq-decl nil expressions_semantics nil)
    (IfThenElse? adt-recognizer-decl "[FPStmt -> boolean]" program nil)
    (subterm adt-def-decl "boolean" program nil)
    (elseBranch adt-accessor-decl "[(IfThenElse?) -> FPStmt]" program
     nil)
    (FPStmt_induction formula-decl nil program nil)
    (Warning? adt-recognizer-decl "[FPStmt -> boolean]" program nil)
    (WARNING adt-constructor-decl "(Warning?)" program nil)
    (fpVarIndex const-decl "nat" expressions_semantics nil)
    (<< adt-def-decl "(strict_well_founded?[FPAExpr])" expressions nil)
    (index shared-adt-accessor-decl
           "[{x: FPAExpr | FPVariable?(x) OR FPParameter?(x)} -> DeBruijnIndex]"
           expressions nil)
    (DeBruijnIndex nonempty-type-eq-decl nil expressions nil)
    (FPParameter? adt-recognizer-decl "[FPAExpr -> boolean]"
     expressions nil)
    (FPVariable? adt-recognizer-decl "[FPAExpr -> boolean]" expressions
     nil)
    (FPBExpr type-decl nil expressions nil)
    (ITE adt-constructor-decl
     "[[FPBExpr[Operator, RealNumber, FloatingPointNumber, FtoR], FPStmt,
  FPStmt] ->
   (IfThenElse?)]" program nil)
    (AExpr? adt-recognizer-decl "[FPStmt -> boolean]" program nil)
    (AEXPR adt-constructor-decl
     "[FPAExpr[Operator, RealNumber, FloatingPointNumber, FtoR] -> (AExpr?)]"
     program nil)
    (LetIn? adt-recognizer-decl "[FPStmt -> boolean]" program nil)
    (LETIN adt-constructor-decl
     "[[FPAExpr[Operator, RealNumber, FloatingPointNumber, FtoR], FPStmt] ->
   (LetIn?)]" program nil))
   shostak))
 (pgm_is_evaluable_in_empty_eng 0
  (pgm_is_evaluable_in_empty_eng-1 nil 3755001771
   ("" (skeep :preds? t)
    (("" (expand "wellFormedProgram?")
      (("" (expand "bounded_by?")
        (("" (inst?)
          (("" (expand "FPEmptyLocalEnv")
            (("" (rewrite "size_empty") nil nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((wellFormedProgram? const-decl "bool" program nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (Operator formal-nonempty-type-decl nil semantics nil)
    (RealNumber formal-nonempty-type-decl nil semantics nil)
    (FloatingPointNumber formal-nonempty-type-decl nil semantics nil)
    (FtoR formal-const-decl "[FloatingPointNumber -> RealNumber]"
     semantics nil)
    (FPStmt type-decl nil program nil)
    (FPProgram type-eq-decl nil program nil)
    (size_empty formula-decl nil u_local_environment nil)
    (FPAExpr type-decl nil expressions nil)
    (FPVariable? adt-recognizer-decl "[FPAExpr -> boolean]" expressions
     nil)
    (pred type-eq-decl nil defined_types nil)
    (strict_total_order? const-decl "bool" orders nil)
    (lt_r formal-const-decl "(strict_total_order?[RealNumber])"
     semantics nil)
    (applyFun_r formal-const-decl
     "[[Operator, RealNumber, RealNumber] -> RealNumber]" semantics
     nil)
    (lt_fp formal-const-decl
     "(strict_total_order?[FloatingPointNumber])" semantics nil)
    (applyFun_fp formal-const-decl
     "[[Operator, FloatingPointNumber, FloatingPointNumber] ->
   FloatingPointNumber]" semantics nil)
    (fpVarIndex const-decl "nat" expressions_semantics nil)
    (strict_well_founded? const-decl "bool" orders nil)
    (<< adt-def-decl "(strict_well_founded?[FPAExpr])" expressions nil)
    (FPEmptyLocalEnv const-decl "FPLocalEnvironment"
     expressions_semantics nil)
    (bounded_by? const-decl "bool" semantics nil))
   shostak))
 (get_from_semantic_environment_monotonocity_TCC1 0
  (get_from_semantic_environment_monotonocity_TCC1-1 nil 3754166623
   ("" (grind) nil nil) ((length def-decl "nat" list_props nil)) nil))
 (get_from_semantic_environment_monotonocity_TCC2 0
  (get_from_semantic_environment_monotonocity_TCC2-1 nil 3754166623
   ("" (subtype-tcc) nil nil)
   ((int_minus_int_is_int application-judgement "int" integers nil))
   nil))
 (get_from_semantic_environment_monotonocity 0
  (get_from_semantic_environment_monotonocity-1 nil 3754166624
   ("" (grind) nil nil)
   ((length def-decl "nat" list_props nil)
    (nth def-decl "T" list_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   shostak))
 (appears?_env_int_def 0
  (appears?_env_int_def-1 nil 3754571078
   ("" (expand "appears?" 1 1) (("" (propax) nil nil)) nil)
   ((appears? const-decl "bool" semantics nil)) shostak))
 (PairCEB_TCC1 0
  (PairCEB_TCC1-1 nil 3731411566
   ("" (existence-tcc)
    ((""
      (inst *
       "(: make_ceb(RTrue,FPTrue,RBottom,FPBottom,true), make_ceb(RTrue,FPTrue,RBottom,FPBottom,true):)")
      (("" (grind) nil nil)) nil))
    nil)
   ((Operator formal-nonempty-type-decl nil semantics nil)
    (RealNumber formal-nonempty-type-decl nil semantics nil)
    (FloatingPointNumber formal-nonempty-type-decl nil semantics nil)
    (FtoR formal-const-decl "[FloatingPointNumber -> RealNumber]"
     semantics nil)
    (FPBExpr type-decl nil expressions nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (pred type-eq-decl nil defined_types nil)
    (strict_total_order? const-decl "bool" orders nil)
    (lt_r formal-const-decl "(strict_total_order?[RealNumber])"
     semantics nil)
    (applyFun_r formal-const-decl
     "[[Operator, RealNumber, RealNumber] -> RealNumber]" semantics
     nil)
    (lt_fp formal-const-decl
     "(strict_total_order?[FloatingPointNumber])" semantics nil)
    (applyFun_fp formal-const-decl
     "[[Operator, FloatingPointNumber, FloatingPointNumber] ->
   FloatingPointNumber]" semantics nil)
    (FPAExprDomain type-decl nil domain nil)
    (RBExpr type-decl nil expressions nil)
    (RAExprDomain type-decl nil domain nil)
    (CEB type-eq-decl nil domain nil) (list type-decl nil list_adt nil)
    (number nonempty-type-decl nil numbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (length def-decl "nat" list_props nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (make_ceb const-decl "CEB" domain nil)
    (RTrue? adt-recognizer-decl "[RBExpr -> boolean]" expressions nil)
    (RTrue adt-constructor-decl "(RTrue?)" expressions nil)
    (FPTrue? adt-recognizer-decl "[FPBExpr -> boolean]" expressions
     nil)
    (FPTrue adt-constructor-decl "(FPTrue?)" expressions nil)
    (RBottom? adt-recognizer-decl "[RAExprDomain -> boolean]" domain
     nil)
    (RBottom adt-constructor-decl "(RBottom?)" domain nil)
    (FPBottom? adt-recognizer-decl "[FPAExprDomain -> boolean]" domain
     nil)
    (FPBottom adt-constructor-decl "(FPBottom?)" domain nil)
    (TRUE const-decl "bool" booleans nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil))
   nil))
 (TripleCEB_TCC1 0
  (TripleCEB_TCC1-1 nil 3731411566
   ("" (existence-tcc)
    ((""
      (inst *
       "(: make_ceb(RTrue,FPTrue,RBottom,FPBottom,true), make_ceb(RTrue,FPTrue,RBottom,FPBottom,true), make_ceb(RTrue,FPTrue,RBottom,FPBottom,true) :)")
      (("" (grind) nil nil)) nil))
    nil)
   ((Operator formal-nonempty-type-decl nil semantics nil)
    (RealNumber formal-nonempty-type-decl nil semantics nil)
    (FloatingPointNumber formal-nonempty-type-decl nil semantics nil)
    (FtoR formal-const-decl "[FloatingPointNumber -> RealNumber]"
     semantics nil)
    (FPBExpr type-decl nil expressions nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (pred type-eq-decl nil defined_types nil)
    (strict_total_order? const-decl "bool" orders nil)
    (lt_r formal-const-decl "(strict_total_order?[RealNumber])"
     semantics nil)
    (applyFun_r formal-const-decl
     "[[Operator, RealNumber, RealNumber] -> RealNumber]" semantics
     nil)
    (lt_fp formal-const-decl
     "(strict_total_order?[FloatingPointNumber])" semantics nil)
    (applyFun_fp formal-const-decl
     "[[Operator, FloatingPointNumber, FloatingPointNumber] ->
   FloatingPointNumber]" semantics nil)
    (FPAExprDomain type-decl nil domain nil)
    (RBExpr type-decl nil expressions nil)
    (RAExprDomain type-decl nil domain nil)
    (CEB type-eq-decl nil domain nil) (list type-decl nil list_adt nil)
    (number nonempty-type-decl nil numbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (length def-decl "nat" list_props nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (make_ceb const-decl "CEB" domain nil)
    (RTrue? adt-recognizer-decl "[RBExpr -> boolean]" expressions nil)
    (RTrue adt-constructor-decl "(RTrue?)" expressions nil)
    (FPTrue? adt-recognizer-decl "[FPBExpr -> boolean]" expressions
     nil)
    (FPTrue adt-constructor-decl "(FPTrue?)" expressions nil)
    (RBottom? adt-recognizer-decl "[RAExprDomain -> boolean]" domain
     nil)
    (RBottom adt-constructor-decl "(RBottom?)" domain nil)
    (FPBottom? adt-recognizer-decl "[FPAExprDomain -> boolean]" domain
     nil)
    (FPBottom adt-constructor-decl "(FPBottom?)" domain nil)
    (TRUE const-decl "bool" booleans nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil))
   nil))
 (makePairCEB_TCC1 0
  (makePairCEB_TCC1-1 nil 3753702385 ("" (grind) nil nil)
   ((length def-decl "nat" list_props nil)) nil))
 (length_TCC1 0
  (length_TCC1-1 nil 3732701184 ("" (judgement-tcc) nil nil) nil nil))
 (wellFormed?_TCC1 0
  (wellFormed?_TCC1-1 nil 3753213762 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (Operator formal-nonempty-type-decl nil semantics nil)
    (RealNumber formal-nonempty-type-decl nil semantics nil)
    (FloatingPointNumber formal-nonempty-type-decl nil semantics nil)
    (FtoR formal-const-decl "[FloatingPointNumber -> RealNumber]"
     semantics nil)
    (FPBExpr type-decl nil expressions nil)
    (pred type-eq-decl nil defined_types nil)
    (strict_total_order? const-decl "bool" orders nil)
    (lt_r formal-const-decl "(strict_total_order?[RealNumber])"
     semantics nil)
    (applyFun_r formal-const-decl
     "[[Operator, RealNumber, RealNumber] -> RealNumber]" semantics
     nil)
    (lt_fp formal-const-decl
     "(strict_total_order?[FloatingPointNumber])" semantics nil)
    (applyFun_fp formal-const-decl
     "[[Operator, FloatingPointNumber, FloatingPointNumber] ->
   FloatingPointNumber]" semantics nil)
    (FPAExprDomain type-decl nil domain nil)
    (RBExpr type-decl nil expressions nil)
    (RAExprDomain type-decl nil domain nil)
    (CEB type-eq-decl nil domain nil) (set type-eq-decl nil sets nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (every adt-def-decl "boolean" list_adt nil)
    (finite_nonempty? const-decl "bool" more_set_defs "sets_aux/")
    (Environment nonempty-type-eq-decl nil semantics nil))
   nil))
 (wellFormed?_TCC2 0
  (wellFormed?_TCC2-1 nil 3753213762 ("" (termination-tcc) nil nil)
   ((NOT const-decl "[bool -> bool]" booleans nil)
    (FPBExpr type-decl nil expressions nil)
    (FPAExprDomain type-decl nil domain nil)
    (RBExpr type-decl nil expressions nil)
    (RAExprDomain type-decl nil domain nil)
    (CEB type-eq-decl nil domain nil) (set type-eq-decl nil sets nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (every adt-def-decl "boolean" list_adt nil)
    (finite_nonempty? const-decl "bool" more_set_defs "sets_aux/")
    (Environment nonempty-type-eq-decl nil semantics nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (<< adt-def-decl "(strict_well_founded?[list])" list_adt nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (FtoR formal-const-decl "[FloatingPointNumber -> RealNumber]"
     semantics nil)
    (applyFun_fp formal-const-decl
     "[[Operator, FloatingPointNumber, FloatingPointNumber] ->
   FloatingPointNumber]" semantics nil)
    (lt_fp formal-const-decl
     "(strict_total_order?[FloatingPointNumber])" semantics nil)
    (FloatingPointNumber formal-nonempty-type-decl nil semantics nil)
    (applyFun_r formal-const-decl
     "[[Operator, RealNumber, RealNumber] -> RealNumber]" semantics
     nil)
    (lt_r formal-const-decl "(strict_total_order?[RealNumber])"
     semantics nil)
    (strict_total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (RealNumber formal-nonempty-type-decl nil semantics nil)
    (Operator formal-nonempty-type-decl nil semantics nil)
    (wellFormed? const-decl "bool" domain nil)
    (wellFormed? const-decl "bool" domain nil))
   nil))
 (wellFormed?_env_ext 0
  (wellFormed?_env_ext-1 nil 3754161850
   ("" (skeep :preds? t)
    (("" (expand "wellFormed?" 1) (("" (assert) nil nil)) nil)) nil)
   ((wellFormed? def-decl "bool" semantics nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil))
   shostak))
 (wellFormed?_decl 0
  (wellFormed?_decl-1 nil 3753467785
   ("" (skeep :but "env")
    (("" (induct "env")
      (("1" (flatten)
        (("1" (skeep :preds? t)
          (("1" (expand "length") (("1" (assert) nil nil)) nil)) nil))
        nil)
       ("2" (flatten)
        (("2" (expand "wellFormed?") (("2" (propax) nil nil)) nil))
        nil)
       ("3" (skolem 1 ("dom" "env"))
        (("3" (flatten)
          (("3" (expand "wellFormed?" 1 1)
            (("3" (split 1)
              (("1" (flatten)
                (("1" (assert)
                  (("1" (skeep :preds? t)
                    (("1" (expand "length" -1 1)
                      (("1" (case "i=0")
                        (("1" (replace -1 :hide? t)
                          (("1" (expand "nth") (("1" (propax) nil nil))
                            nil))
                          nil)
                         ("2" (inst -4 "i-1")
                          (("1" (expand "nth" 2)
                            (("1" (assert) nil nil)) nil)
                           ("2" (grind) nil nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("2" (flatten)
                (("2" (split 1)
                  (("1" (inst -1 "0")
                    (("1" (expand "nth") (("1" (propax) nil nil)) nil)
                     ("2" (grind) nil nil))
                    nil)
                   ("2" (assert)
                    (("2" (skeep)
                      (("2" (inst -1 "i+1")
                        (("1" (expand "nth" -1)
                          (("1" (propax) nil nil)) nil)
                         ("2" (grind) nil nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((list type-decl nil list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (every adt-def-decl "boolean" list_adt nil)
    (Environment nonempty-type-eq-decl nil semantics nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (wellFormed? def-decl "bool" semantics nil)
    (< const-decl "bool" reals nil)
    (length def-decl "nat" list_props nil)
    (below type-eq-decl nil naturalnumbers nil)
    (wellFormed? const-decl "bool" domain nil)
    (below type-eq-decl nil nat_types nil)
    (nth def-decl "T" list_props nil)
    (Domain type-eq-decl nil domain nil)
    (finite_nonempty? const-decl "bool" more_set_defs "sets_aux/")
    (set type-eq-decl nil sets nil) (CEB type-eq-decl nil domain nil)
    (RAExprDomain type-decl nil domain nil)
    (RBExpr type-decl nil expressions nil)
    (FPAExprDomain type-decl nil domain nil)
    (applyFun_fp formal-const-decl
     "[[Operator, FloatingPointNumber, FloatingPointNumber] ->
   FloatingPointNumber]" semantics nil)
    (lt_fp formal-const-decl
     "(strict_total_order?[FloatingPointNumber])" semantics nil)
    (applyFun_r formal-const-decl
     "[[Operator, RealNumber, RealNumber] -> RealNumber]" semantics
     nil)
    (lt_r formal-const-decl "(strict_total_order?[RealNumber])"
     semantics nil)
    (strict_total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (FPBExpr type-decl nil expressions nil)
    (FtoR formal-const-decl "[FloatingPointNumber -> RealNumber]"
     semantics nil)
    (FloatingPointNumber formal-nonempty-type-decl nil semantics nil)
    (RealNumber formal-nonempty-type-decl nil semantics nil)
    (Operator formal-nonempty-type-decl nil semantics nil)
    (list_induction formula-decl nil list_adt nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (dom skolem-const-decl "Domain
    [Operator, RealNumber, lt_r, applyFun_r, FloatingPointNumber, lt_fp,
     applyFun_fp, FtoR]" semantics nil)
    (env skolem-const-decl "list
    [Domain
         [Operator, RealNumber, lt_r, applyFun_r, FloatingPointNumber,
          lt_fp, applyFun_fp, FtoR]]" semantics nil)
    (i skolem-const-decl "below(length(cons(dom, env)))" semantics nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (i skolem-const-decl "below(length(env))" semantics nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields
       nil))
   shostak))
 (wellFormed?_env_monotonocity 0
  (wellFormed?_env_monotonocity-1 nil 3753467637
   ("" (skeep)
    (("" (skeep :preds? t)
      (("" (rewrite "wellFormed?_decl")
        (("" (rewrite "wellFormed?_decl")
          (("" (skeep :preds? t)
            (("" (inst -4 "i")
              ((""
                (rewrite
                 "wellFormed?_dom_iff_every_ceb_is_wellFormed?")
                ((""
                  (rewrite
                   "wellFormed?_dom_iff_every_ceb_is_wellFormed?")
                  (("" (skeep :preds? t)
                    (("" (inst -5 "ceb")
                      ((""
                        (rewrite
                         "wellFormed?_ceb_is_wellFormed?_fconds")
                        ((""
                          (rewrite
                           "wellFormed?_ceb_is_wellFormed?_fconds")
                          (("" (use "wellFormed?_motonocity")
                            (("" (assert)
                              (("" (inst? -1 :where 1) nil nil)) nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((upfrom nonempty-type-eq-decl nil integers nil)
    (< const-decl "bool" reals nil)
    (Domain type-eq-decl nil domain nil)
    (length def-decl "nat" list_props nil)
    (below type-eq-decl nil naturalnumbers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (wellFormed?_motonocity formula-decl nil expressions nil)
    (wellFormed?_ceb_is_wellFormed?_fconds formula-decl nil domain nil)
    (nth def-decl "T" list_props nil)
    (below type-eq-decl nil nat_types nil)
    (wellFormed?_dom_iff_every_ceb_is_wellFormed? formula-decl nil
     domain nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (Environment nonempty-type-eq-decl nil semantics nil)
    (finite_nonempty? const-decl "bool" more_set_defs "sets_aux/")
    (every adt-def-decl "boolean" list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil) (set type-eq-decl nil sets nil)
    (CEB type-eq-decl nil domain nil)
    (RAExprDomain type-decl nil domain nil)
    (RBExpr type-decl nil expressions nil)
    (FPAExprDomain type-decl nil domain nil)
    (applyFun_fp formal-const-decl
     "[[Operator, FloatingPointNumber, FloatingPointNumber] ->
   FloatingPointNumber]" semantics nil)
    (lt_fp formal-const-decl
     "(strict_total_order?[FloatingPointNumber])" semantics nil)
    (applyFun_r formal-const-decl
     "[[Operator, RealNumber, RealNumber] -> RealNumber]" semantics
     nil)
    (lt_r formal-const-decl "(strict_total_order?[RealNumber])"
     semantics nil)
    (strict_total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (FPBExpr type-decl nil expressions nil)
    (FtoR formal-const-decl "[FloatingPointNumber -> RealNumber]"
     semantics nil)
    (FloatingPointNumber formal-nonempty-type-decl nil semantics nil)
    (RealNumber formal-nonempty-type-decl nil semantics nil)
    (Operator formal-nonempty-type-decl nil semantics nil)
    (wellFormed?_decl formula-decl nil semantics nil))
   shostak))
 (maxFreeLocalIndex_TCC1 0
  (maxFreeLocalIndex_TCC1-1 nil 3753551600
   ("" (termination-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (Operator formal-nonempty-type-decl nil semantics nil)
    (RealNumber formal-nonempty-type-decl nil semantics nil)
    (FloatingPointNumber formal-nonempty-type-decl nil semantics nil)
    (FtoR formal-const-decl "[FloatingPointNumber -> RealNumber]"
     semantics nil)
    (FPBExpr type-decl nil expressions nil)
    (pred type-eq-decl nil defined_types nil)
    (strict_total_order? const-decl "bool" orders nil)
    (lt_r formal-const-decl "(strict_total_order?[RealNumber])"
     semantics nil)
    (applyFun_r formal-const-decl
     "[[Operator, RealNumber, RealNumber] -> RealNumber]" semantics
     nil)
    (lt_fp formal-const-decl
     "(strict_total_order?[FloatingPointNumber])" semantics nil)
    (applyFun_fp formal-const-decl
     "[[Operator, FloatingPointNumber, FloatingPointNumber] ->
   FloatingPointNumber]" semantics nil)
    (FPAExprDomain type-decl nil domain nil)
    (RBExpr type-decl nil expressions nil)
    (RAExprDomain type-decl nil domain nil)
    (CEB type-eq-decl nil domain nil) (set type-eq-decl nil sets nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (every adt-def-decl "boolean" list_adt nil)
    (finite_nonempty? const-decl "bool" more_set_defs "sets_aux/")
    (Environment nonempty-type-eq-decl nil semantics nil)
    (Domain type-eq-decl nil domain nil)
    (<< adt-def-decl "(strict_well_founded?[list])" list_adt nil)
    (nonempty? const-decl "bool" sets nil)
    (empty? const-decl "bool" sets nil)
    (member const-decl "bool" sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (injective? const-decl "bool" functions nil))
   nil))
 (maxFreeLocalIndex_TCC2 0
  (maxFreeLocalIndex_TCC2-1 nil 3753555564 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (Operator formal-nonempty-type-decl nil semantics nil)
    (RealNumber formal-nonempty-type-decl nil semantics nil)
    (FloatingPointNumber formal-nonempty-type-decl nil semantics nil)
    (FtoR formal-const-decl "[FloatingPointNumber -> RealNumber]"
     semantics nil)
    (FPBExpr type-decl nil expressions nil)
    (pred type-eq-decl nil defined_types nil)
    (strict_total_order? const-decl "bool" orders nil)
    (lt_r formal-const-decl "(strict_total_order?[RealNumber])"
     semantics nil)
    (applyFun_r formal-const-decl
     "[[Operator, RealNumber, RealNumber] -> RealNumber]" semantics
     nil)
    (lt_fp formal-const-decl
     "(strict_total_order?[FloatingPointNumber])" semantics nil)
    (applyFun_fp formal-const-decl
     "[[Operator, FloatingPointNumber, FloatingPointNumber] ->
   FloatingPointNumber]" semantics nil)
    (FPAExprDomain type-decl nil domain nil)
    (RBExpr type-decl nil expressions nil)
    (RAExprDomain type-decl nil domain nil)
    (CEB type-eq-decl nil domain nil) (set type-eq-decl nil sets nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (every adt-def-decl "boolean" list_adt nil)
    (finite_nonempty? const-decl "bool" more_set_defs "sets_aux/")
    (Environment nonempty-type-eq-decl nil semantics nil)
    (Domain type-eq-decl nil domain nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (minus_odd_is_odd application-judgement "odd_int" integers nil)
    (int_max application-judgement "{k: int | i <= k AND j <= k}"
     real_defs nil)
    (rat_max application-judgement "{s: rat | s >= q AND s >= r}"
     real_defs nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nonempty? const-decl "bool" sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (injective? const-decl "bool" functions nil)
    (member const-decl "bool" sets nil)
    (empty? const-decl "bool" sets nil))
   nil))
 (max_local_index_env_ge_dom 0
  (max_local_index_env_ge_dom-1 nil 3753604354
   ("" (induct-and-simplify "env") nil nil)
   ((list type-decl nil list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (every adt-def-decl "boolean" list_adt nil)
    (Environment nonempty-type-eq-decl nil semantics nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (member def-decl "bool" list_props nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (<= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (upfrom nonempty-type-eq-decl nil integers nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (maxFreeLocalIndex const-decl "upfrom(-1)" domain nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (maxFreeLocalIndex def-decl "{m: upfrom(-1) |
         (FORALL (ceb: (dom)): maxFreeLocalIndex(ceb) <= m) AND
          (EXISTS (ceb: (dom)): maxFreeLocalIndex(ceb) = m)}" domain
     nil)
    (maxFreeLocalIndex def-decl "upfrom(-1)" semantics nil)
    (Domain type-eq-decl nil domain nil)
    (finite_nonempty? const-decl "bool" more_set_defs "sets_aux/")
    (set type-eq-decl nil sets nil) (CEB type-eq-decl nil domain nil)
    (RAExprDomain type-decl nil domain nil)
    (RBExpr type-decl nil expressions nil)
    (FPAExprDomain type-decl nil domain nil)
    (applyFun_fp formal-const-decl
     "[[Operator, FloatingPointNumber, FloatingPointNumber] ->
   FloatingPointNumber]" semantics nil)
    (lt_fp formal-const-decl
     "(strict_total_order?[FloatingPointNumber])" semantics nil)
    (applyFun_r formal-const-decl
     "[[Operator, RealNumber, RealNumber] -> RealNumber]" semantics
     nil)
    (lt_r formal-const-decl "(strict_total_order?[RealNumber])"
     semantics nil)
    (strict_total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (FPBExpr type-decl nil expressions nil)
    (FtoR formal-const-decl "[FloatingPointNumber -> RealNumber]"
     semantics nil)
    (FloatingPointNumber formal-nonempty-type-decl nil semantics nil)
    (RealNumber formal-nonempty-type-decl nil semantics nil)
    (Operator formal-nonempty-type-decl nil semantics nil)
    (list_induction formula-decl nil list_adt nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (rat_max application-judgement "{s: rat | s >= q AND s >= r}"
     real_defs nil)
    (int_max application-judgement "{k: int | i <= k AND j <= k}"
     real_defs nil)
    (minus_odd_is_odd application-judgement "odd_int" integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (member const-decl "bool" sets nil)
    (empty? const-decl "bool" sets nil))
   shostak))
 (max_local_index_ceb_leq_max_local_index_env 0
  (max_local_index_ceb_leq_max_local_index_env-1 nil 3753604205
   ("" (skeep :preds? t)
    (("" (use "max_local_index_env_ge_dom")
      (("" (assert)
        (("" (use "max_local_index_dom_ge_ceb") (("" (assert) nil nil))
          nil))
        nil))
      nil))
    nil)
   ((max_local_index_env_ge_dom formula-decl nil semantics nil)
    (member def-decl "bool" list_props nil)
    (Domain type-eq-decl nil domain nil)
    (Environment nonempty-type-eq-decl nil semantics nil)
    (finite_nonempty? const-decl "bool" more_set_defs "sets_aux/")
    (every adt-def-decl "boolean" list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil) (set type-eq-decl nil sets nil)
    (CEB type-eq-decl nil domain nil)
    (RAExprDomain type-decl nil domain nil)
    (RBExpr type-decl nil expressions nil)
    (FPAExprDomain type-decl nil domain nil)
    (applyFun_fp formal-const-decl
     "[[Operator, FloatingPointNumber, FloatingPointNumber] ->
   FloatingPointNumber]" semantics nil)
    (lt_fp formal-const-decl
     "(strict_total_order?[FloatingPointNumber])" semantics nil)
    (applyFun_r formal-const-decl
     "[[Operator, RealNumber, RealNumber] -> RealNumber]" semantics
     nil)
    (lt_r formal-const-decl "(strict_total_order?[RealNumber])"
     semantics nil)
    (strict_total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (FPBExpr type-decl nil expressions nil)
    (FtoR formal-const-decl "[FloatingPointNumber -> RealNumber]"
     semantics nil)
    (FloatingPointNumber formal-nonempty-type-decl nil semantics nil)
    (RealNumber formal-nonempty-type-decl nil semantics nil)
    (Operator formal-nonempty-type-decl nil semantics nil)
    (max_local_index_dom_ge_ceb formula-decl nil domain nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil))
   shostak))
 (max_local_index_env_def 0
  (max_local_index_env_def-1 nil 3753551660
   ("" (expand "maxFreeLocalIndex" 1 1) (("" (propax) nil nil)) nil)
   ((maxFreeLocalIndex def-decl "upfrom(-1)" semantics nil)) shostak))
 (maxParamIndex_TCC1 0
  (maxParamIndex_TCC1-1 nil 3754998329 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (Operator formal-nonempty-type-decl nil semantics nil)
    (RealNumber formal-nonempty-type-decl nil semantics nil)
    (FloatingPointNumber formal-nonempty-type-decl nil semantics nil)
    (FtoR formal-const-decl "[FloatingPointNumber -> RealNumber]"
     semantics nil)
    (FPBExpr type-decl nil expressions nil)
    (pred type-eq-decl nil defined_types nil)
    (strict_total_order? const-decl "bool" orders nil)
    (lt_r formal-const-decl "(strict_total_order?[RealNumber])"
     semantics nil)
    (applyFun_r formal-const-decl
     "[[Operator, RealNumber, RealNumber] -> RealNumber]" semantics
     nil)
    (lt_fp formal-const-decl
     "(strict_total_order?[FloatingPointNumber])" semantics nil)
    (applyFun_fp formal-const-decl
     "[[Operator, FloatingPointNumber, FloatingPointNumber] ->
   FloatingPointNumber]" semantics nil)
    (FPAExprDomain type-decl nil domain nil)
    (RBExpr type-decl nil expressions nil)
    (RAExprDomain type-decl nil domain nil)
    (CEB type-eq-decl nil domain nil) (set type-eq-decl nil sets nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (every adt-def-decl "boolean" list_adt nil)
    (finite_nonempty? const-decl "bool" more_set_defs "sets_aux/")
    (Environment nonempty-type-eq-decl nil semantics nil)
    (Domain type-eq-decl nil domain nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (minus_odd_is_odd application-judgement "odd_int" integers nil)
    (int_max application-judgement "{k: int | i <= k AND j <= k}"
     real_defs nil)
    (rat_max application-judgement "{s: rat | s >= q AND s >= r}"
     real_defs nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nonempty? const-decl "bool" sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (injective? const-decl "bool" functions nil)
    (member const-decl "bool" sets nil)
    (empty? const-decl "bool" sets nil))
   nil))
 (max_local_index_env_well_formed_eq 0
  (max_local_index_env_well_formed_eq-1 nil 3754997176
   ("" (skeep 1 :but "env")
    (("" (induct "env")
      (("1" (expand "maxFreeLocalIndex")
        (("1" (expand "maxParamIndex")
          (("1" (expand "wellFormed?") (("1" (propax) nil nil)) nil))
          nil))
        nil)
       ("2" (skolem 1 ("dom" "env"))
        (("2" (flatten)
          (("2" (expand "wellFormed?" 1)
            (("2" (replace -1 :hide? t :dir rl)
              (("2" (expand "maxFreeLocalIndex" 1 1)
                (("2" (expand "maxParamIndex" 1 1)
                  (("2" (rewrite "wellFormed?_dom_int_def")
                    (("2" (grind) nil nil)) nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((list type-decl nil list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (every adt-def-decl "boolean" list_adt nil)
    (Environment nonempty-type-eq-decl nil semantics nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (upfrom nonempty-type-eq-decl nil integers nil)
    (maxFreeLocalIndex def-decl "upfrom(-1)" semantics nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (maxParamIndex def-decl "upfrom(-1)" semantics nil)
    (wellFormed? def-decl "bool" semantics nil)
    (Domain type-eq-decl nil domain nil)
    (finite_nonempty? const-decl "bool" more_set_defs "sets_aux/")
    (set type-eq-decl nil sets nil) (CEB type-eq-decl nil domain nil)
    (RAExprDomain type-decl nil domain nil)
    (RBExpr type-decl nil expressions nil)
    (FPAExprDomain type-decl nil domain nil)
    (applyFun_fp formal-const-decl
     "[[Operator, FloatingPointNumber, FloatingPointNumber] ->
   FloatingPointNumber]" semantics nil)
    (lt_fp formal-const-decl
     "(strict_total_order?[FloatingPointNumber])" semantics nil)
    (applyFun_r formal-const-decl
     "[[Operator, RealNumber, RealNumber] -> RealNumber]" semantics
     nil)
    (lt_r formal-const-decl "(strict_total_order?[RealNumber])"
     semantics nil)
    (strict_total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (FPBExpr type-decl nil expressions nil)
    (FtoR formal-const-decl "[FloatingPointNumber -> RealNumber]"
     semantics nil)
    (FloatingPointNumber formal-nonempty-type-decl nil semantics nil)
    (RealNumber formal-nonempty-type-decl nil semantics nil)
    (Operator formal-nonempty-type-decl nil semantics nil)
    (list_induction formula-decl nil list_adt nil)
    (max const-decl "{p: real | p >= m AND p >= n}" real_defs nil)
    (empty? const-decl "bool" sets nil)
    (member const-decl "bool" sets nil)
    (minus_odd_is_odd application-judgement "odd_int" integers nil)
    (int_max application-judgement "{k: int | i <= k AND j <= k}"
     real_defs nil)
    (rat_max application-judgement "{s: rat | s >= q AND s >= r}"
     real_defs nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (wellFormed?_dom_int_def formula-decl nil domain nil))
   shostak))
 (stableConsistent?_TCC1 0
  (stableConsistent?_TCC1-1 nil 3752417903 ("" (subtype-tcc) nil nil)
   nil nil))
 (stableConsistent?_TCC2 0
  (stableConsistent?_TCC2-1 nil 3752417903 ("" (subtype-tcc) nil nil)
   nil nil))
 (cartesian_product_elem_set_TCC1 0
  (cartesian_product_elem_set_TCC1-1 nil 3753702385
   ("" (assert) nil nil) nil nil))
 (cartesian_product_elem_set_TCC2 0
  (cartesian_product_elem_set_TCC2-1 nil 3753702385 ("" (tcc) nil nil)
   ((nth def-decl "T" list_props nil)) nil))
 (cartesian_product_elem_set_TCC3 0
  (cartesian_product_elem_set_TCC3-1 nil 3753702385
   ("" (skeep)
    (("" (expand "singleton")
      (("" (expand "makePairCEB")
        (("" (expand "member")
          (("" (case "singleton?(dom)")
            (("1" (apply-extensionality 1)
              (("1" (hide 2)
                (("1" (iff)
                  (("1" (split 1)
                    (("1" (grind) nil nil)
                     ("2" (flatten)
                      (("2" (grind)
                        (("2" (apply-extensionality)
                          (("2" (typepred "x!1")
                            (("2" (apply-extensionality)
                              (("2"
                                (hide-all-but (-1 1))
                                (("2"
                                  (expand "length")
                                  (("2"
                                    (lift-if -1)
                                    (("2"
                                      (grind)
                                      (("2"
                                        (expand "length")
                                        (("2" (grind) nil nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("2" (hide 2) (("2" (grind) nil nil)) nil))
              nil)
             ("2" (hide 2)
              (("2" (typepred "dom") (("2" (grind) nil nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((singleton const-decl "(singleton?)" sets nil)
    (member const-decl "bool" sets nil)
    (injective? const-decl "bool" functions nil)
    (is_finite const-decl "bool" finite_sets nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (list type-decl nil list_adt nil)
    (number nonempty-type-decl nil numbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (length def-decl "nat" list_props nil)
    (PairCEB nonempty-type-eq-decl nil semantics nil)
    (nth def-decl "T" list_props nil)
    (below type-eq-decl nil nat_types nil)
    (< const-decl "bool" reals nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (ceb skolem-const-decl "CEB
    [Operator, RealNumber, lt_r, applyFun_r, FloatingPointNumber, lt_fp,
     applyFun_fp, FtoR]" semantics nil)
    (nonempty? const-decl "bool" sets nil)
    (choose const-decl "(p)" sets nil)
    (dom skolem-const-decl "Domain
    [Operator, RealNumber, lt_r, applyFun_r, FloatingPointNumber, lt_fp,
     applyFun_fp, FtoR]" semantics nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (finite_rest application-judgement "finite_set" finite_sets nil)
    (list_cons_extensionality formula-decl nil list_adt nil)
    (nil application-judgement "above(1)" semantics nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (car adt-accessor-decl "[(cons?) -> T]" list_adt nil)
    (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil)
    (remove const-decl "set" sets nil)
    (/= const-decl "boolean" notequal nil)
    (rest const-decl "set" sets nil)
    (empty? const-decl "bool" sets nil)
    (Operator formal-nonempty-type-decl nil semantics nil)
    (RealNumber formal-nonempty-type-decl nil semantics nil)
    (FloatingPointNumber formal-nonempty-type-decl nil semantics nil)
    (FtoR formal-const-decl "[FloatingPointNumber -> RealNumber]"
     semantics nil)
    (FPBExpr type-decl nil expressions nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (pred type-eq-decl nil defined_types nil)
    (strict_total_order? const-decl "bool" orders nil)
    (lt_r formal-const-decl "(strict_total_order?[RealNumber])"
     semantics nil)
    (applyFun_r formal-const-decl
     "[[Operator, RealNumber, RealNumber] -> RealNumber]" semantics
     nil)
    (lt_fp formal-const-decl
     "(strict_total_order?[FloatingPointNumber])" semantics nil)
    (applyFun_fp formal-const-decl
     "[[Operator, FloatingPointNumber, FloatingPointNumber] ->
   FloatingPointNumber]" semantics nil)
    (FPAExprDomain type-decl nil domain nil)
    (RBExpr type-decl nil expressions nil)
    (RAExprDomain type-decl nil domain nil)
    (CEB type-eq-decl nil domain nil) (set type-eq-decl nil sets nil)
    (singleton? const-decl "bool" sets nil)
    (finite_nonempty? const-decl "bool" more_set_defs "sets_aux/")
    (Domain type-eq-decl nil domain nil)
    (makePairCEB const-decl "PairCEB" semantics nil))
   nil))
 (cartesian_product_elem_set_TCC4 0
  (cartesian_product_elem_set_TCC4-1 nil 3753702385
   ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (Operator formal-nonempty-type-decl nil semantics nil)
    (RealNumber formal-nonempty-type-decl nil semantics nil)
    (FloatingPointNumber formal-nonempty-type-decl nil semantics nil)
    (FtoR formal-const-decl "[FloatingPointNumber -> RealNumber]"
     semantics nil)
    (FPBExpr type-decl nil expressions nil)
    (pred type-eq-decl nil defined_types nil)
    (strict_total_order? const-decl "bool" orders nil)
    (lt_r formal-const-decl "(strict_total_order?[RealNumber])"
     semantics nil)
    (applyFun_r formal-const-decl
     "[[Operator, RealNumber, RealNumber] -> RealNumber]" semantics
     nil)
    (lt_fp formal-const-decl
     "(strict_total_order?[FloatingPointNumber])" semantics nil)
    (applyFun_fp formal-const-decl
     "[[Operator, FloatingPointNumber, FloatingPointNumber] ->
   FloatingPointNumber]" semantics nil)
    (FPAExprDomain type-decl nil domain nil)
    (RBExpr type-decl nil expressions nil)
    (RAExprDomain type-decl nil domain nil)
    (CEB type-eq-decl nil domain nil) (set type-eq-decl nil sets nil)
    (Domain type-eq-decl nil domain nil)
    (member const-decl "bool" sets nil)
    (empty? const-decl "bool" sets nil)
    (nonempty? const-decl "bool" sets nil)
    (finite_nonempty? const-decl "bool" more_set_defs "sets_aux/")
    (finite_rest application-judgement "finite_set" finite_sets nil))
   nil))
 (cartesian_product_elem_set_TCC5 0
  (cartesian_product_elem_set_TCC5-1 nil 3753702385
   ("" (skeep :preds? t)
    (("" (rewrite "card_rest[CEB]")
      (("1" (assert) nil nil) ("2" (subtype-tcc) nil nil)) nil))
    nil)
   ((card_rest formula-decl nil finite_sets nil)
    (set type-eq-decl nil sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (finite_nonempty? const-decl "bool" more_set_defs "sets_aux/")
    (Domain type-eq-decl nil domain nil)
    (Operator formal-nonempty-type-decl nil semantics nil)
    (RealNumber formal-nonempty-type-decl nil semantics nil)
    (FloatingPointNumber formal-nonempty-type-decl nil semantics nil)
    (FtoR formal-const-decl "[FloatingPointNumber -> RealNumber]"
     semantics nil)
    (FPBExpr type-decl nil expressions nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (pred type-eq-decl nil defined_types nil)
    (strict_total_order? const-decl "bool" orders nil)
    (lt_r formal-const-decl "(strict_total_order?[RealNumber])"
     semantics nil)
    (applyFun_r formal-const-decl
     "[[Operator, RealNumber, RealNumber] -> RealNumber]" semantics
     nil)
    (lt_fp formal-const-decl
     "(strict_total_order?[FloatingPointNumber])" semantics nil)
    (applyFun_fp formal-const-decl
     "[[Operator, FloatingPointNumber, FloatingPointNumber] ->
   FloatingPointNumber]" semantics nil)
    (FPAExprDomain type-decl nil domain nil)
    (RBExpr type-decl nil expressions nil)
    (RAExprDomain type-decl nil domain nil)
    (CEB type-eq-decl nil domain nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (finite_rest application-judgement "finite_set" finite_sets nil)
    (nonempty? const-decl "bool" sets nil)
    (injective? const-decl "bool" functions nil)
    (empty? const-decl "bool" sets nil)
    (member const-decl "bool" sets nil))
   nil))
 (cartesian_product_elem_set_TCC6 0
  (cartesian_product_elem_set_TCC6-1 nil 3753702385
   ("" (skeep :preds? t)
    (("" (apply-extensionality)
      (("1" (hide 3)
        (("1" (expand "add")
          (("1" (expand "makePairCEB")
            (("1" (expand "member")
              (("1"
                (case "(: ceb,
                   choose
                       [CEB
                            [Operator, RealNumber, lt_r, applyFun_r,
                             FloatingPointNumber, lt_fp, applyFun_fp, FtoR]]
                       (dom) :)
                 = x!1")
                (("1" (assert)
                  (("1" (replace -1 :hide? t :dir rl)
                    (("1" (expand "nth")
                      (("1" (expand "nth") (("1" (propax) nil nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (assert)
                  (("2" (invoke (typepred "%1") (! 2 1 0))
                    (("1" (replace -2 :hide? t)
                      (("1" (assert)
                        (("1" (expand "member")
                          (("1" (iff 2)
                            (("1" (split 2)
                              (("1"
                                (flatten)
                                (("1"
                                  (assert)
                                  (("1"
                                    (lemma "rest_member[CEB]")
                                    (("1"
                                      (inst -1 "dom" "nth(x!1, 1)")
                                      (("1"
                                        (expand "member")
                                        (("1" (propax) nil nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil)
                               ("2"
                                (flatten)
                                (("2"
                                  (assert)
                                  (("2"
                                    (lemma "choose_rest_or[CEB]")
                                    (("2"
                                      (inst -1 "dom" "nth(x!1, 1)")
                                      (("2"
                                        (expand "member")
                                        (("2"
                                          (apply-extensionality 2)
                                          (("1"
                                            (expand "nth")
                                            (("1" (assert) nil nil))
                                            nil)
                                           ("2"
                                            (expand "nth")
                                            (("2"
                                              (expand "nth")
                                              (("2"
                                                (hide-all-but (-1 1))
                                                (("2"
                                                  (typepred "x!1")
                                                  (("2"
                                                    (expand "length")
                                                    (("2"
                                                      (lift-if -1)
                                                      (("2"
                                                        (split -1)
                                                        (("1"
                                                          (assert)
                                                          nil
                                                          nil)
                                                         ("2"
                                                          (flatten)
                                                          (("2"
                                                            (expand
                                                             "length")
                                                            (("2"
                                                              (lift-if
                                                               -1)
                                                              (("2"
                                                                (split
                                                                 -1)
                                                                (("1"
                                                                  (assert)
                                                                  nil
                                                                  nil)
                                                                 ("2"
                                                                  (flatten)
                                                                  (("2"
                                                                    (expand
                                                                     "length")
                                                                    (("2"
                                                                      (lift-if
                                                                       -1)
                                                                      (("2"
                                                                        (split
                                                                         -1)
                                                                        (("1"
                                                                          (apply-extensionality
                                                                           3)
                                                                          (("1"
                                                                            (grind)
                                                                            nil
                                                                            nil))
                                                                          nil)
                                                                         ("2"
                                                                          (flatten)
                                                                          (("2"
                                                                            (assert)
                                                                            nil
                                                                            nil))
                                                                          nil))
                                                                        nil))
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil)
                                           ("3"
                                            (typepred "x!1")
                                            (("3"
                                              (hide-all-but (-1 1))
                                              (("3" (grind) nil nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil)
                     ("2" (subtype-tcc) nil nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (subtype-tcc) nil nil))
      nil))
    nil)
   ((Operator formal-nonempty-type-decl nil semantics nil)
    (RealNumber formal-nonempty-type-decl nil semantics nil)
    (FloatingPointNumber formal-nonempty-type-decl nil semantics nil)
    (FtoR formal-const-decl "[FloatingPointNumber -> RealNumber]"
     semantics nil)
    (FPBExpr type-decl nil expressions nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (pred type-eq-decl nil defined_types nil)
    (strict_total_order? const-decl "bool" orders nil)
    (lt_r formal-const-decl "(strict_total_order?[RealNumber])"
     semantics nil)
    (applyFun_r formal-const-decl
     "[[Operator, RealNumber, RealNumber] -> RealNumber]" semantics
     nil)
    (lt_fp formal-const-decl
     "(strict_total_order?[FloatingPointNumber])" semantics nil)
    (applyFun_fp formal-const-decl
     "[[Operator, FloatingPointNumber, FloatingPointNumber] ->
   FloatingPointNumber]" semantics nil)
    (FPAExprDomain type-decl nil domain nil)
    (RBExpr type-decl nil expressions nil)
    (RAExprDomain type-decl nil domain nil)
    (CEB type-eq-decl nil domain nil) (list type-decl nil list_adt nil)
    (number nonempty-type-decl nil numbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (length def-decl "nat" list_props nil)
    (PairCEB nonempty-type-eq-decl nil semantics nil)
    (set type-eq-decl nil sets nil) (member const-decl "bool" sets nil)
    (nth def-decl "T" list_props nil)
    (below type-eq-decl nil nat_types nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (card const-decl "{n: nat | n = Card(S)}" finite_sets nil)
    (Card const-decl "nat" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (< const-decl "bool" reals nil) (choose const-decl "(p)" sets nil)
    (makePairCEB const-decl "PairCEB" semantics nil)
    (add const-decl "(nonempty?)" sets nil)
    (nonempty? const-decl "bool" sets nil)
    (dom skolem-const-decl "Domain
    [Operator, RealNumber, lt_r, applyFun_r, FloatingPointNumber, lt_fp,
     applyFun_fp, FtoR]" semantics nil)
    (Domain type-eq-decl nil domain nil)
    (rest const-decl "set" sets nil)
    (finite_nonempty? const-decl "bool" more_set_defs "sets_aux/")
    (finite_rest application-judgement "finite_set" finite_sets nil)
    (nonempty_add_finite application-judgement "non_empty_finite_set"
     finite_sets nil)
    (finite_nonempty?_add application-judgement "(finite_nonempty?)"
     more_set_defs "sets_aux/")
    (empty? const-decl "bool" sets nil)
    (rest_member formula-decl nil sets_lemmas nil)
    (list_cons_extensionality formula-decl nil list_adt nil)
    (x!1 skolem-const-decl "PairCEB" semantics nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil)
    (nil application-judgement "above(1)" semantics nil)
    (choose_rest_or formula-decl nil sets_lemmas nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (every adt-def-decl "boolean" list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil))
   nil))
 (cartesian_product_TCC1 0
  (cartesian_product_TCC1-1 nil 3731411566 ("" (subtype-tcc) nil nil)
   nil nil))
 (cartesian_product_TCC2 0
  (cartesian_product_TCC2-1 nil 3753709395 ("" (subtype-tcc) nil nil)
   ((member const-decl "bool" sets nil)) nil))
 (cartesian_product_TCC3 0
  (cartesian_product_TCC3-1 nil 3753709395
   ("" (skeep)
    (("" (invoke (typepred "%1") (! 1 1))
      (("" (replace -2 :hide? t)
        (("" (expand "member")
          (("" (assert)
            (("" (apply-extensionality)
              (("" (hide 2)
                (("" (iff)
                  (("" (split 1)
                    (("1" (flatten) (("1" (grind) nil nil)) nil)
                     ("2" (flatten) (("2" (grind) nil nil)) nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (Operator formal-nonempty-type-decl nil semantics nil)
    (RealNumber formal-nonempty-type-decl nil semantics nil)
    (FloatingPointNumber formal-nonempty-type-decl nil semantics nil)
    (FtoR formal-const-decl "[FloatingPointNumber -> RealNumber]"
     semantics nil)
    (FPBExpr type-decl nil expressions nil)
    (pred type-eq-decl nil defined_types nil)
    (strict_total_order? const-decl "bool" orders nil)
    (lt_r formal-const-decl "(strict_total_order?[RealNumber])"
     semantics nil)
    (applyFun_r formal-const-decl
     "[[Operator, RealNumber, RealNumber] -> RealNumber]" semantics
     nil)
    (lt_fp formal-const-decl
     "(strict_total_order?[FloatingPointNumber])" semantics nil)
    (applyFun_fp formal-const-decl
     "[[Operator, FloatingPointNumber, FloatingPointNumber] ->
   FloatingPointNumber]" semantics nil)
    (FPAExprDomain type-decl nil domain nil)
    (RBExpr type-decl nil expressions nil)
    (RAExprDomain type-decl nil domain nil)
    (CEB type-eq-decl nil domain nil) (list type-decl nil list_adt nil)
    (number nonempty-type-decl nil numbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (length def-decl "nat" list_props nil)
    (PairCEB nonempty-type-eq-decl nil semantics nil)
    (set type-eq-decl nil sets nil)
    (finite_nonempty? const-decl "bool" more_set_defs "sets_aux/")
    (Domain type-eq-decl nil domain nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (< const-decl "bool" reals nil)
    (below type-eq-decl nil nat_types nil)
    (nth def-decl "T" list_props nil)
    (member const-decl "bool" sets nil)
    (cartesian_product_elem_set def-decl
     "{fne | fne = ({p: PairCEB | nth(p, 0) = ceb AND member(nth(p, 1), dom)})}"
     semantics nil)
    (nonempty? const-decl "bool" sets nil)
    (choose const-decl "(p)" sets nil)
    (injective? const-decl "bool" functions nil)
    (is_finite const-decl "bool" finite_sets nil)
    (empty? const-decl "bool" sets nil)
    (rest const-decl "set" sets nil)
    (/= const-decl "boolean" notequal nil)
    (remove const-decl "set" sets nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (nil application-judgement "above(1)" semantics nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (car adt-accessor-decl "[(cons?) -> T]" list_adt nil)
    (finite_rest application-judgement "finite_set" finite_sets nil))
   nil))
 (cartesian_product_TCC4 0
  (cartesian_product_TCC4-1 nil 3753709852
   ("" (skeep :preds? t)
    (("" (invoke (typepred "%1") (! 2 1 1))
      (("" (replace -2 :hide? t)
        (("" (expand "union")
          (("" (expand "member")
            ((""
              (typepred "v(rest
                 [CEB
                      [Operator, RealNumber, lt_r, applyFun_r,
                       FloatingPointNumber, lt_fp, applyFun_fp, FtoR]]
                 (dom1),
             dom2)")
              (("1" (replace -2 :hide? t)
                (("1" (apply-extensionality)
                  (("1" (hide 3)
                    (("1" (iff)
                      (("1" (split)
                        (("1" (flatten) (("1" (grind) nil nil)) nil)
                         ("2" (flatten) (("2" (grind) nil nil)) nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("2" (rewrite "card_rest[CEB]")
                (("1" (assert) nil nil) ("2" (subtype-tcc) nil nil))
                nil)
               ("3" (subtype-tcc) nil nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (Operator formal-nonempty-type-decl nil semantics nil)
    (RealNumber formal-nonempty-type-decl nil semantics nil)
    (FloatingPointNumber formal-nonempty-type-decl nil semantics nil)
    (FtoR formal-const-decl "[FloatingPointNumber -> RealNumber]"
     semantics nil)
    (FPBExpr type-decl nil expressions nil)
    (pred type-eq-decl nil defined_types nil)
    (strict_total_order? const-decl "bool" orders nil)
    (lt_r formal-const-decl "(strict_total_order?[RealNumber])"
     semantics nil)
    (applyFun_r formal-const-decl
     "[[Operator, RealNumber, RealNumber] -> RealNumber]" semantics
     nil)
    (lt_fp formal-const-decl
     "(strict_total_order?[FloatingPointNumber])" semantics nil)
    (applyFun_fp formal-const-decl
     "[[Operator, FloatingPointNumber, FloatingPointNumber] ->
   FloatingPointNumber]" semantics nil)
    (FPAExprDomain type-decl nil domain nil)
    (RBExpr type-decl nil expressions nil)
    (RAExprDomain type-decl nil domain nil)
    (CEB type-eq-decl nil domain nil) (list type-decl nil list_adt nil)
    (number nonempty-type-decl nil numbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (length def-decl "nat" list_props nil)
    (PairCEB nonempty-type-eq-decl nil semantics nil)
    (set type-eq-decl nil sets nil)
    (finite_nonempty? const-decl "bool" more_set_defs "sets_aux/")
    (Domain type-eq-decl nil domain nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (< const-decl "bool" reals nil)
    (below type-eq-decl nil nat_types nil)
    (nth def-decl "T" list_props nil)
    (member const-decl "bool" sets nil)
    (cartesian_product_elem_set def-decl
     "{fne | fne = ({p: PairCEB | nth(p, 0) = ceb AND member(nth(p, 1), dom)})}"
     semantics nil)
    (nonempty? const-decl "bool" sets nil)
    (choose const-decl "(p)" sets nil)
    (union const-decl "set" sets nil) (rest const-decl "set" sets nil)
    (card const-decl "{n: nat | n = Card(S)}" finite_sets nil)
    (Card const-decl "nat" finite_sets nil)
    (finite_set type-eq-decl nil finite_sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (finite_rest application-judgement "finite_set" finite_sets nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (injective? const-decl "bool" functions nil)
    (empty? const-decl "bool" sets nil)
    (/= const-decl "boolean" notequal nil)
    (remove const-decl "set" sets nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (card_rest formula-decl nil finite_sets nil))
   nil))
 (cartesian_product_intensional_def 0
  (cartesian_product_intensional_def-1 nil 3753709406
   ("" (skeep :preds? t)
    (("" (typepred "cartesian_product(dom1, dom2)")
      (("" (propax) nil nil)) nil))
    nil)
   ((cartesian_product def-decl "{fne |
         fne =
          ({p: PairCEB |
              member(nth(p, 0), dom1) AND member(nth(p, 1), dom2)})}"
     semantics nil)
    (nth def-decl "T" list_props nil)
    (below type-eq-decl nil nat_types nil)
    (< const-decl "bool" reals nil) (member const-decl "bool" sets nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (Domain type-eq-decl nil domain nil)
    (finite_nonempty? const-decl "bool" more_set_defs "sets_aux/")
    (set type-eq-decl nil sets nil)
    (PairCEB nonempty-type-eq-decl nil semantics nil)
    (length def-decl "nat" list_props nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number nonempty-type-decl nil numbers nil)
    (list type-decl nil list_adt nil) (CEB type-eq-decl nil domain nil)
    (RAExprDomain type-decl nil domain nil)
    (RBExpr type-decl nil expressions nil)
    (FPAExprDomain type-decl nil domain nil)
    (applyFun_fp formal-const-decl
     "[[Operator, FloatingPointNumber, FloatingPointNumber] ->
   FloatingPointNumber]" semantics nil)
    (lt_fp formal-const-decl
     "(strict_total_order?[FloatingPointNumber])" semantics nil)
    (applyFun_r formal-const-decl
     "[[Operator, RealNumber, RealNumber] -> RealNumber]" semantics
     nil)
    (lt_r formal-const-decl "(strict_total_order?[RealNumber])"
     semantics nil)
    (strict_total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (FPBExpr type-decl nil expressions nil)
    (FtoR formal-const-decl "[FloatingPointNumber -> RealNumber]"
     semantics nil)
    (FloatingPointNumber formal-nonempty-type-decl nil semantics nil)
    (RealNumber formal-nonempty-type-decl nil semantics nil)
    (Operator formal-nonempty-type-decl nil semantics nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil))
   shostak))
 (conditionsHold?_TCC1 0
  (conditionsHold?_TCC1-1 nil 3752417903 ("" (subtype-tcc) nil nil) nil
   nil))
 (conditionsHold?_TCC2 0
  (conditionsHold?_TCC2-1 nil 3752417903 ("" (subtype-tcc) nil nil) nil
   nil))
 (valid_domain_assures_conditions_hold 0
  (valid_domain_assures_conditions_hold-1 nil 3732697641
   ("" (skeep :preds? t)
    (("" (expand "validDomain") (("" (flatten) nil nil)) nil)) nil)
   ((validDomain const-decl "bool" semantics nil)) shostak))
 (valid_domain_assures_bottomless 0
  (valid_domain_assures_bottomless-1 nil 3732700159
   ("" (grind) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (Operator formal-nonempty-type-decl nil semantics nil)
    (RealNumber formal-nonempty-type-decl nil semantics nil)
    (FloatingPointNumber formal-nonempty-type-decl nil semantics nil)
    (FtoR formal-const-decl "[FloatingPointNumber -> RealNumber]"
     semantics nil)
    (FPBExpr type-decl nil expressions nil)
    (pred type-eq-decl nil defined_types nil)
    (strict_total_order? const-decl "bool" orders nil)
    (lt_r formal-const-decl "(strict_total_order?[RealNumber])"
     semantics nil)
    (applyFun_r formal-const-decl
     "[[Operator, RealNumber, RealNumber] -> RealNumber]" semantics
     nil)
    (lt_fp formal-const-decl
     "(strict_total_order?[FloatingPointNumber])" semantics nil)
    (applyFun_fp formal-const-decl
     "[[Operator, FloatingPointNumber, FloatingPointNumber] ->
   FloatingPointNumber]" semantics nil)
    (FPAExprDomain type-decl nil domain nil)
    (RBExpr type-decl nil expressions nil)
    (RAExprDomain type-decl nil domain nil)
    (CEB type-eq-decl nil domain nil) (set type-eq-decl nil sets nil)
    (finite_nonempty? const-decl "bool" more_set_defs "sets_aux/")
    (Domain type-eq-decl nil domain nil)
    (validDomain const-decl "bool" semantics nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (>= const-decl "bool" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (injective? const-decl "bool" functions nil)
    (is_finite const-decl "bool" finite_sets nil)
    (member const-decl "bool" sets nil)
    (empty? const-decl "bool" sets nil)
    (nonempty? const-decl "bool" sets nil)
    (stable? const-decl "bool" semantics nil)
    (conditionsHold? const-decl "bool" semantics nil)
    (conditionsHold? const-decl "bool" semantics nil)
    (appears? const-decl "bool" expressions nil)
    (FtoR def-decl "RAExpr" expressions nil)
    (appears? const-decl "bool" expressions nil)
    (appears? const-decl "bool" domain nil)
    (appears? const-decl "bool" domain nil)
    (/= const-decl "boolean" notequal nil)
    (bottomLess? const-decl "bool" semantics nil)
    (bottomLess? const-decl "bool" semantics nil))
   shostak))
 (valid_domain_assures_stable 0
  (valid_domain_assures_stable-1 nil 3732700162 ("" (grind) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (Operator formal-nonempty-type-decl nil semantics nil)
    (RealNumber formal-nonempty-type-decl nil semantics nil)
    (FloatingPointNumber formal-nonempty-type-decl nil semantics nil)
    (FtoR formal-const-decl "[FloatingPointNumber -> RealNumber]"
     semantics nil)
    (FPBExpr type-decl nil expressions nil)
    (pred type-eq-decl nil defined_types nil)
    (strict_total_order? const-decl "bool" orders nil)
    (lt_r formal-const-decl "(strict_total_order?[RealNumber])"
     semantics nil)
    (applyFun_r formal-const-decl
     "[[Operator, RealNumber, RealNumber] -> RealNumber]" semantics
     nil)
    (lt_fp formal-const-decl
     "(strict_total_order?[FloatingPointNumber])" semantics nil)
    (applyFun_fp formal-const-decl
     "[[Operator, FloatingPointNumber, FloatingPointNumber] ->
   FloatingPointNumber]" semantics nil)
    (FPAExprDomain type-decl nil domain nil)
    (RBExpr type-decl nil expressions nil)
    (RAExprDomain type-decl nil domain nil)
    (CEB type-eq-decl nil domain nil) (set type-eq-decl nil sets nil)
    (finite_nonempty? const-decl "bool" more_set_defs "sets_aux/")
    (Domain type-eq-decl nil domain nil)
    (validDomain const-decl "bool" semantics nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (>= const-decl "bool" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (injective? const-decl "bool" functions nil)
    (is_finite const-decl "bool" finite_sets nil)
    (member const-decl "bool" sets nil)
    (empty? const-decl "bool" sets nil)
    (nonempty? const-decl "bool" sets nil)
    (/= const-decl "boolean" notequal nil)
    (bottomLess? const-decl "bool" semantics nil)
    (bottomLess? const-decl "bool" semantics nil)
    (conditionsHold? const-decl "bool" semantics nil)
    (conditionsHold? const-decl "bool" semantics nil)
    (appears? const-decl "bool" expressions nil)
    (FtoR def-decl "RAExpr" expressions nil)
    (appears? const-decl "bool" expressions nil)
    (appears? const-decl "bool" domain nil)
    (appears? const-decl "bool" domain nil)
    (stable? const-decl "bool" semantics nil))
   shostak))
 (valid_domain__ceb_stable 0
  (valid_domain__ceb_stable-1 nil 3732700087
   ("" (skeep :preds? t)
    (("" (lemma "valid_domain_assures_stable")
      (("" (inst -1 "dom")
        (("" (expand "stable?" -1) (("" (inst -1 "ceb") nil nil)) nil))
        nil))
      nil))
    nil)
   ((valid_domain_assures_stable formula-decl nil semantics nil)
    (stable? const-decl "bool" semantics nil)
    (validDomain const-decl "bool" semantics nil)
    (Domain type-eq-decl nil domain nil)
    (finite_nonempty? const-decl "bool" more_set_defs "sets_aux/")
    (set type-eq-decl nil sets nil) (CEB type-eq-decl nil domain nil)
    (RAExprDomain type-decl nil domain nil)
    (RBExpr type-decl nil expressions nil)
    (FPAExprDomain type-decl nil domain nil)
    (applyFun_fp formal-const-decl
     "[[Operator, FloatingPointNumber, FloatingPointNumber] ->
   FloatingPointNumber]" semantics nil)
    (lt_fp formal-const-decl
     "(strict_total_order?[FloatingPointNumber])" semantics nil)
    (applyFun_r formal-const-decl
     "[[Operator, RealNumber, RealNumber] -> RealNumber]" semantics
     nil)
    (lt_r formal-const-decl "(strict_total_order?[RealNumber])"
     semantics nil)
    (strict_total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (FPBExpr type-decl nil expressions nil)
    (FtoR formal-const-decl "[FloatingPointNumber -> RealNumber]"
     semantics nil)
    (FloatingPointNumber formal-nonempty-type-decl nil semantics nil)
    (RealNumber formal-nonempty-type-decl nil semantics nil)
    (Operator formal-nonempty-type-decl nil semantics nil))
   shostak))
 (valid_domain__ceb_bottomless 0
  (valid_domain__ceb_bottomless-1 nil 3732700239
   ("" (skeep :preds? t)
    (("" (lemma "valid_domain_assures_bottomless")
      (("" (inst -1 "dom")
        (("" (expand "bottomLess?" -1) (("" (inst -1 "ceb") nil nil))
          nil))
        nil))
      nil))
    nil)
   ((valid_domain_assures_bottomless formula-decl nil semantics nil)
    (bottomLess? const-decl "bool" semantics nil)
    (validDomain const-decl "bool" semantics nil)
    (Domain type-eq-decl nil domain nil)
    (finite_nonempty? const-decl "bool" more_set_defs "sets_aux/")
    (set type-eq-decl nil sets nil) (CEB type-eq-decl nil domain nil)
    (RAExprDomain type-decl nil domain nil)
    (RBExpr type-decl nil expressions nil)
    (FPAExprDomain type-decl nil domain nil)
    (applyFun_fp formal-const-decl
     "[[Operator, FloatingPointNumber, FloatingPointNumber] ->
   FloatingPointNumber]" semantics nil)
    (lt_fp formal-const-decl
     "(strict_total_order?[FloatingPointNumber])" semantics nil)
    (applyFun_r formal-const-decl
     "[[Operator, RealNumber, RealNumber] -> RealNumber]" semantics
     nil)
    (lt_r formal-const-decl "(strict_total_order?[RealNumber])"
     semantics nil)
    (strict_total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (FPBExpr type-decl nil expressions nil)
    (FtoR formal-const-decl "[FloatingPointNumber -> RealNumber]"
     semantics nil)
    (FloatingPointNumber formal-nonempty-type-decl nil semantics nil)
    (RealNumber formal-nonempty-type-decl nil semantics nil)
    (Operator formal-nonempty-type-decl nil semantics nil))
   shostak))
 (valid_domain__ceb_conditions_hold 0
  (valid_domain__ceb_conditions_hold-1 nil 3732700272
   ("" (skeep :preds? t)
    (("" (lemma "valid_domain_assures_conditions_hold")
      (("" (inst -1 "dom")
        (("" (expand "conditionsHold?" -1)
          (("" (inst -1 "ceb") nil nil)) nil))
        nil))
      nil))
    nil)
   ((valid_domain_assures_conditions_hold formula-decl nil semantics
     nil)
    (conditionsHold? const-decl "bool" semantics nil)
    (validDomain const-decl "bool" semantics nil)
    (Domain type-eq-decl nil domain nil)
    (finite_nonempty? const-decl "bool" more_set_defs "sets_aux/")
    (set type-eq-decl nil sets nil) (CEB type-eq-decl nil domain nil)
    (RAExprDomain type-decl nil domain nil)
    (RBExpr type-decl nil expressions nil)
    (FPAExprDomain type-decl nil domain nil)
    (applyFun_fp formal-const-decl
     "[[Operator, FloatingPointNumber, FloatingPointNumber] ->
   FloatingPointNumber]" semantics nil)
    (lt_fp formal-const-decl
     "(strict_total_order?[FloatingPointNumber])" semantics nil)
    (applyFun_r formal-const-decl
     "[[Operator, RealNumber, RealNumber] -> RealNumber]" semantics
     nil)
    (lt_r formal-const-decl "(strict_total_order?[RealNumber])"
     semantics nil)
    (strict_total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (FPBExpr type-decl nil expressions nil)
    (FtoR formal-const-decl "[FloatingPointNumber -> RealNumber]"
     semantics nil)
    (FloatingPointNumber formal-nonempty-type-decl nil semantics nil)
    (RealNumber formal-nonempty-type-decl nil semantics nil)
    (Operator formal-nonempty-type-decl nil semantics nil))
   shostak))
 (validEnvironmentForStmt_no_free_var 0
  (validEnvironmentForStmt_no_free_var-1 nil 3755516129
   ("" (skeep :preds? t)
    (("" (expand "validEnvironmentForStmt")
      (("" (flatten) (("" (inst -6 "local") nil nil)) nil)) nil))
    nil)
   ((validEnvironmentForStmt const-decl "bool" semantics nil)
    (Operator formal-nonempty-type-decl nil semantics nil)
    (RealNumber formal-nonempty-type-decl nil semantics nil)
    (FloatingPointNumber formal-nonempty-type-decl nil semantics nil)
    (FtoR formal-const-decl "[FloatingPointNumber -> RealNumber]"
     semantics nil)
    (FPAExpr type-decl nil expressions nil)
    (boolean nonempty-type-decl nil booleans nil)
    (FPVariable? adt-recognizer-decl "[FPAExpr -> boolean]" expressions
     nil))
   shostak))
 (valid_environment_assures_conditions_hold 0
  (valid_environment_assures_conditions_hold-1 nil 3732697654
   ("" (skeep :preds? t)
    (("" (expand "validEnvironmentForStmt") (("" (flatten) nil nil))
      nil))
    nil)
   ((validEnvironmentForStmt const-decl "bool" semantics nil))
   shostak))
 (valid_environment_assures_stable 0
  (valid_environment_assures_stable-1 nil 3732700317
   ("" (grind) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (Operator formal-nonempty-type-decl nil semantics nil)
    (RealNumber formal-nonempty-type-decl nil semantics nil)
    (FloatingPointNumber formal-nonempty-type-decl nil semantics nil)
    (FtoR formal-const-decl "[FloatingPointNumber -> RealNumber]"
     semantics nil)
    (FPBExpr type-decl nil expressions nil)
    (pred type-eq-decl nil defined_types nil)
    (strict_total_order? const-decl "bool" orders nil)
    (lt_r formal-const-decl "(strict_total_order?[RealNumber])"
     semantics nil)
    (applyFun_r formal-const-decl
     "[[Operator, RealNumber, RealNumber] -> RealNumber]" semantics
     nil)
    (lt_fp formal-const-decl
     "(strict_total_order?[FloatingPointNumber])" semantics nil)
    (applyFun_fp formal-const-decl
     "[[Operator, FloatingPointNumber, FloatingPointNumber] ->
   FloatingPointNumber]" semantics nil)
    (FPAExprDomain type-decl nil domain nil)
    (RBExpr type-decl nil expressions nil)
    (RAExprDomain type-decl nil domain nil)
    (CEB type-eq-decl nil domain nil) (set type-eq-decl nil sets nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (every adt-def-decl "boolean" list_adt nil)
    (finite_nonempty? const-decl "bool" more_set_defs "sets_aux/")
    (Environment nonempty-type-eq-decl nil semantics nil)
    (validEnvironmentForStmt const-decl "bool" semantics nil)
    (Domain type-eq-decl nil domain nil)
    (member def-decl "bool" list_props nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (>= const-decl "bool" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (injective? const-decl "bool" functions nil)
    (is_finite const-decl "bool" finite_sets nil)
    (member const-decl "bool" sets nil)
    (empty? const-decl "bool" sets nil)
    (nonempty? const-decl "bool" sets nil)
    (/= const-decl "boolean" notequal nil)
    (bottomLess? const-decl "bool" semantics nil)
    (bottomLess? const-decl "bool" semantics nil)
    (bottomLess? const-decl "bool" semantics nil)
    (conditionsHold? const-decl "bool" semantics nil)
    (conditionsHold? const-decl "bool" semantics nil)
    (conditionsHold? const-decl "bool" semantics nil)
    (appears? const-decl "bool" expressions nil)
    (FtoR def-decl "RAExpr" expressions nil)
    (appears? const-decl "bool" expressions nil)
    (appears? const-decl "bool" domain nil)
    (appears? const-decl "bool" domain nil)
    (appears? const-decl "bool" semantics nil)
    (stable? const-decl "bool" semantics nil)
    (stable? const-decl "bool" semantics nil))
   shostak))
 (valid_environment_assures_bottomless 0
  (valid_environment_assures_bottomless-1 nil 3732700321
   ("" (grind) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (Operator formal-nonempty-type-decl nil semantics nil)
    (RealNumber formal-nonempty-type-decl nil semantics nil)
    (FloatingPointNumber formal-nonempty-type-decl nil semantics nil)
    (FtoR formal-const-decl "[FloatingPointNumber -> RealNumber]"
     semantics nil)
    (FPBExpr type-decl nil expressions nil)
    (pred type-eq-decl nil defined_types nil)
    (strict_total_order? const-decl "bool" orders nil)
    (lt_r formal-const-decl "(strict_total_order?[RealNumber])"
     semantics nil)
    (applyFun_r formal-const-decl
     "[[Operator, RealNumber, RealNumber] -> RealNumber]" semantics
     nil)
    (lt_fp formal-const-decl
     "(strict_total_order?[FloatingPointNumber])" semantics nil)
    (applyFun_fp formal-const-decl
     "[[Operator, FloatingPointNumber, FloatingPointNumber] ->
   FloatingPointNumber]" semantics nil)
    (FPAExprDomain type-decl nil domain nil)
    (RBExpr type-decl nil expressions nil)
    (RAExprDomain type-decl nil domain nil)
    (CEB type-eq-decl nil domain nil) (set type-eq-decl nil sets nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (every adt-def-decl "boolean" list_adt nil)
    (finite_nonempty? const-decl "bool" more_set_defs "sets_aux/")
    (Environment nonempty-type-eq-decl nil semantics nil)
    (validEnvironmentForStmt const-decl "bool" semantics nil)
    (member def-decl "bool" list_props nil)
    (Domain type-eq-decl nil domain nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (>= const-decl "bool" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (injective? const-decl "bool" functions nil)
    (is_finite const-decl "bool" finite_sets nil)
    (member const-decl "bool" sets nil)
    (empty? const-decl "bool" sets nil)
    (nonempty? const-decl "bool" sets nil)
    (stable? const-decl "bool" semantics nil)
    (stable? const-decl "bool" semantics nil)
    (conditionsHold? const-decl "bool" semantics nil)
    (conditionsHold? const-decl "bool" semantics nil)
    (conditionsHold? const-decl "bool" semantics nil)
    (appears? const-decl "bool" expressions nil)
    (FtoR def-decl "RAExpr" expressions nil)
    (appears? const-decl "bool" expressions nil)
    (appears? const-decl "bool" domain nil)
    (appears? const-decl "bool" domain nil)
    (appears? const-decl "bool" semantics nil)
    (/= const-decl "boolean" notequal nil)
    (bottomLess? const-decl "bool" semantics nil)
    (bottomLess? const-decl "bool" semantics nil)
    (bottomLess? const-decl "bool" semantics nil))
   shostak))
 (empty_env_is_valid 0
  (empty_env_is_valid-1 nil 3755001643 ("" (grind) nil nil)
   ((injective? const-decl "bool" functions nil)
    (is_finite const-decl "bool" finite_sets nil)
    (member const-decl "bool" sets nil)
    (empty? const-decl "bool" sets nil)
    (nonempty? const-decl "bool" sets nil)
    (FPBExpr type-decl nil expressions nil)
    (FPAExprDomain type-decl nil domain nil)
    (RBExpr type-decl nil expressions nil)
    (RAExprDomain type-decl nil domain nil)
    (CEB type-eq-decl nil domain nil) (set type-eq-decl nil sets nil)
    (finite_nonempty? const-decl "bool" more_set_defs "sets_aux/")
    (Domain type-eq-decl nil domain nil)
    (list type-decl nil list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (every adt-def-decl "boolean" list_adt nil)
    (member def-decl "bool" list_props nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (FPAExpr type-decl nil expressions nil)
    (FPVariable? adt-recognizer-decl "[FPAExpr -> boolean]" expressions
     nil)
    (bounded_by? def-decl "bool" expressions_semantics nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (consistentLocalEnvironments? const-decl "bool"
     expressions_semantics nil)
    (RLocalEnvironment type-eq-decl nil expressions_semantics nil)
    (<< adt-def-decl "(strict_well_founded?[RAExpr])" expressions nil)
    (rVarIndex const-decl "nat" expressions_semantics nil)
    (RVariable? adt-recognizer-decl "[RAExpr -> boolean]" expressions
     nil)
    (RAExpr type-decl nil expressions nil)
    (bounded_by? def-decl "bool" expressions_semantics nil)
    (FPLocalEnvironment type-eq-decl nil expressions_semantics nil)
    (LocalEnvironment nonempty-type-decl nil u_local_environment nil)
    (<< adt-def-decl "(strict_well_founded?[FPAExpr])" expressions nil)
    (strict_well_founded? const-decl "bool" orders nil)
    (fpVarIndex const-decl "nat" expressions_semantics nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (emptyEnv const-decl "Environment" semantics nil)
    (/= const-decl "boolean" notequal nil)
    (bottomLess? const-decl "bool" semantics nil)
    (bottomLess? const-decl "bool" semantics nil)
    (bottomLess? const-decl "bool" semantics nil)
    (stable? const-decl "bool" semantics nil)
    (stable? const-decl "bool" semantics nil)
    (conditionsHold? const-decl "bool" semantics nil)
    (conditionsHold? const-decl "bool" semantics nil)
    (conditionsHold? const-decl "bool" semantics nil)
    (FtoR formal-const-decl "[FloatingPointNumber -> RealNumber]"
     semantics nil)
    (FloatingPointNumber formal-nonempty-type-decl nil semantics nil)
    (RealNumber formal-nonempty-type-decl nil semantics nil)
    (Operator formal-nonempty-type-decl nil semantics nil)
    (appears? const-decl "bool" expressions nil)
    (FtoR def-decl "RAExpr" expressions nil)
    (appears? const-decl "bool" expressions nil)
    (applyFun_fp formal-const-decl
     "[[Operator, FloatingPointNumber, FloatingPointNumber] ->
   FloatingPointNumber]" semantics nil)
    (lt_fp formal-const-decl
     "(strict_total_order?[FloatingPointNumber])" semantics nil)
    (applyFun_r formal-const-decl
     "[[Operator, RealNumber, RealNumber] -> RealNumber]" semantics
     nil)
    (lt_r formal-const-decl "(strict_total_order?[RealNumber])"
     semantics nil)
    (strict_total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (appears? const-decl "bool" domain nil)
    (appears? const-decl "bool" domain nil)
    (appears? const-decl "bool" semantics nil)
    (validEnvironmentForStmt const-decl "bool" semantics nil))
   shostak))
 (empty_env_is_wellFormed? 0
  (empty_env_is_wellFormed?-1 nil 3755001691
   ("" (skeep)
    (("" (expand "wellFormed?")
      (("" (expand "emptyEnv") (("" (propax) nil nil)) nil)) nil))
    nil)
   ((wellFormed? def-decl "bool" semantics nil)
    (emptyEnv const-decl "Environment" semantics nil))
   shostak))
 (sem_TCC1 0
  (sem_TCC1-1 nil 3731411566
   (""
    (with-labels (skeep* :preds? t)
     (("ceb in result" nil nil nil nil "aexpr def" "target"
       "UNKNOWN")))
    (("" (expand "make_ceb" "ceb in result")
      (("" (expand "singleton" "ceb in result")
        (("" (replace "aexpr def" :hide? t)
          (("" (split "target")
            (("1" (expand "bottomLess?" *)
              (("1" (assert) (("1" (grind) nil nil)) nil)) nil)
             ("2" (grind) nil nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((nonempty_singleton_finite application-judgement
     "non_empty_finite_set" finite_sets nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (fpVarIndex const-decl "nat" expressions_semantics nil)
    (strict_well_founded? const-decl "bool" orders nil)
    (<< adt-def-decl "(strict_well_founded?[FPAExpr])" expressions nil)
    (LocalEnvironment nonempty-type-decl nil u_local_environment nil)
    (FPLocalEnvironment type-eq-decl nil expressions_semantics nil)
    (bounded_by? def-decl "bool" expressions_semantics nil)
    (RVariable? adt-recognizer-decl "[RAExpr -> boolean]" expressions
     nil)
    (rVarIndex const-decl "nat" expressions_semantics nil)
    (<< adt-def-decl "(strict_well_founded?[RAExpr])" expressions nil)
    (RLocalEnvironment type-eq-decl nil expressions_semantics nil)
    (consistentLocalEnvironments? const-decl "bool"
     expressions_semantics nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (bounded_by? def-decl "bool" expressions_semantics nil)
    (val def-decl "bool" expressions_semantics nil)
    (val def-decl "bool" expressions_semantics nil)
    (FPVariable? adt-recognizer-decl "[FPAExpr -> boolean]" expressions
     nil)
    (FPAExpr type-decl nil expressions nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (FPAExpr adt-constructor-decl
     "[FPAExpr[Operator, RealNumber, FloatingPointNumber, FtoR] -> (FPAExpr?)]"
     domain nil)
    (FPAExpr? adt-recognizer-decl "[FPAExprDomain -> boolean]" domain
     nil)
    (number adt-accessor-decl "[(FPConstant?) -> FPNumber]" expressions
            nil)
    (FPConstant? adt-recognizer-decl "[FPAExpr -> boolean]" expressions
     nil)
    (RConstant adt-constructor-decl "[RNumber -> (RConstant?)]"
     expressions nil)
    (RConstant? adt-recognizer-decl "[RAExpr -> boolean]" expressions
     nil)
    (RAExpr adt-constructor-decl
     "[RAExpr[Operator, RealNumber, FloatingPointNumber, FtoR] -> (RAExpr?)]"
     domain nil)
    (RAExpr? adt-recognizer-decl "[RAExprDomain -> boolean]" domain
     nil)
    (RAExpr type-decl nil expressions nil)
    (FPTrue adt-constructor-decl "(FPTrue?)" expressions nil)
    (FPTrue? adt-recognizer-decl "[FPBExpr -> boolean]" expressions
     nil)
    (RTrue adt-constructor-decl "(RTrue?)" expressions nil)
    (RTrue? adt-recognizer-decl "[RBExpr -> boolean]" expressions nil)
    (singleton const-decl "(singleton?)" sets nil)
    (singleton? const-decl "bool" sets nil)
    (set type-eq-decl nil sets nil) (CEB type-eq-decl nil domain nil)
    (RAExprDomain type-decl nil domain nil)
    (RBExpr type-decl nil expressions nil)
    (FPAExprDomain type-decl nil domain nil)
    (FPBExpr type-decl nil expressions nil)
    (appearsFree? def-decl "bool" expressions nil)
    (appearsFree? def-decl "bool" expressions nil)
    (/= const-decl "boolean" notequal nil)
    (bottomLess? const-decl "bool" semantics nil)
    (bottomLess? const-decl "bool" semantics nil)
    (bottomLess? const-decl "bool" semantics nil)
    (stable? const-decl "bool" semantics nil)
    (stable? const-decl "bool" semantics nil)
    (conditionsHold? const-decl "bool" semantics nil)
    (conditionsHold? const-decl "bool" semantics nil)
    (conditionsHold? const-decl "bool" semantics nil)
    (FtoR formal-const-decl "[FloatingPointNumber -> RealNumber]"
     semantics nil)
    (FloatingPointNumber formal-nonempty-type-decl nil semantics nil)
    (RealNumber formal-nonempty-type-decl nil semantics nil)
    (Operator formal-nonempty-type-decl nil semantics nil)
    (appears? const-decl "bool" expressions nil)
    (FtoR def-decl "RAExpr" expressions nil)
    (appears? const-decl "bool" expressions nil)
    (applyFun_fp formal-const-decl
     "[[Operator, FloatingPointNumber, FloatingPointNumber] ->
   FloatingPointNumber]" semantics nil)
    (lt_fp formal-const-decl
     "(strict_total_order?[FloatingPointNumber])" semantics nil)
    (applyFun_r formal-const-decl
     "[[Operator, RealNumber, RealNumber] -> RealNumber]" semantics
     nil)
    (lt_r formal-const-decl "(strict_total_order?[RealNumber])"
     semantics nil)
    (strict_total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (appears? const-decl "bool" domain nil)
    (appears? const-decl "bool" domain nil)
    (appears? const-decl "bool" semantics nil)
    (validEnvironmentForStmt const-decl "bool" semantics nil)
    (FtoR def-decl "RAExprDomain" domain nil)
    (make_ceb const-decl "CEB" domain nil)
    (validDomain const-decl "bool" semantics nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil))
 (sem_TCC2 0
  (sem_TCC2-1 nil 3731411566
   ("" (skeep :preds? t)
    (("" (expand "wellFormed?")
      (("" (assert) (("" (grind) nil nil)) nil)) nil))
    nil)
   ((wellFormed? inductive-decl "bool" expressions nil)
    (validEnvironmentForStmt const-decl "bool" semantics nil)
    (appears? const-decl "bool" semantics nil)
    (appears? const-decl "bool" domain nil)
    (appears? const-decl "bool" domain nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (pred type-eq-decl nil defined_types nil)
    (strict_total_order? const-decl "bool" orders nil)
    (lt_r formal-const-decl "(strict_total_order?[RealNumber])"
     semantics nil)
    (applyFun_r formal-const-decl
     "[[Operator, RealNumber, RealNumber] -> RealNumber]" semantics
     nil)
    (lt_fp formal-const-decl
     "(strict_total_order?[FloatingPointNumber])" semantics nil)
    (applyFun_fp formal-const-decl
     "[[Operator, FloatingPointNumber, FloatingPointNumber] ->
   FloatingPointNumber]" semantics nil)
    (appears? const-decl "bool" expressions nil)
    (FtoR def-decl "RAExpr" expressions nil)
    (appears? const-decl "bool" expressions nil)
    (Operator formal-nonempty-type-decl nil semantics nil)
    (RealNumber formal-nonempty-type-decl nil semantics nil)
    (FloatingPointNumber formal-nonempty-type-decl nil semantics nil)
    (FtoR formal-const-decl "[FloatingPointNumber -> RealNumber]"
     semantics nil)
    (conditionsHold? const-decl "bool" semantics nil)
    (conditionsHold? const-decl "bool" semantics nil)
    (conditionsHold? const-decl "bool" semantics nil)
    (stable? const-decl "bool" semantics nil)
    (stable? const-decl "bool" semantics nil)
    (bottomLess? const-decl "bool" semantics nil)
    (bottomLess? const-decl "bool" semantics nil)
    (bottomLess? const-decl "bool" semantics nil)
    (/= const-decl "boolean" notequal nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil))
   nil))
 (sem_TCC3 0
  (sem_TCC3-1 nil 3731411566
   ("" (skeep* :preds? t)
    (("" (expand "validEnvironmentForStmt")
      (("" (flatten)
        (("" (expand "wellFormed?" -)
          (("" (replace -9 :hide? t)
            (("" (assert)
              (("" (case "0 <= length(env) - 1 -v ")
                (("1" (assert)
                  (("1" (hide -1)
                    (("1" (expand "validDomain")
                      (("1" (split)
                        (("1" (expand "bottomLess?" -)
                          (("1" (inst? - :where 1)
                            (("1" (use "nth_member[Domain]") nil nil))
                            nil))
                          nil)
                         ("2" (expand "stable?" -)
                          (("2" (inst? - :where 1)
                            (("2" (expand "stable?")
                              (("2"
                                (use "nth_member[Domain]")
                                nil
                                nil))
                              nil))
                            nil))
                          nil)
                         ("3" (expand "conditionsHold?" -)
                          (("3" (inst? - :where 1)
                            (("3" (use "nth_member[Domain]") nil nil))
                            nil))
                          nil)
                         ("4" (skeep)
                          (("4" (inst -7 "local")
                            (("4" (rewrite "appears?_env_int_def")
                              (("4"
                                (inst 1 "nth(env,v)")
                                (("4"
                                  (use "nth_member[Domain]")
                                  nil
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (assert) nil nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((validEnvironmentForStmt const-decl "bool" semantics nil)
    (wellFormed? inductive-decl "bool" expressions nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (validDomain const-decl "bool" semantics nil)
    (appears?_env_int_def formula-decl nil semantics nil)
    (FPVariable? adt-recognizer-decl "[FPAExpr -> boolean]" expressions
     nil)
    (conditionsHold? const-decl "bool" semantics nil)
    (stable? const-decl "bool" semantics nil)
    (stable? const-decl "bool" semantics nil)
    (bottomLess? const-decl "bool" semantics nil)
    (below type-eq-decl nil naturalnumbers nil)
    (nth_member formula-decl nil more_list_props "structures/")
    (v skolem-const-decl
     "DeBruijnIndex[Operator, RealNumber, FloatingPointNumber, FtoR]"
     semantics nil)
    (env skolem-const-decl
     "{env: (validEnvironmentForStmt) | wellFormed?(aexpr, nargs, length(env))}"
     semantics nil)
    (nargs skolem-const-decl "nat" semantics nil)
    (aexpr skolem-const-decl
     "FPAExpr[Operator, RealNumber, FloatingPointNumber, FtoR]"
     semantics nil)
    (member def-decl "bool" list_props nil)
    (< const-decl "bool" reals nil)
    (below type-eq-decl nil nat_types nil)
    (nth def-decl "T" list_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (<= const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (Operator formal-nonempty-type-decl nil semantics nil)
    (RealNumber formal-nonempty-type-decl nil semantics nil)
    (FloatingPointNumber formal-nonempty-type-decl nil semantics nil)
    (FtoR formal-const-decl "[FloatingPointNumber -> RealNumber]"
     semantics nil)
    (FPBExpr type-decl nil expressions nil)
    (pred type-eq-decl nil defined_types nil)
    (strict_total_order? const-decl "bool" orders nil)
    (lt_r formal-const-decl "(strict_total_order?[RealNumber])"
     semantics nil)
    (applyFun_r formal-const-decl
     "[[Operator, RealNumber, RealNumber] -> RealNumber]" semantics
     nil)
    (lt_fp formal-const-decl
     "(strict_total_order?[FloatingPointNumber])" semantics nil)
    (applyFun_fp formal-const-decl
     "[[Operator, FloatingPointNumber, FloatingPointNumber] ->
   FloatingPointNumber]" semantics nil)
    (FPAExprDomain type-decl nil domain nil)
    (RBExpr type-decl nil expressions nil)
    (RAExprDomain type-decl nil domain nil)
    (CEB type-eq-decl nil domain nil) (set type-eq-decl nil sets nil)
    (list type-decl nil list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (every adt-def-decl "boolean" list_adt nil)
    (finite_nonempty? const-decl "bool" more_set_defs "sets_aux/")
    (Domain type-eq-decl nil domain nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (length def-decl "nat" list_props nil)
    (Environment nonempty-type-eq-decl nil semantics nil)
    (FPAExpr type-decl nil expressions nil)
    (DeBruijnIndex nonempty-type-eq-decl nil expressions nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil))
 (sem_TCC4 0
  (sem_TCC4-1 nil 3731411566
   ("" (skeep* :preds? t)
    (("" (expand "singleton")
      (("" (expand "make_ceb")
        (("" (split)
          (("1" (grind) nil nil)
           ("2" (expand "finite_nonempty?")
            (("2" (split 1)
              (("1" (expand "is_finite")
                (("1"
                  (inst 1 "1" "LAMBDA(x: ({y:
                     CEB
                         [Operator, RealNumber, lt_r, applyFun_r,
                          FloatingPointNumber, lt_fp, applyFun_fp, FtoR]
                     |
                     y =
                      (# rconds
                           := RTrue
                                  [Operator, RealNumber,
                                   FloatingPointNumber, FtoR],
                         fpconds
                           := FPTrue
                                  [Operator, RealNumber,
                                   FloatingPointNumber, FtoR],
                         rresult
                           := FtoR
                                  [Operator, RealNumber, lt_r, applyFun_r,
                                   FloatingPointNumber, lt_fp, applyFun_fp,
                                   FtoR]
                                  (FPAExpr
                                       [Operator,
                                        RealNumber,
                                        lt_r,
                                        applyFun_r,
                                        FloatingPointNumber,
                                        lt_fp,
                                        applyFun_fp,
                                        FtoR]
                                       (aexpr)),
                         fpresult
                           := FPAExpr
                                  [Operator, RealNumber, lt_r, applyFun_r,
                                   FloatingPointNumber, lt_fp, applyFun_fp,
                                   FtoR]
                                  (aexpr),
                         stable? := TRUE #)})):0")
                  (("1" (grind) nil nil)) nil))
                nil)
               ("2" (grind) nil nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((singleton const-decl "(singleton?)" sets nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (validDomain const-decl "bool" semantics nil)
    (appearsFree? def-decl "bool" expressions nil)
    (appearsFree? def-decl "bool" expressions nil)
    (val def-decl "bool" expressions_semantics nil)
    (val def-decl "bool" expressions_semantics nil)
    (FtoR def-decl "RAExprDomain" domain nil)
    (validEnvironmentForStmt const-decl "bool" semantics nil)
    (appears? const-decl "bool" semantics nil)
    (appears? const-decl "bool" domain nil)
    (appears? const-decl "bool" domain nil)
    (pred type-eq-decl nil defined_types nil)
    (strict_total_order? const-decl "bool" orders nil)
    (lt_r formal-const-decl "(strict_total_order?[RealNumber])"
     semantics nil)
    (applyFun_r formal-const-decl
     "[[Operator, RealNumber, RealNumber] -> RealNumber]" semantics
     nil)
    (lt_fp formal-const-decl
     "(strict_total_order?[FloatingPointNumber])" semantics nil)
    (applyFun_fp formal-const-decl
     "[[Operator, FloatingPointNumber, FloatingPointNumber] ->
   FloatingPointNumber]" semantics nil)
    (appears? const-decl "bool" expressions nil)
    (FtoR def-decl "RAExpr" expressions nil)
    (appears? const-decl "bool" expressions nil)
    (Operator formal-nonempty-type-decl nil semantics nil)
    (RealNumber formal-nonempty-type-decl nil semantics nil)
    (FloatingPointNumber formal-nonempty-type-decl nil semantics nil)
    (FtoR formal-const-decl "[FloatingPointNumber -> RealNumber]"
     semantics nil)
    (conditionsHold? const-decl "bool" semantics nil)
    (conditionsHold? const-decl "bool" semantics nil)
    (conditionsHold? const-decl "bool" semantics nil)
    (stable? const-decl "bool" semantics nil)
    (stable? const-decl "bool" semantics nil)
    (bottomLess? const-decl "bool" semantics nil)
    (bottomLess? const-decl "bool" semantics nil)
    (bottomLess? const-decl "bool" semantics nil)
    (/= const-decl "boolean" notequal nil)
    (FPAExpr adt-constructor-decl
     "[FPAExpr[Operator, RealNumber, FloatingPointNumber, FtoR] -> (FPAExpr?)]"
     domain nil)
    (FPAExpr? adt-recognizer-decl "[FPAExprDomain -> boolean]" domain
     nil)
    (index shared-adt-accessor-decl
           "[{x: FPAExpr | FPVariable?(x) OR FPParameter?(x)} -> DeBruijnIndex]"
           expressions nil)
    (DeBruijnIndex nonempty-type-eq-decl nil expressions nil)
    (FPParameter? adt-recognizer-decl "[FPAExpr -> boolean]"
     expressions nil)
    (FPVariable? adt-recognizer-decl "[FPAExpr -> boolean]" expressions
     nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (FPAExpr type-decl nil expressions nil)
    (RParameter adt-constructor-decl
     "[ParameterIndex -> (RParameter?)]" expressions nil)
    (RParameter? adt-recognizer-decl "[RAExpr -> boolean]" expressions
     nil)
    (ParameterIndex nonempty-type-eq-decl nil expressions nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (RAExpr adt-constructor-decl
     "[RAExpr[Operator, RealNumber, FloatingPointNumber, FtoR] -> (RAExpr?)]"
     domain nil)
    (RAExpr? adt-recognizer-decl "[RAExprDomain -> boolean]" domain
     nil)
    (RAExpr type-decl nil expressions nil)
    (FPTrue adt-constructor-decl "(FPTrue?)" expressions nil)
    (FPTrue? adt-recognizer-decl "[FPBExpr -> boolean]" expressions
     nil)
    (RTrue adt-constructor-decl "(RTrue?)" expressions nil)
    (RTrue? adt-recognizer-decl "[RBExpr -> boolean]" expressions nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (CEB type-eq-decl nil domain nil)
    (RAExprDomain type-decl nil domain nil)
    (RBExpr type-decl nil expressions nil)
    (FPAExprDomain type-decl nil domain nil)
    (FPBExpr type-decl nil expressions nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (make_ceb const-decl "CEB" domain nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil))
 (sem_TCC5 0
  (sem_TCC5-1 nil 3731411566
   ("" (skeep* :preds? t)
    (("" (case "aexpr = FPOperator(op, arg1, arg2)")
      (("1" (label "aexpr" -1)
        (("1" (replace "aexpr" :hide? t)
          (("1" (expand "wellFormed?" -) (("1" (assert) nil nil)) nil))
          nil))
        nil)
       ("2" (propax) nil nil))
      nil))
    nil)
   ((FPOperator adt-constructor-decl
     "[[Operator, FPAExpr, FPAExpr] -> (FPOperator?)]" expressions nil)
    (FPOperator? adt-recognizer-decl "[FPAExpr -> boolean]" expressions
     nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (FPAExpr type-decl nil expressions nil)
    (FtoR formal-const-decl "[FloatingPointNumber -> RealNumber]"
     semantics nil)
    (FloatingPointNumber formal-nonempty-type-decl nil semantics nil)
    (RealNumber formal-nonempty-type-decl nil semantics nil)
    (Operator formal-nonempty-type-decl nil semantics nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (wellFormed? inductive-decl "bool" expressions nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil))
 (sem_TCC6 0
  (sem_TCC6-2 "" 3731868565 ("" (grind) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (Operator formal-nonempty-type-decl nil semantics nil)
    (RealNumber formal-nonempty-type-decl nil semantics nil)
    (FloatingPointNumber formal-nonempty-type-decl nil semantics nil)
    (FtoR formal-const-decl "[FloatingPointNumber -> RealNumber]"
     semantics nil)
    (FPBExpr type-decl nil expressions nil)
    (pred type-eq-decl nil defined_types nil)
    (strict_total_order? const-decl "bool" orders nil)
    (lt_r formal-const-decl "(strict_total_order?[RealNumber])"
     semantics nil)
    (applyFun_r formal-const-decl
     "[[Operator, RealNumber, RealNumber] -> RealNumber]" semantics
     nil)
    (lt_fp formal-const-decl
     "(strict_total_order?[FloatingPointNumber])" semantics nil)
    (applyFun_fp formal-const-decl
     "[[Operator, FloatingPointNumber, FloatingPointNumber] ->
   FloatingPointNumber]" semantics nil)
    (FPAExprDomain type-decl nil domain nil)
    (RBExpr type-decl nil expressions nil)
    (RAExprDomain type-decl nil domain nil)
    (CEB type-eq-decl nil domain nil) (set type-eq-decl nil sets nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (every adt-def-decl "boolean" list_adt nil)
    (finite_nonempty? const-decl "bool" more_set_defs "sets_aux/")
    (Environment nonempty-type-eq-decl nil semantics nil)
    (validEnvironmentForStmt const-decl "bool" semantics nil)
    (FPAExpr type-decl nil expressions nil)
    (wellFormed? inductive-decl "bool" expressions nil)
    (Domain type-eq-decl nil domain nil)
    (length def-decl "nat" list_props nil)
    (injective? const-decl "bool" functions nil)
    (is_finite const-decl "bool" finite_sets nil)
    (member const-decl "bool" sets nil)
    (empty? const-decl "bool" sets nil)
    (nonempty? const-decl "bool" sets nil)
    (/= const-decl "boolean" notequal nil)
    (bottomLess? const-decl "bool" semantics nil)
    (bottomLess? const-decl "bool" semantics nil)
    (stable? const-decl "bool" semantics nil)
    (conditionsHold? const-decl "bool" semantics nil)
    (conditionsHold? const-decl "bool" semantics nil)
    (appears? const-decl "bool" expressions nil)
    (FtoR def-decl "RAExpr" expressions nil)
    (appears? const-decl "bool" expressions nil)
    (appears? const-decl "bool" domain nil)
    (appears? const-decl "bool" domain nil)
    (bottomLess? const-decl "bool" semantics nil)
    (stable? const-decl "bool" semantics nil)
    (conditionsHold? const-decl "bool" semantics nil)
    (appears? const-decl "bool" semantics nil)
    (<< adt-def-decl "(strict_well_founded?[FPAExpr])" expressions nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (validDomain const-decl "bool" semantics nil))
   shostak)
  (sem_TCC6-1 nil 3731411566
   ("" (skeep* :preds? t)
    (("" (assert)
      (("" (case "aexpr = FPOperator(op, arg1, arg2)")
        (("1" (label "aexpr" -1)
          (("1" (replace "aexpr" :hide? t)
            (("1" (expand "wellFormed?" -) (("1" (propax) nil nil))
              nil))
            nil))
          nil)
         ("2" (propax) nil nil))
        nil))
      nil))
    nil)
   ((FPBExpr type-decl nil expressions nil)
    (FPAExprDomain type-decl nil domain nil)
    (RBExpr type-decl nil expressions nil)
    (RAExprDomain type-decl nil domain nil)
    (CEB type-eq-decl nil domain nil)
    (FPAExpr type-decl nil expressions nil)
    (wellFormed? inductive-decl "bool" expressions nil)
    (Domain type-eq-decl nil domain nil)
    (<< adt-def-decl "(strict_well_founded?[FPAExpr])" expressions
     nil))
   nil))
 (sem_TCC7 0
  (sem_TCC7-1 nil 3731411566 ("" (subtype-tcc) nil nil) nil nil))
 (sem_TCC8 0
  (sem_TCC8-4 "" 3753702960
   (""
    (with-labels (skeep* :preds? t)
     ((nil nil nil "cebs from arg2 are valid" nil
       "cebs from arg1 are valid" nil nil nil nil "aexpr def" nil nil
       "combinations def" "target" "UNKNOWN")))
    (("" (expand "validDomain")
      ((""
        (with-labels (flatten "cebs from arg1 are valid")
         (("sem arg1 is bottomless" "sem arg1 is stable"
           "sem arg1 is trivial" "sem arg1 has no free vars"
           "UNKNOWN")))
        ((""
          (with-labels (flatten "cebs from arg2 are valid")
           (("sem arg2 is bottomless" "sem arg2 is stable"
             "sem arg2 is trivial" "sem arg2 has no free vars"
             "UNKNOWN")))
          (("" (expand "map" "target")
            ((""
              (rewrite "cartesian_product_intensional_def"
               "combinations def")
              (("" (split "target")
                (("1" (expand "bottomLess?" "target")
                  (("1"
                    (with-labels (skeep "target" :preds? t)
                     (("ceb def" "target" "UNKNOWN")))
                    (("1"
                      (with-labels (skeep "ceb def" :preds? t)
                       ((nil "y is in combinations" "ceb def"
                         "UNKNOWN")))
                      (("1" (replace "combinations def" :hide? T)
                        (("1" (assert)
                          (("1"
                            (with-labels
                             (flatten "y is in combinations")
                             (("y0 in arg1" "y1 in arg2" "UNKNOWN")))
                            (("1" (expand "create_new_CEB" "ceb def")
                              (("1"
                                (replace "ceb def" "target")
                                (("1"
                                  (expand "make_ceb" "target")
                                  (("1"
                                    (expand "bottomLess?" "target")
                                    (("1"
                                      (expand
                                       "bottomLess?"
                                       "sem arg1 is bottomless")
                                      (("1"
                                        (expand "member")
                                        (("1"
                                          (inst
                                           "sem arg1 is bottomless"
                                           "nth(y, 0)")
                                          (("1"
                                            (expand
                                             "bottomLess?"
                                             "sem arg1 is bottomless")
                                            (("1"
                                              (flatten)
                                              (("1"
                                                (assert)
                                                (("1"
                                                  (expand
                                                   "bottomLess?"
                                                   "sem arg2 is bottomless")
                                                  (("1"
                                                    (inst
                                                     "sem arg2 is bottomless"
                                                     "nth(y, 1)")
                                                    (("1"
                                                      (expand
                                                       "bottomLess?"
                                                       "sem arg2 is bottomless")
                                                      (("1"
                                                        (flatten)
                                                        (("1"
                                                          (assert)
                                                          nil
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (expand "stable?" "target")
                  (("2"
                    (with-labels (skeep "target" :preds? t)
                     (("ceb def" "target" "UNKNOWN")))
                    (("2"
                      (with-labels (skeep "ceb def" :preds? t)
                       ((nil "y is in combinations" "ceb def"
                         "UNKNOWN")))
                      (("2" (replace "combinations def" :hide? T)
                        (("2" (assert)
                          (("2"
                            (with-labels
                             (flatten "y is in combinations")
                             (("y0 in arg1" "y1 in arg2" "UNKNOWN")))
                            (("2" (expand "create_new_CEB" "ceb def")
                              (("2"
                                (replace "ceb def" "target")
                                (("2"
                                  (expand "make_ceb" "target")
                                  (("2"
                                    (expand "member")
                                    (("2" (assert) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("3" (expand "conditionsHold?" "target")
                  (("3"
                    (with-labels (skeep "target" :preds? t)
                     (("ceb def" "target" "UNKNOWN")))
                    (("3"
                      (with-labels (skeep "ceb def" :preds? t)
                       ((nil "y is in combinations" "ceb def"
                         "UNKNOWN")))
                      (("3" (replace "combinations def" :hide? T)
                        (("3" (assert)
                          (("3"
                            (with-labels
                             (flatten "y is in combinations")
                             (("y0 in arg1" "y1 in arg2" "UNKNOWN")))
                            (("3" (expand "create_new_CEB" "ceb def")
                              (("3"
                                (replace "ceb def" "target" :hide? t)
                                (("3"
                                  (expand "make_ceb" "target")
                                  (("3"
                                    (expand "conditionsHold?" "target")
                                    (("3"
                                      (expand
                                       "conditionsHold?"
                                       "sem arg1 is trivial")
                                      (("3"
                                        (expand "member")
                                        (("3"
                                          (inst
                                           "sem arg1 is trivial"
                                           "nth(y, 0)")
                                          (("3"
                                            (expand
                                             "conditionsHold?"
                                             "sem arg1 is trivial")
                                            (("3"
                                              (skeep "target")
                                              (("3"
                                                (inst
                                                 "sem arg1 is trivial"
                                                 "fpParamEnv"
                                                 "fpLocalEnv"
                                                 "rLocalEnv")
                                                (("1"
                                                  (flatten)
                                                  (("1"
                                                    (expand
                                                     "conditionsHold?"
                                                     "sem arg2 is trivial")
                                                    (("1"
                                                      (inst
                                                       "sem arg2 is trivial"
                                                       "nth(y, 1)")
                                                      (("1"
                                                        (expand
                                                         "conditionsHold?"
                                                         "sem arg2 is trivial")
                                                        (("1"
                                                          (inst
                                                           "sem arg2 is trivial"
                                                           "fpParamEnv"
                                                           "fpLocalEnv"
                                                           "rLocalEnv")
                                                          (("1"
                                                            (flatten)
                                                            (("1"
                                                              (hide-all-but
                                                               ("target"
                                                                "sem arg1 is trivial"
                                                                "sem arg2 is trivial"))
                                                              (("1"
                                                                (expand
                                                                 "val"
                                                                 "target")
                                                                (("1"
                                                                  (assert)
                                                                  nil
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil)
                                                           ("2"
                                                            (hide-all-but
                                                             1)
                                                            (("2"
                                                              (typepred
                                                               "rLocalEnv")
                                                              (("2"
                                                                (lemma
                                                                 "evaluable_subterm_r")
                                                                (("2"
                                                                  (inst?
                                                                   -1
                                                                   :where
                                                                   1)
                                                                  (("2"
                                                                    (inst?
                                                                     -1
                                                                     :where
                                                                     -3)
                                                                    (("2"
                                                                      (assert)
                                                                      (("2"
                                                                        (hide-all-but
                                                                         1)
                                                                        (("2"
                                                                          (grind)
                                                                          nil
                                                                          nil))
                                                                        nil))
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil)
                                                           ("3"
                                                            (hide-all-but
                                                             1)
                                                            (("3"
                                                              (typepred
                                                               "fpLocalEnv")
                                                              (("3"
                                                                (lemma
                                                                 "evaluable_subterm_fp")
                                                                (("3"
                                                                  (inst?
                                                                   -1
                                                                   :where
                                                                   1)
                                                                  (("3"
                                                                    (inst?
                                                                     -1
                                                                     :where
                                                                     -2)
                                                                    (("3"
                                                                      (assert)
                                                                      (("3"
                                                                        (hide-all-but
                                                                         1)
                                                                        (("3"
                                                                          (grind)
                                                                          nil
                                                                          nil))
                                                                        nil))
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil)
                                                 ("2"
                                                  (hide-all-but 1)
                                                  (("2"
                                                    (typepred
                                                     "rLocalEnv")
                                                    (("2"
                                                      (lemma
                                                       "evaluable_subterm_r")
                                                      (("2"
                                                        (inst?
                                                         -1
                                                         :where
                                                         1)
                                                        (("2"
                                                          (inst?
                                                           -1
                                                           :where
                                                           -3)
                                                          (("2"
                                                            (assert)
                                                            (("2"
                                                              (hide-all-but
                                                               1)
                                                              (("2"
                                                                (grind)
                                                                nil
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil)
                                                 ("3"
                                                  (hide-all-but 1)
                                                  (("3"
                                                    (typepred
                                                     "fpLocalEnv")
                                                    (("3"
                                                      (lemma
                                                       "evaluable_subterm_fp")
                                                      (("3"
                                                        (inst?
                                                         -1
                                                         :where
                                                         1)
                                                        (("3"
                                                          (inst?
                                                           -1
                                                           :where
                                                           -2)
                                                          (("3"
                                                            (assert)
                                                            (("3"
                                                              (hide-all-but
                                                               1)
                                                              (("3"
                                                                (grind)
                                                                nil
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("4"
                  (with-labels (skeep "target" :preds? t)
                   ((nil "local does not appear in new dom"
                     "UNKNOWN")))
                  (("4" (rewrite "appears?_dom_int_def")
                    (("1"
                      (with-labels
                       (skeep "local does not appear in new dom"
                        :preds? t)
                       (("y is in combinations"
                         "local does not appear in ceb" "UNKNOWN")))
                      (("1" (skeep "y is in combinations")
                        (("1" (replace "y is in combinations" :hide? t)
                          (("1" (rewrite "appears?_ceb_int_def")
                            (("1" (expand "create_new_CEB")
                              (("1"
                                (assert)
                                (("1"
                                  (expand "make_ceb")
                                  (("1"
                                    (inst
                                     "sem arg1 has no free vars"
                                     "local")
                                    (("1"
                                      (inst
                                       "sem arg2 has no free vars"
                                       "local")
                                      (("1"
                                        (rewrite
                                         "appears?_dom_int_def")
                                        (("1"
                                          (rewrite
                                           "appears?_dom_int_def")
                                          (("1"
                                            (typepred "y")
                                            (("1"
                                              (replace
                                               "combinations def"
                                               :hide?
                                               t)
                                              (("1"
                                                (assert)
                                                (("1"
                                                  (flatten)
                                                  (("1"
                                                    (split
                                                     "local does not appear in ceb")
                                                    (("1"
                                                      (rewrite
                                                       "appears?_form_int_def_and")
                                                      (("1"
                                                        (split
                                                         "local does not appear in ceb")
                                                        (("1"
                                                          (inst
                                                           "sem arg1 has no free vars"
                                                           "nth(y,0)")
                                                          (("1"
                                                            (rewrite
                                                             "appears?_ceb_int_def")
                                                            (("1"
                                                              (flatten)
                                                              nil
                                                              nil))
                                                            nil)
                                                           ("2"
                                                            (expand
                                                             "member")
                                                            (("2"
                                                              (propax)
                                                              nil
                                                              nil))
                                                            nil))
                                                          nil)
                                                         ("2"
                                                          (inst
                                                           "sem arg2 has no free vars"
                                                           "nth(y,1)")
                                                          (("1"
                                                            (rewrite
                                                             "appears?_ceb_int_def")
                                                            (("1"
                                                              (flatten)
                                                              nil
                                                              nil))
                                                            nil)
                                                           ("2"
                                                            (expand
                                                             "member")
                                                            (("2"
                                                              (propax)
                                                              nil
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil)
                                                     ("2"
                                                      (rewrite
                                                       "appears?_rform_int_def_and")
                                                      (("2"
                                                        (split
                                                         "local does not appear in ceb")
                                                        (("1"
                                                          (inst
                                                           "sem arg1 has no free vars"
                                                           "nth(y,0)")
                                                          (("1"
                                                            (rewrite
                                                             "appears?_ceb_int_def")
                                                            (("1"
                                                              (flatten)
                                                              nil
                                                              nil))
                                                            nil)
                                                           ("2"
                                                            (expand
                                                             "member")
                                                            (("2"
                                                              (propax)
                                                              nil
                                                              nil))
                                                            nil))
                                                          nil)
                                                         ("2"
                                                          (inst
                                                           "sem arg2 has no free vars"
                                                           "nth(y,1)")
                                                          (("1"
                                                            (rewrite
                                                             "appears?_ceb_int_def")
                                                            (("1"
                                                              (flatten)
                                                              nil
                                                              nil))
                                                            nil)
                                                           ("2"
                                                            (expand
                                                             "member")
                                                            (("2"
                                                              (propax)
                                                              nil
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil)
                     ("2"
                      (case "map(LAMBDA (p: PairCEB):create_new_CEB(op)(nth(p, 0),nth(p, 1)))(combinations) = {x:
              CEB |
              EXISTS (y: (combinations)):
                x =
                 create_new_CEB(op)
                               (nth(y, 0),
                                nth(y, 1))}")
                      (("1" (replace -1 :hide? t :dir rl)
                        (("1" (assert) nil nil)) nil)
                       ("2" (expand "map") (("2" (propax) nil nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((nil application-judgement "(finite_nonempty?[T2])" more_set_props
     "sets_aux/")
    (nil application-judgement "(nonempty?[T2])" more_set_props
     "sets_aux/")
    (validDomain const-decl "bool" semantics nil)
    (cartesian_product_intensional_def formula-decl nil semantics nil)
    (Operator formal-nonempty-type-decl nil semantics nil)
    (RealNumber formal-nonempty-type-decl nil semantics nil)
    (FloatingPointNumber formal-nonempty-type-decl nil semantics nil)
    (FtoR formal-const-decl "[FloatingPointNumber -> RealNumber]"
     semantics nil)
    (FPBExpr type-decl nil expressions nil)
    (pred type-eq-decl nil defined_types nil)
    (strict_total_order? const-decl "bool" orders nil)
    (lt_r formal-const-decl "(strict_total_order?[RealNumber])"
     semantics nil)
    (applyFun_r formal-const-decl
     "[[Operator, RealNumber, RealNumber] -> RealNumber]" semantics
     nil)
    (lt_fp formal-const-decl
     "(strict_total_order?[FloatingPointNumber])" semantics nil)
    (applyFun_fp formal-const-decl
     "[[Operator, FloatingPointNumber, FloatingPointNumber] ->
   FloatingPointNumber]" semantics nil)
    (FPAExprDomain type-decl nil domain nil)
    (RBExpr type-decl nil expressions nil)
    (RAExprDomain type-decl nil domain nil)
    (CEB type-eq-decl nil domain nil) (set type-eq-decl nil sets nil)
    (finite_nonempty? const-decl "bool" more_set_defs "sets_aux/")
    (Domain type-eq-decl nil domain nil)
    (setof type-eq-decl nil defined_types nil)
    (FtoR def-decl "RAExpr" expressions nil)
    (appears?_rform_int_def_and formula-decl nil expressions nil)
    (appears?_form_int_def_and formula-decl nil expressions nil)
    (y skolem-const-decl "(combinations)" semantics nil)
    (ftor_fpvar_rvar_j application-judgement "(RVariable?)" semantics
     nil)
    (appears?_ceb_int_def formula-decl nil domain nil)
    (appears?_dom_int_def formula-decl nil domain nil)
    (conditionsHold? const-decl "bool" semantics nil)
    (y skolem-const-decl "(combinations)" semantics nil)
    (val def-decl "bool" expressions_semantics nil)
    (val def-decl "bool" expressions_semantics nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (subterm adt-def-decl "boolean" expressions nil)
    (evaluable_subterm_r formula-decl nil expressions_semantics nil)
    (subterm adt-def-decl "boolean" expressions nil)
    (evaluable_subterm_fp formula-decl nil expressions_semantics nil)
    (FPEnvironment nonempty-type-eq-decl nil expressions_semantics nil)
    (FPNumber nonempty-type-eq-decl nil expressions nil)
    (ParameterIndex nonempty-type-eq-decl nil expressions nil)
    (RAExpr type-decl nil expressions nil)
    (RVariable? adt-recognizer-decl "[RAExpr -> boolean]" expressions
     nil)
    (rVarIndex const-decl "nat" expressions_semantics nil)
    (<< adt-def-decl "(strict_well_founded?[RAExpr])" expressions nil)
    (RLocalEnvironment type-eq-decl nil expressions_semantics nil)
    (bounded_by? def-decl "bool" expressions_semantics nil)
    (consistentLocalEnvironments? const-decl "bool"
     expressions_semantics nil)
    (RAnd? adt-recognizer-decl "[RBExpr -> boolean]" expressions nil)
    (RAnd adt-constructor-decl "[[RBExpr, RBExpr] -> (RAnd?)]"
     expressions nil)
    (rLocalEnv skolem-const-decl "{rLocalEnv: RLocalEnvironment |
         consistentLocalEnvironments?(fpLocalEnv, rLocalEnv) AND
          bounded_by?(rLocalEnv)
                     (RAnd(rconds
                             (nth
                                  [CEB
                                       [Operator,
                                        RealNumber,
                                        lt_r,
                                        applyFun_r,
                                        FloatingPointNumber,
                                        lt_fp,
                                        applyFun_fp,
                                        FtoR]]
                                  (y, 0)),
                           rconds
                             (nth
                                  [CEB
                                       [Operator,
                                        RealNumber,
                                        lt_r,
                                        applyFun_r,
                                        FloatingPointNumber,
                                        lt_fp,
                                        applyFun_fp,
                                        FtoR]]
                                  (y, 1))))}" semantics nil)
    (FPAExpr type-decl nil expressions nil)
    (FPVariable? adt-recognizer-decl "[FPAExpr -> boolean]" expressions
     nil)
    (fpVarIndex const-decl "nat" expressions_semantics nil)
    (strict_well_founded? const-decl "bool" orders nil)
    (<< adt-def-decl "(strict_well_founded?[FPAExpr])" expressions nil)
    (LocalEnvironment nonempty-type-decl nil u_local_environment nil)
    (FPLocalEnvironment type-eq-decl nil expressions_semantics nil)
    (bounded_by? def-decl "bool" expressions_semantics nil)
    (FPAnd? adt-recognizer-decl "[FPBExpr -> boolean]" expressions nil)
    (FPAnd adt-constructor-decl "[[FPBExpr, FPBExpr] -> (FPAnd?)]"
     expressions nil)
    (fpLocalEnv skolem-const-decl "{fpLocalEnv: FPLocalEnvironment |
         bounded_by?(fpLocalEnv)
                    (FPAnd(fpconds
                             (nth
                                  [CEB
                                       [Operator,
                                        RealNumber,
                                        lt_r,
                                        applyFun_r,
                                        FloatingPointNumber,
                                        lt_fp,
                                        applyFun_fp,
                                        FtoR]]
                                  (y, 0)),
                           fpconds
                             (nth
                                  [CEB
                                       [Operator,
                                        RealNumber,
                                        lt_r,
                                        applyFun_r,
                                        FloatingPointNumber,
                                        lt_fp,
                                        applyFun_fp,
                                        FtoR]]
                                  (y, 1))))}" semantics nil)
    (conditionsHold? const-decl "bool" semantics nil)
    (stable? const-decl "bool" semantics nil)
    (bottomLess? const-decl "bool" semantics nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (nil application-judgement "above(1)" semantics nil)
    (create_new_CEB const-decl "CEB" semantics nil)
    (make_ceb const-decl "CEB" domain nil)
    (y skolem-const-decl "(combinations)" semantics nil)
    (combinations skolem-const-decl "{fne |
         fne =
          ({p: PairCEB |
              member(nth(p, 0), sem_arg1) AND member(nth(p, 1), sem_arg2)})}"
     semantics nil)
    (sem_arg2 skolem-const-decl "(validDomain)" semantics nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (PairCEB nonempty-type-eq-decl nil semantics nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (nth def-decl "T" list_props nil)
    (below type-eq-decl nil nat_types nil)
    (length def-decl "nat" list_props nil)
    (< const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (list type-decl nil list_adt nil)
    (sem_arg1 skolem-const-decl "(validDomain)" semantics nil)
    (member const-decl "bool" sets nil)
    (bottomLess? const-decl "bool" semantics nil)
    (map const-decl "setof[T2]" more_set_props "sets_aux/")
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil)
  (sem_TCC8-3 "" 3732701699 ("" (subtype-tcc) nil nil) nil nil)
  (sem_TCC8-2 "" 3732649105
   (""
    (with-labels (skeep* :preds? t)
     ((nil nil "cebs from arg2 are valid" nil
       "cebs from arg1 are valid" nil nil nil nil "aexpr def" nil nil
       "combinations def" "target" "UNKNOWN")))
    (("" (expand "validDomain" "target")
      ((""
        (expand "validDomain"
                ("target" "cebs from arg2 are valid"
                 "cebs from arg1 are valid"))
        ((""
          (flatten ("cebs from arg2 are valid"
                    "cebs from arg1 are valid"))
          (("" (expand "map" "target")
            (("" (expand "cartesian_product" "combinations def")
              (("" (split "target")
                (("1" (expand "bottomLess?" "target")
                  (("1"
                    (with-labels (skeep "target" :preds? t)
                     (("ceb def" "target" "UNKNOWN")))
                    (("1"
                      (with-labels (skeep "ceb def" :preds? t)
                       ((nil "y is in combinations" "ceb def"
                         "UNKNOWN")))
                      (("1" (replace "combinations def" :hide? T)
                        (("1" (assert)
                          (("1"
                            (with-labels
                             (flatten "y is in combinations")
                             (("y0 in arg1" "y1 in arg2" "UNKNOWN")))
                            (("1" (expand "create_new_CEB" "ceb def")
                              (("1"
                                (replace "ceb def" "target")
                                (("1"
                                  (expand "make_ceb" "target")
                                  (("1"
                                    (expand "bottomLess?" "target")
                                    (("1"
                                      (expand
                                       "bottomLess?"
                                       "cebs from arg1 are valid")
                                      (("1"
                                        (expand "member")
                                        (("1"
                                          (inst
                                           "cebs from arg1 are valid"
                                           "nth(y, 0)")
                                          (("1"
                                            (expand
                                             "bottomLess?"
                                             "cebs from arg1 are valid")
                                            (("1"
                                              (flatten)
                                              (("1"
                                                (assert)
                                                (("1"
                                                  (expand
                                                   "bottomLess?"
                                                   "cebs from arg2 are valid")
                                                  (("1"
                                                    (inst
                                                     "cebs from arg2 are valid"
                                                     "nth(y, 1)")
                                                    (("1"
                                                      (expand
                                                       "bottomLess?"
                                                       "cebs from arg2 are valid")
                                                      (("1"
                                                        (flatten)
                                                        (("1"
                                                          (assert)
                                                          nil
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (expand "stable?" "target")
                  (("2"
                    (with-labels (skeep "target" :preds? t)
                     (("ceb def" "target" "UNKNOWN")))
                    (("2"
                      (with-labels (skeep "ceb def" :preds? t)
                       ((nil "y is in combinations" "ceb def"
                         "UNKNOWN")))
                      (("2" (replace "combinations def" :hide? T)
                        (("2" (assert)
                          (("2"
                            (with-labels
                             (flatten "y is in combinations")
                             (("y0 in arg1" "y1 in arg2" "UNKNOWN")))
                            (("2" (expand "create_new_CEB" "ceb def")
                              (("2"
                                (replace "ceb def" "target")
                                (("2"
                                  (expand "make_ceb" "target")
                                  (("2"
                                    (expand "member")
                                    (("2" (assert) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("3" (expand "conditionsHold?" "target")
                  (("3"
                    (with-labels (skeep "target" :preds? t)
                     (("ceb def" "target" "UNKNOWN")))
                    (("3"
                      (with-labels (skeep "ceb def" :preds? t)
                       ((nil "y is in combinations" "ceb def"
                         "UNKNOWN")))
                      (("3" (replace "combinations def" :hide? T)
                        (("3" (assert)
                          (("3"
                            (with-labels
                             (flatten "y is in combinations")
                             (("y0 in arg1" "y1 in arg2" "UNKNOWN")))
                            (("3" (expand "create_new_CEB" "ceb def")
                              (("3"
                                (replace "ceb def" "target")
                                (("3"
                                  (expand "make_ceb" "target")
                                  (("3"
                                    (expand "conditionsHold?" "target")
                                    (("3"
                                      (expand
                                       "conditionsHold?"
                                       "cebs from arg1 are valid")
                                      (("3"
                                        (expand "member")
                                        (("3"
                                          (inst
                                           "cebs from arg1 are valid"
                                           "nth(y, 0)")
                                          (("3"
                                            (expand
                                             "conditionsHold?"
                                             "cebs from arg1 are valid")
                                            (("3"
                                              (skeep "target")
                                              (("3"
                                                (inst
                                                 "cebs from arg1 are valid"
                                                 "fpEnv")
                                                (("3"
                                                  (flatten)
                                                  (("3"
                                                    (expand
                                                     "conditionsHold?"
                                                     "cebs from arg2 are valid")
                                                    (("3"
                                                      (inst
                                                       "cebs from arg2 are valid"
                                                       "nth(y, 1)")
                                                      (("3"
                                                        (expand
                                                         "conditionsHold?"
                                                         "cebs from arg2 are valid")
                                                        (("3"
                                                          (inst
                                                           "cebs from arg2 are valid"
                                                           "fpEnv")
                                                          (("3"
                                                            (flatten)
                                                            (("3"
                                                              (hide-all-but
                                                               ("target"
                                                                "cebs from arg1 are valid"
                                                                "cebs from arg2 are valid"))
                                                              (("3"
                                                                (expand
                                                                 "val"
                                                                 "target")
                                                                (("3"
                                                                  (assert)
                                                                  nil
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   nil shostak)
  (sem_TCC8-1 nil 3731411566
   (""
    (with-labels (skeep* :preds? t)
     (("ceb typepred" nil nil
       "cebs from arg2 are bottomLess and Stable" nil
       "cebs from arg1 are bottomLess and Stable" nil nil nil nil
       "aexpr def" nil nil "combinations def" "target" "UNKNOWN")))
    (("" (replace "combinations def" :hide? t)
      (("" (expand "cartesian_product" "ceb typepred")
        (("" (expand "map" "ceb typepred")
          (("" (skeep - :but (("y" "pair")) :preds? t)
            ((""
              (inst "cebs from arg2 are bottomLess and Stable"
               "nth(pair,1)")
              (("1"
                (inst "cebs from arg1 are bottomLess and Stable"
                 "nth(pair,0)")
                (("1" (flatten)
                  (("1" (split "target")
                    (("1" (expand "create_new_CEB")
                      (("1" (expand "make_ceb")
                        (("1" (expand "bottomLess?")
                          (("1" (flatten)
                            (("1" (replace "ceb typepred" :hide? t)
                              (("1" (assert) nil nil)) nil))
                            nil))
                          nil))
                        nil))
                      nil)
                     ("2" (expand "create_new_CEB")
                      (("2" (expand "make_ceb")
                        (("2" (replace "ceb typepred")
                          (("2" (assert) nil nil)) nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (expand "member") (("2" (propax) nil nil)) nil))
                nil)
               ("2" (expand "member") (("2" (propax) nil nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((map const-decl "setof[T2]" more_set_props "sets_aux/")
    (Domain type-eq-decl nil domain nil)
    (CEB type-eq-decl nil domain nil)
    (RAExprDomain type-decl nil domain nil)
    (RBExpr type-decl nil expressions nil)
    (FPAExprDomain type-decl nil domain nil)
    (FPBExpr type-decl nil expressions nil)
    (make_ceb const-decl "CEB" domain nil))
   nil))
 (sem_TCC9 0
  (sem_TCC9-6 "" 3753703169
   ("" (skeep* :preds? t)
    (("" (assert)
      (("" (case "aexpr = FPOperator(op, arg1, arg2)")
        (("1" (label "aexpr" -1)
          (("1" (replace "aexpr" :hide? t)
            (("1" (expand "wellFormed?" -) (("1" (propax) nil nil))
              nil))
            nil))
          nil)
         ("2" (propax) nil nil))
        nil))
      nil))
    nil)
   ((real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (wellFormed? inductive-decl "bool" expressions nil)
    (Operator formal-nonempty-type-decl nil semantics nil)
    (RealNumber formal-nonempty-type-decl nil semantics nil)
    (FloatingPointNumber formal-nonempty-type-decl nil semantics nil)
    (FtoR formal-const-decl "[FloatingPointNumber -> RealNumber]"
     semantics nil)
    (FPAExpr type-decl nil expressions nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (FPOperator? adt-recognizer-decl "[FPAExpr -> boolean]" expressions
     nil)
    (FPOperator adt-constructor-decl
     "[[Operator, FPAExpr, FPAExpr] -> (FPOperator?)]" expressions nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil)
  (sem_TCC9-5 "" 3753630985
   (""
    (with-labels (skeep* :preds? t)
     ((nil nil "cebs from arg2 are valid" nil
       "cebs from arg1 are valid" nil nil nil nil "aexpr def" nil nil
       "combinations def" "target" "UNKNOWN")))
    (("" (expand "validDomain")
      ((""
        (flatten ("cebs from arg2 are valid"
                  "cebs from arg1 are valid"))
        (("" (expand "map" "target")
          (("" (expand "cartesian_product" "combinations def")
            (("" (split "target")
              (("1" (expand "bottomLess?" "target")
                (("1"
                  (with-labels (skeep "target" :preds? t)
                   (("ceb def" "target" "UNKNOWN")))
                  (("1"
                    (with-labels (skeep "ceb def" :preds? t)
                     ((nil "y is in combinations" "ceb def"
                       "UNKNOWN")))
                    (("1" (replace "combinations def" :hide? T)
                      (("1" (assert)
                        (("1"
                          (with-labels (flatten "y is in combinations")
                           (("y0 in arg1" "y1 in arg2" "UNKNOWN")))
                          (("1" (expand "create_new_CEB" "ceb def")
                            (("1" (replace "ceb def" "target")
                              (("1"
                                (expand "make_ceb" "target")
                                (("1"
                                  (expand "bottomLess?" "target")
                                  (("1"
                                    (expand
                                     "bottomLess?"
                                     "cebs from arg1 are valid")
                                    (("1"
                                      (expand "member")
                                      (("1"
                                        (inst
                                         "cebs from arg1 are valid"
                                         "nth(y, 0)")
                                        (("1"
                                          (expand
                                           "bottomLess?"
                                           "cebs from arg1 are valid")
                                          (("1"
                                            (flatten)
                                            (("1"
                                              (assert)
                                              (("1"
                                                (expand
                                                 "bottomLess?"
                                                 "cebs from arg2 are valid")
                                                (("1"
                                                  (inst
                                                   "cebs from arg2 are valid"
                                                   "nth(y, 1)")
                                                  (("1"
                                                    (expand
                                                     "bottomLess?"
                                                     "cebs from arg2 are valid")
                                                    (("1"
                                                      (flatten)
                                                      (("1"
                                                        (assert)
                                                        nil
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("2" (expand "stable?" "target")
                (("2"
                  (with-labels (skeep "target" :preds? t)
                   (("ceb def" "target" "UNKNOWN")))
                  (("2"
                    (with-labels (skeep "ceb def" :preds? t)
                     ((nil "y is in combinations" "ceb def"
                       "UNKNOWN")))
                    (("2" (replace "combinations def" :hide? T)
                      (("2" (assert)
                        (("2"
                          (with-labels (flatten "y is in combinations")
                           (("y0 in arg1" "y1 in arg2" "UNKNOWN")))
                          (("2" (expand "create_new_CEB" "ceb def")
                            (("2" (replace "ceb def" "target")
                              (("2"
                                (expand "make_ceb" "target")
                                (("2"
                                  (expand "member")
                                  (("2" (assert) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("3" (expand "conditionsHold?" "target")
                (("3"
                  (with-labels (skeep "target" :preds? t)
                   (("ceb def" "target" "UNKNOWN")))
                  (("3"
                    (with-labels (skeep "ceb def" :preds? t)
                     ((nil "y is in combinations" "ceb def"
                       "UNKNOWN")))
                    (("3" (replace "combinations def" :hide? T)
                      (("3" (assert)
                        (("3"
                          (with-labels (flatten "y is in combinations")
                           (("y0 in arg1" "y1 in arg2" "UNKNOWN")))
                          (("3" (expand "create_new_CEB" "ceb def")
                            (("3" (replace "ceb def" "target" :hide? t)
                              (("3"
                                (expand "make_ceb" "target")
                                (("3"
                                  (expand "conditionsHold?" "target")
                                  (("3"
                                    (expand
                                     "conditionsHold?"
                                     "cebs from arg1 are valid")
                                    (("3"
                                      (expand "member")
                                      (("3"
                                        (inst
                                         "cebs from arg1 are valid"
                                         "nth(y, 0)")
                                        (("3"
                                          (expand
                                           "conditionsHold?"
                                           "cebs from arg1 are valid")
                                          (("3"
                                            (skeep "target")
                                            (("3"
                                              (inst
                                               "cebs from arg1 are valid"
                                               "fpParamEnv"
                                               "fpLocalEnv"
                                               "rLocalEnv")
                                              (("1"
                                                (flatten)
                                                (("1"
                                                  (expand
                                                   "conditionsHold?"
                                                   "cebs from arg2 are valid")
                                                  (("1"
                                                    (inst
                                                     "cebs from arg2 are valid"
                                                     "nth(y, 1)")
                                                    (("1"
                                                      (expand
                                                       "conditionsHold?"
                                                       "cebs from arg2 are valid")
                                                      (("1"
                                                        (inst
                                                         "cebs from arg2 are valid"
                                                         "fpParamEnv"
                                                         "fpLocalEnv"
                                                         "rLocalEnv")
                                                        (("1"
                                                          (flatten)
                                                          (("1"
                                                            (hide-all-but
                                                             ("target"
                                                              "cebs from arg1 are valid"
                                                              "cebs from arg2 are valid"))
                                                            (("1"
                                                              (expand
                                                               "val"
                                                               "target")
                                                              (("1"
                                                                (assert)
                                                                nil
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil)
                                                         ("2"
                                                          (hide-all-but
                                                           1)
                                                          (("2"
                                                            (typepred
                                                             "rLocalEnv")
                                                            (("2"
                                                              (lemma
                                                               "evaluable_subterm_r")
                                                              (("2"
                                                                (inst?
                                                                 -1
                                                                 :where
                                                                 1)
                                                                (("2"
                                                                  (inst?
                                                                   -1
                                                                   :where
                                                                   -3)
                                                                  (("2"
                                                                    (assert)
                                                                    (("2"
                                                                      (hide-all-but
                                                                       1)
                                                                      (("2"
                                                                        (grind)
                                                                        nil
                                                                        nil))
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil)
                                                         ("3"
                                                          (hide-all-but
                                                           1)
                                                          (("3"
                                                            (typepred
                                                             "fpLocalEnv")
                                                            (("3"
                                                              (lemma
                                                               "evaluable_subterm_fp")
                                                              (("3"
                                                                (inst?
                                                                 -1
                                                                 :where
                                                                 1)
                                                                (("3"
                                                                  (inst?
                                                                   -1
                                                                   :where
                                                                   -2)
                                                                  (("3"
                                                                    (assert)
                                                                    (("3"
                                                                      (hide-all-but
                                                                       1)
                                                                      (("3"
                                                                        (grind)
                                                                        nil
                                                                        nil))
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil)
                                               ("2"
                                                (hide-all-but 1)
                                                (("2"
                                                  (typepred
                                                   "rLocalEnv")
                                                  (("2"
                                                    (lemma
                                                     "evaluable_subterm_r")
                                                    (("2"
                                                      (inst?
                                                       -1
                                                       :where
                                                       1)
                                                      (("2"
                                                        (inst?
                                                         -1
                                                         :where
                                                         -3)
                                                        (("2"
                                                          (assert)
                                                          (("2"
                                                            (hide-all-but
                                                             1)
                                                            (("2"
                                                              (grind)
                                                              nil
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil)
                                               ("3"
                                                (hide-all-but 1)
                                                (("3"
                                                  (typepred
                                                   "fpLocalEnv")
                                                  (("3"
                                                    (lemma
                                                     "evaluable_subterm_fp")
                                                    (("3"
                                                      (inst?
                                                       -1
                                                       :where
                                                       1)
                                                      (("3"
                                                        (inst?
                                                         -1
                                                         :where
                                                         -2)
                                                        (("3"
                                                          (assert)
                                                          (("3"
                                                            (hide-all-but
                                                             1)
                                                            (("3"
                                                              (grind)
                                                              nil
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((nil application-judgement "(finite_nonempty?[T2])" more_set_props
     "sets_aux/")
    (map const-decl "setof[T2]" more_set_props "sets_aux/")
    (FPBExpr type-decl nil expressions nil)
    (FPAExprDomain type-decl nil domain nil)
    (RBExpr type-decl nil expressions nil)
    (RAExprDomain type-decl nil domain nil)
    (CEB type-eq-decl nil domain nil)
    (finite_nonempty? const-decl "bool" more_set_defs "sets_aux/")
    (Domain type-eq-decl nil domain nil)
    (make_ceb const-decl "CEB" domain nil)
    (FPAExpr type-decl nil expressions nil)
    (FPLocalEnvironment type-eq-decl nil expressions_semantics nil)
    (FPAnd? adt-recognizer-decl "[FPBExpr -> boolean]" expressions nil)
    (FPAnd adt-constructor-decl "[[FPBExpr, FPBExpr] -> (FPAnd?)]"
     expressions nil)
    (RAnd adt-constructor-decl "[[RBExpr, RBExpr] -> (RAnd?)]"
     expressions nil)
    (RAnd? adt-recognizer-decl "[RBExpr -> boolean]" expressions nil)
    (consistentLocalEnvironments? const-decl "bool"
     expressions_semantics nil)
    (RLocalEnvironment type-eq-decl nil expressions_semantics nil)
    (RAExpr type-decl nil expressions nil)
    (FPEnvironment nonempty-type-eq-decl nil expressions_semantics nil)
    (FPNumber nonempty-type-eq-decl nil expressions nil)
    (ParameterIndex nonempty-type-eq-decl nil expressions nil)
    (evaluable_subterm_fp formula-decl nil expressions_semantics nil)
    (evaluable_subterm_r formula-decl nil expressions_semantics nil))
   shostak)
  (sem_TCC9-4 nil 3752665949
   (""
    (with-labels (skeep* :preds? t)
     ((nil nil "cebs from arg2 are valid" nil
       "cebs from arg1 are valid" nil nil nil nil "aexpr def" nil nil
       "combinations def" "target" "UNKNOWN")))
    (("" (expand "validDomain" "target")
      ((""
        (expand "validDomain"
                ("target" "cebs from arg2 are valid"
                 "cebs from arg1 are valid"))
        ((""
          (flatten ("cebs from arg2 are valid"
                    "cebs from arg1 are valid"))
          (("" (expand "map" "target")
            (("" (expand "cartesian_product" "combinations def")
              (("" (split "target")
                (("1" (expand "bottomLess?" "target")
                  (("1"
                    (with-labels (skeep "target" :preds? t)
                     (("ceb def" "target" "UNKNOWN")))
                    (("1"
                      (with-labels (skeep "ceb def" :preds? t)
                       ((nil "y is in combinations" "ceb def"
                         "UNKNOWN")))
                      (("1" (replace "combinations def" :hide? T)
                        (("1" (assert)
                          (("1"
                            (with-labels
                             (flatten "y is in combinations")
                             (("y0 in arg1" "y1 in arg2" "UNKNOWN")))
                            (("1" (expand "create_new_CEB" "ceb def")
                              (("1"
                                (replace "ceb def" "target")
                                (("1"
                                  (expand "make_ceb" "target")
                                  (("1"
                                    (expand "bottomLess?" "target")
                                    (("1"
                                      (expand
                                       "bottomLess?"
                                       "cebs from arg1 are valid")
                                      (("1"
                                        (expand "member")
                                        (("1"
                                          (inst
                                           "cebs from arg1 are valid"
                                           "nth(y, 0)")
                                          (("1"
                                            (expand
                                             "bottomLess?"
                                             "cebs from arg1 are valid")
                                            (("1"
                                              (flatten)
                                              (("1"
                                                (assert)
                                                (("1"
                                                  (expand
                                                   "bottomLess?"
                                                   "cebs from arg2 are valid")
                                                  (("1"
                                                    (inst
                                                     "cebs from arg2 are valid"
                                                     "nth(y, 1)")
                                                    (("1"
                                                      (expand
                                                       "bottomLess?"
                                                       "cebs from arg2 are valid")
                                                      (("1"
                                                        (flatten)
                                                        (("1"
                                                          (assert)
                                                          nil
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (expand "stable?" "target")
                  (("2"
                    (with-labels (skeep "target" :preds? t)
                     (("ceb def" "target" "UNKNOWN")))
                    (("2"
                      (with-labels (skeep "ceb def" :preds? t)
                       ((nil "y is in combinations" "ceb def"
                         "UNKNOWN")))
                      (("2" (replace "combinations def" :hide? T)
                        (("2" (assert)
                          (("2"
                            (with-labels
                             (flatten "y is in combinations")
                             (("y0 in arg1" "y1 in arg2" "UNKNOWN")))
                            (("2" (expand "create_new_CEB" "ceb def")
                              (("2"
                                (replace "ceb def" "target")
                                (("2"
                                  (expand "make_ceb" "target")
                                  (("2"
                                    (expand "member")
                                    (("2" (assert) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("3" (expand "conditionsHold?" "target")
                  (("3"
                    (with-labels (skeep "target" :preds? t)
                     (("ceb def" "target" "UNKNOWN")))
                    (("3"
                      (with-labels (skeep "ceb def" :preds? t)
                       ((nil "y is in combinations" "ceb def"
                         "UNKNOWN")))
                      (("3" (replace "combinations def" :hide? T)
                        (("3" (assert)
                          (("3"
                            (with-labels
                             (flatten "y is in combinations")
                             (("y0 in arg1" "y1 in arg2" "UNKNOWN")))
                            (("3" (expand "create_new_CEB" "ceb def")
                              (("3"
                                (replace "ceb def" "target" :hide? t)
                                (("3"
                                  (expand "make_ceb" "target")
                                  (("3"
                                    (expand "conditionsHold?" "target")
                                    (("3"
                                      (expand
                                       "conditionsHold?"
                                       "cebs from arg1 are valid")
                                      (("3"
                                        (expand "member")
                                        (("3"
                                          (inst
                                           "cebs from arg1 are valid"
                                           "nth(y, 0)")
                                          (("3"
                                            (expand
                                             "conditionsHold?"
                                             "cebs from arg1 are valid")
                                            (("3"
                                              (skeep "target")
                                              (("3"
                                                (inst
                                                 "cebs from arg1 are valid"
                                                 "fpParamEnv"
                                                 "fpLocalEnv"
                                                 "rLocalEnv")
                                                (("1"
                                                  (flatten)
                                                  (("1"
                                                    (expand
                                                     "conditionsHold?"
                                                     "cebs from arg2 are valid")
                                                    (("1"
                                                      (inst
                                                       "cebs from arg2 are valid"
                                                       "nth(y, 1)")
                                                      (("1"
                                                        (expand
                                                         "conditionsHold?"
                                                         "cebs from arg2 are valid")
                                                        (("1"
                                                          (inst
                                                           "cebs from arg2 are valid"
                                                           "fpParamEnv"
                                                           "fpLocalEnv"
                                                           "rLocalEnv")
                                                          (("1"
                                                            (flatten)
                                                            (("1"
                                                              (hide-all-but
                                                               ("target"
                                                                "cebs from arg1 are valid"
                                                                "cebs from arg2 are valid"))
                                                              (("1"
                                                                (expand
                                                                 "val"
                                                                 "target")
                                                                (("1"
                                                                  (assert)
                                                                  nil
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil)
                                                           ("2"
                                                            (hide-all-but
                                                             1)
                                                            (("2"
                                                              (typepred
                                                               "rLocalEnv")
                                                              (("2"
                                                                (lemma
                                                                 "evaluable_subterm_r")
                                                                (("2"
                                                                  (inst?
                                                                   -1
                                                                   :where
                                                                   1)
                                                                  (("2"
                                                                    (inst?
                                                                     -1
                                                                     :where
                                                                     -3)
                                                                    (("2"
                                                                      (assert)
                                                                      (("2"
                                                                        (hide-all-but
                                                                         1)
                                                                        (("2"
                                                                          (grind)
                                                                          nil
                                                                          nil))
                                                                        nil))
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil)
                                                           ("3"
                                                            (hide-all-but
                                                             1)
                                                            (("3"
                                                              (typepred
                                                               "fpLocalEnv")
                                                              (("3"
                                                                (lemma
                                                                 "evaluable_subterm_fp")
                                                                (("3"
                                                                  (inst?
                                                                   -1
                                                                   :where
                                                                   1)
                                                                  (("3"
                                                                    (inst?
                                                                     -1
                                                                     :where
                                                                     -2)
                                                                    (("3"
                                                                      (assert)
                                                                      (("3"
                                                                        (hide-all-but
                                                                         1)
                                                                        (("3"
                                                                          (grind)
                                                                          nil
                                                                          nil))
                                                                        nil))
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil)
                                                 ("2"
                                                  (hide-all-but 1)
                                                  (("2"
                                                    (typepred
                                                     "rLocalEnv")
                                                    (("2"
                                                      (lemma
                                                       "evaluable_subterm_r")
                                                      (("2"
                                                        (inst?
                                                         -1
                                                         :where
                                                         1)
                                                        (("2"
                                                          (inst?
                                                           -1
                                                           :where
                                                           -3)
                                                          (("2"
                                                            (assert)
                                                            (("2"
                                                              (hide-all-but
                                                               1)
                                                              (("2"
                                                                (grind)
                                                                nil
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil)
                                                 ("3"
                                                  (hide-all-but 1)
                                                  (("3"
                                                    (typepred
                                                     "fpLocalEnv")
                                                    (("3"
                                                      (lemma
                                                       "evaluable_subterm_fp")
                                                      (("3"
                                                        (inst?
                                                         -1
                                                         :where
                                                         1)
                                                        (("3"
                                                          (inst?
                                                           -1
                                                           :where
                                                           -2)
                                                          (("3"
                                                            (assert)
                                                            (("3"
                                                              (hide-all-but
                                                               1)
                                                              (("3"
                                                                (grind)
                                                                nil
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((nil application-judgement "(nonempty?[T2])" more_set_props
     "sets_aux/")
    (evaluable_subterm_r formula-decl nil expressions_semantics nil)
    (evaluable_subterm_fp formula-decl nil expressions_semantics nil)
    (ParameterIndex nonempty-type-eq-decl nil expressions nil)
    (FPNumber nonempty-type-eq-decl nil expressions nil)
    (FPEnvironment nonempty-type-eq-decl nil expressions_semantics nil)
    (RAExpr type-decl nil expressions nil)
    (RLocalEnvironment type-eq-decl nil expressions_semantics nil)
    (consistentLocalEnvironments? const-decl "bool"
     expressions_semantics nil)
    (RAnd? adt-recognizer-decl "[RBExpr -> boolean]" expressions nil)
    (RAnd adt-constructor-decl "[[RBExpr, RBExpr] -> (RAnd?)]"
     expressions nil)
    (FPAnd adt-constructor-decl "[[FPBExpr, FPBExpr] -> (FPAnd?)]"
     expressions nil)
    (FPAnd? adt-recognizer-decl "[FPBExpr -> boolean]" expressions nil)
    (FPLocalEnvironment type-eq-decl nil expressions_semantics nil)
    (FPAExpr type-decl nil expressions nil)
    (make_ceb const-decl "CEB" domain nil)
    (Domain type-eq-decl nil domain nil)
    (CEB type-eq-decl nil domain nil)
    (RAExprDomain type-decl nil domain nil)
    (RBExpr type-decl nil expressions nil)
    (FPAExprDomain type-decl nil domain nil)
    (FPBExpr type-decl nil expressions nil)
    (map const-decl "setof[T2]" more_set_props "sets_aux/"))
   nil)
  (sem_TCC9-3 nil 3732701632
   (""
    (with-labels (skeep* :preds? t)
     ((nil nil "cebs from arg2 are valid" nil
       "cebs from arg1 are valid" nil nil nil nil "aexpr def" nil nil
       "combinations def" "target" "UNKNOWN")))
    (("" (expand "validDomain" "target")
      ((""
        (expand "validDomain"
                ("target" "cebs from arg2 are valid"
                 "cebs from arg1 are valid"))
        ((""
          (flatten ("cebs from arg2 are valid"
                    "cebs from arg1 are valid"))
          (("" (expand "map" "target")
            (("" (expand "cartesian_product" "combinations def")
              (("" (split "target")
                (("1" (expand "bottomLess?" "target")
                  (("1"
                    (with-labels (skeep "target" :preds? t)
                     (("ceb def" "target" "UNKNOWN")))
                    (("1"
                      (with-labels (skeep "ceb def" :preds? t)
                       ((nil "y is in combinations" "ceb def"
                         "UNKNOWN")))
                      (("1" (replace "combinations def" :hide? T)
                        (("1" (assert)
                          (("1"
                            (with-labels
                             (flatten "y is in combinations")
                             (("y0 in arg1" "y1 in arg2" "UNKNOWN")))
                            (("1" (expand "create_new_CEB" "ceb def")
                              (("1"
                                (replace "ceb def" "target")
                                (("1"
                                  (expand "make_ceb" "target")
                                  (("1"
                                    (expand "bottomLess?" "target")
                                    (("1"
                                      (expand
                                       "bottomLess?"
                                       "cebs from arg1 are valid")
                                      (("1"
                                        (expand "member")
                                        (("1"
                                          (inst
                                           "cebs from arg1 are valid"
                                           "nth(y, 0)")
                                          (("1"
                                            (expand
                                             "bottomLess?"
                                             "cebs from arg1 are valid")
                                            (("1"
                                              (flatten)
                                              (("1"
                                                (assert)
                                                (("1"
                                                  (expand
                                                   "bottomLess?"
                                                   "cebs from arg2 are valid")
                                                  (("1"
                                                    (inst
                                                     "cebs from arg2 are valid"
                                                     "nth(y, 1)")
                                                    (("1"
                                                      (expand
                                                       "bottomLess?"
                                                       "cebs from arg2 are valid")
                                                      (("1"
                                                        (flatten)
                                                        (("1"
                                                          (assert)
                                                          nil
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (expand "stable?" "target")
                  (("2"
                    (with-labels (skeep "target" :preds? t)
                     (("ceb def" "target" "UNKNOWN")))
                    (("2"
                      (with-labels (skeep "ceb def" :preds? t)
                       ((nil "y is in combinations" "ceb def"
                         "UNKNOWN")))
                      (("2" (replace "combinations def" :hide? T)
                        (("2" (assert)
                          (("2"
                            (with-labels
                             (flatten "y is in combinations")
                             (("y0 in arg1" "y1 in arg2" "UNKNOWN")))
                            (("2" (expand "create_new_CEB" "ceb def")
                              (("2"
                                (replace "ceb def" "target")
                                (("2"
                                  (expand "make_ceb" "target")
                                  (("2" (propax) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("3" (expand "conditionsHold?" "target")
                  (("3"
                    (with-labels (skeep "target" :preds? t)
                     (("ceb def" "target" "UNKNOWN")))
                    (("3"
                      (with-labels (skeep "ceb def" :preds? t)
                       ((nil "y is in combinations" "ceb def"
                         "UNKNOWN")))
                      (("3" (replace "combinations def" :hide? T)
                        (("3" (assert)
                          (("3"
                            (with-labels
                             (flatten "y is in combinations")
                             (("y0 in arg1" "y1 in arg2" "UNKNOWN")))
                            (("3" (expand "create_new_CEB" "ceb def")
                              (("3"
                                (replace "ceb def" "target")
                                (("3"
                                  (expand "make_ceb" "target")
                                  (("3"
                                    (expand "conditionsHold?" "target")
                                    (("3"
                                      (expand
                                       "conditionsHold?"
                                       "cebs from arg1 are valid")
                                      (("3"
                                        (expand "member")
                                        (("3"
                                          (inst
                                           "cebs from arg1 are valid"
                                           "nth(y, 0)")
                                          (("3"
                                            (expand
                                             "conditionsHold?"
                                             "cebs from arg1 are valid")
                                            (("3"
                                              (skeep "target")
                                              (("3"
                                                (hide-all-but 1)
                                                (("3" (grind) nil nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((nil application-judgement "(nonempty?[T2])" more_set_props
     "sets_aux/")
    (make_ceb const-decl "CEB" domain nil)
    (Domain type-eq-decl nil domain nil)
    (CEB type-eq-decl nil domain nil)
    (RAExprDomain type-decl nil domain nil)
    (RBExpr type-decl nil expressions nil)
    (FPAExprDomain type-decl nil domain nil)
    (FPBExpr type-decl nil expressions nil)
    (map const-decl "setof[T2]" more_set_props "sets_aux/"))
   nil)
  (sem_TCC9-2 nil 3732643487
   ("" (skeep* :preds? t)
    (("" (assert)
      (("" (case "aexpr = FPOperator(op, arg1, arg2)")
        (("1" (label "aexpr" -1)
          (("1" (replace "aexpr" :hide? t)
            (("1" (expand "wellFormed?" -) (("1" (propax) nil nil))
              nil))
            nil))
          nil)
         ("2" (propax) nil nil))
        nil))
      nil))
    nil)
   ((wellFormed? inductive-decl "bool" expressions nil)
    (FPAExpr type-decl nil expressions nil)
    (FPOperator? adt-recognizer-decl "[FPAExpr -> boolean]" expressions
     nil)
    (FPOperator adt-constructor-decl
     "[[Operator, FPAExpr, FPAExpr] -> (FPOperator?)]" expressions
     nil))
   nil)
  (sem_TCC9-1 nil 3731411566
   ("" (skeep* :preds? t)
    (("" (replace -16 :hide? t)
      (("" (expand "cartesian_product")
        (("" (expand "map")
          (("" (skeep - :but (("y" "pair")) :preds? t)
            (("" (inst -7 "nth(pair,1)")
              (("1" (inst -9 "nth(pair,0)")
                (("1" (flatten)
                  (("1" (split)
                    (("1" (expand "stableConsistent?")
                      (("1" (assert)
                        (("1" (expand "create_new_CEB")
                          (("1" (expand "make_ceb")
                            (("1" (replace -4 :hide? t)
                              (("1"
                                (assert)
                                (("1"
                                  (skeep :preds? t)
                                  (("1"
                                    (expand "val" 1)
                                    (("1"
                                      (iff)
                                      (("1"
                                        (split)
                                        (("1"
                                          (flatten)
                                          (("1"
                                            (insteep -)
                                            (("1"
                                              (insteep -)
                                              (("1" (assert) nil nil))
                                              nil))
                                            nil))
                                          nil)
                                         ("2"
                                          (flatten)
                                          (("2"
                                            (insteep -)
                                            (("2"
                                              (insteep -)
                                              (("2" (assert) nil nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil)
                     ("2" (expand "create_new_CEB")
                      (("2" (expand "make_ceb")
                        (("2" (expand "bottomLess?")
                          (("2" (flatten)
                            (("2" (replace -4 :hide? t)
                              (("2" (assert) nil nil)) nil))
                            nil))
                          nil))
                        nil))
                      nil)
                     ("3" (expand "create_new_CEB")
                      (("3" (expand "make_ceb")
                        (("3" (replace -4) (("3" (assert) nil nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (expand "member") (("2" (propax) nil nil)) nil))
                nil)
               ("2" (expand "member") (("2" (propax) nil nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((map const-decl "setof[T2]" more_set_props "sets_aux/")
    (Domain type-eq-decl nil domain nil)
    (CEB type-eq-decl nil domain nil)
    (RAExprDomain type-decl nil domain nil)
    (RBExpr type-decl nil expressions nil)
    (FPAExprDomain type-decl nil domain nil)
    (FPBExpr type-decl nil expressions nil)
    (FtoR const-decl "InducedREnv(fpEnv)" expressions_semantics nil)
    (InducedREnv nonempty-type-eq-decl nil expressions_semantics nil)
    (REnvironment nonempty-type-eq-decl nil expressions_semantics nil)
    (RNumber nonempty-type-eq-decl nil expressions nil)
    (FPEnvironment nonempty-type-eq-decl nil expressions_semantics nil)
    (FPNumber nonempty-type-eq-decl nil expressions nil)
    (ParameterIndex nonempty-type-eq-decl nil expressions nil)
    (make_ceb const-decl "CEB" domain nil))
   nil))
 (sem_TCC10 0
  (sem_TCC10-3 nil 3732701613 ("" (termination-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (Operator formal-nonempty-type-decl nil semantics nil)
    (RealNumber formal-nonempty-type-decl nil semantics nil)
    (FloatingPointNumber formal-nonempty-type-decl nil semantics nil)
    (FtoR formal-const-decl "[FloatingPointNumber -> RealNumber]"
     semantics nil)
    (FPBExpr type-decl nil expressions nil)
    (pred type-eq-decl nil defined_types nil)
    (strict_total_order? const-decl "bool" orders nil)
    (lt_r formal-const-decl "(strict_total_order?[RealNumber])"
     semantics nil)
    (applyFun_r formal-const-decl
     "[[Operator, RealNumber, RealNumber] -> RealNumber]" semantics
     nil)
    (lt_fp formal-const-decl
     "(strict_total_order?[FloatingPointNumber])" semantics nil)
    (applyFun_fp formal-const-decl
     "[[Operator, FloatingPointNumber, FloatingPointNumber] ->
   FloatingPointNumber]" semantics nil)
    (FPAExprDomain type-decl nil domain nil)
    (RBExpr type-decl nil expressions nil)
    (RAExprDomain type-decl nil domain nil)
    (CEB type-eq-decl nil domain nil) (set type-eq-decl nil sets nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (every adt-def-decl "boolean" list_adt nil)
    (finite_nonempty? const-decl "bool" more_set_defs "sets_aux/")
    (Environment nonempty-type-eq-decl nil semantics nil)
    (validEnvironmentForStmt const-decl "bool" semantics nil)
    (FPAExpr type-decl nil expressions nil)
    (wellFormed? inductive-decl "bool" expressions nil)
    (Domain type-eq-decl nil domain nil)
    (length def-decl "nat" list_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (<< adt-def-decl "(strict_well_founded?[FPAExpr])" expressions nil)
    (appears? const-decl "bool" semantics nil)
    (appears? const-decl "bool" domain nil)
    (appears? const-decl "bool" domain nil)
    (appears? const-decl "bool" expressions nil)
    (FtoR def-decl "RAExpr" expressions nil)
    (appears? const-decl "bool" expressions nil)
    (conditionsHold? const-decl "bool" semantics nil)
    (conditionsHold? const-decl "bool" semantics nil)
    (conditionsHold? const-decl "bool" semantics nil)
    (stable? const-decl "bool" semantics nil)
    (stable? const-decl "bool" semantics nil)
    (bottomLess? const-decl "bool" semantics nil)
    (bottomLess? const-decl "bool" semantics nil)
    (bottomLess? const-decl "bool" semantics nil)
    (/= const-decl "boolean" notequal nil))
   nil)
  (sem_TCC10-2 nil 3732643554 ("" (termination-tcc) nil nil)
   ((FPBExpr type-decl nil expressions nil)
    (FPAExprDomain type-decl nil domain nil)
    (RBExpr type-decl nil expressions nil)
    (RAExprDomain type-decl nil domain nil)
    (CEB type-eq-decl nil domain nil)
    (FPAExpr type-decl nil expressions nil)
    (wellFormed? inductive-decl "bool" expressions nil)
    (Domain type-eq-decl nil domain nil)
    (<< adt-def-decl "(strict_well_founded?[FPAExpr])" expressions
     nil))
   nil)
  (sem_TCC10-1 nil 3731411566
   ("" (skeep* :preds? t)
    (("" (assert)
      (("" (case "aexpr = FPOperator(op, arg1, arg2)")
        (("1" (label "aexpr" -1)
          (("1" (replace "aexpr" :hide? t)
            (("1" (expand "wellFormed?" -) (("1" (propax) nil nil))
              nil))
            nil))
          nil)
         ("2" (propax) nil nil))
        nil))
      nil))
    nil)
   ((wellFormed? inductive-decl "bool" expressions nil)
    (FPAExpr type-decl nil expressions nil)
    (FPOperator? adt-recognizer-decl "[FPAExpr -> boolean]" expressions
     nil)
    (FPOperator adt-constructor-decl
     "[[Operator, FPAExpr, FPAExpr] -> (FPOperator?)]" expressions
     nil))
   nil))
 (sem_expr_var_fpconds_TCC1 0
  (sem_expr_var_fpconds_TCC1-1 nil 3753464405
   ("" (skeep :preds? t)
    (("" (expand "wellFormed?" -5) (("" (assert) nil nil)) nil)) nil)
   ((wellFormed? inductive-decl "bool" expressions nil)) nil))
 (sem_expr_var_fpconds 0
  (sem_expr_var_fpconds-1 nil 3753464405 ("" (grind) nil nil)
   ((sem def-decl "(validDomain)" semantics nil)) shostak))
 (sem_expr_cnt_fpconds 0
  (sem_expr_cnt_fpconds-1 nil 3753463648 ("" (grind) nil nil)
   ((NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (FPBExpr type-decl nil expressions nil)
    (FPAExprDomain type-decl nil domain nil)
    (RBExpr type-decl nil expressions nil)
    (RAExprDomain type-decl nil domain nil)
    (CEB type-eq-decl nil domain nil) (set type-eq-decl nil sets nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (every adt-def-decl "boolean" list_adt nil)
    (finite_nonempty? const-decl "bool" more_set_defs "sets_aux/")
    (Environment nonempty-type-eq-decl nil semantics nil)
    (validEnvironmentForStmt const-decl "bool" semantics nil)
    (FPAExpr type-decl nil expressions nil)
    (wellFormed? inductive-decl "bool" expressions nil)
    (FPConstant? adt-recognizer-decl "[FPAExpr -> boolean]" expressions
     nil)
    (FPConstant adt-constructor-decl "[FPNumber -> (FPConstant?)]"
     expressions nil)
    (FPNumber nonempty-type-eq-decl nil expressions nil)
    (Domain type-eq-decl nil domain nil)
    (length def-decl "nat" list_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (appears? const-decl "bool" semantics nil)
    (appears? const-decl "bool" domain nil)
    (appears? const-decl "bool" domain nil)
    (appears? const-decl "bool" expressions nil)
    (appears? const-decl "bool" expressions nil)
    (conditionsHold? const-decl "bool" semantics nil)
    (conditionsHold? const-decl "bool" semantics nil)
    (conditionsHold? const-decl "bool" semantics nil)
    (stable? const-decl "bool" semantics nil)
    (stable? const-decl "bool" semantics nil)
    (bottomLess? const-decl "bool" semantics nil)
    (bottomLess? const-decl "bool" semantics nil)
    (bottomLess? const-decl "bool" semantics nil)
    (/= const-decl "boolean" notequal nil)
    (FtoR formal-const-decl "[FloatingPointNumber -> RealNumber]"
     semantics nil)
    (FloatingPointNumber formal-nonempty-type-decl nil semantics nil)
    (RealNumber formal-nonempty-type-decl nil semantics nil)
    (Operator formal-nonempty-type-decl nil semantics nil)
    (FtoR def-decl "RAExpr" expressions nil)
    (applyFun_fp formal-const-decl
     "[[Operator, FloatingPointNumber, FloatingPointNumber] ->
   FloatingPointNumber]" semantics nil)
    (lt_fp formal-const-decl
     "(strict_total_order?[FloatingPointNumber])" semantics nil)
    (applyFun_r formal-const-decl
     "[[Operator, RealNumber, RealNumber] -> RealNumber]" semantics
     nil)
    (lt_r formal-const-decl "(strict_total_order?[RealNumber])"
     semantics nil)
    (strict_total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (FtoR def-decl "RAExprDomain" domain nil)
    (make_ceb const-decl "CEB" domain nil)
    (sem def-decl "(validDomain)" semantics nil)
    (singleton const-decl "(singleton?)" sets nil))
   shostak))
 (sem_expr_par_fpconds 0
  (sem_expr_par_fpconds-1 nil 3753465810 ("" (grind) nil nil)
   ((NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (FPBExpr type-decl nil expressions nil)
    (FPAExprDomain type-decl nil domain nil)
    (RBExpr type-decl nil expressions nil)
    (RAExprDomain type-decl nil domain nil)
    (CEB type-eq-decl nil domain nil) (set type-eq-decl nil sets nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (every adt-def-decl "boolean" list_adt nil)
    (finite_nonempty? const-decl "bool" more_set_defs "sets_aux/")
    (Environment nonempty-type-eq-decl nil semantics nil)
    (validEnvironmentForStmt const-decl "bool" semantics nil)
    (FPAExpr type-decl nil expressions nil)
    (wellFormed? inductive-decl "bool" expressions nil)
    (ParameterIndex nonempty-type-eq-decl nil expressions nil)
    (FPParameter? adt-recognizer-decl "[FPAExpr -> boolean]"
     expressions nil)
    (FPParameter adt-constructor-decl
     "[ParameterIndex -> (FPParameter?)]" expressions nil)
    (Domain type-eq-decl nil domain nil)
    (length def-decl "nat" list_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (appears? const-decl "bool" semantics nil)
    (appears? const-decl "bool" domain nil)
    (appears? const-decl "bool" domain nil)
    (appears? const-decl "bool" expressions nil)
    (appears? const-decl "bool" expressions nil)
    (conditionsHold? const-decl "bool" semantics nil)
    (conditionsHold? const-decl "bool" semantics nil)
    (conditionsHold? const-decl "bool" semantics nil)
    (stable? const-decl "bool" semantics nil)
    (stable? const-decl "bool" semantics nil)
    (bottomLess? const-decl "bool" semantics nil)
    (bottomLess? const-decl "bool" semantics nil)
    (bottomLess? const-decl "bool" semantics nil)
    (/= const-decl "boolean" notequal nil)
    (FtoR formal-const-decl "[FloatingPointNumber -> RealNumber]"
     semantics nil)
    (FloatingPointNumber formal-nonempty-type-decl nil semantics nil)
    (RealNumber formal-nonempty-type-decl nil semantics nil)
    (Operator formal-nonempty-type-decl nil semantics nil)
    (FtoR def-decl "RAExpr" expressions nil)
    (applyFun_fp formal-const-decl
     "[[Operator, FloatingPointNumber, FloatingPointNumber] ->
   FloatingPointNumber]" semantics nil)
    (lt_fp formal-const-decl
     "(strict_total_order?[FloatingPointNumber])" semantics nil)
    (applyFun_r formal-const-decl
     "[[Operator, RealNumber, RealNumber] -> RealNumber]" semantics
     nil)
    (lt_r formal-const-decl "(strict_total_order?[RealNumber])"
     semantics nil)
    (strict_total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (FtoR def-decl "RAExprDomain" domain nil)
    (make_ceb const-decl "CEB" domain nil)
    (sem def-decl "(validDomain)" semantics nil)
    (singleton const-decl "(singleton?)" sets nil))
   shostak))
 (sem_expr_opr_fpconds 0
  (sem_expr_opr_fpconds-1 nil 3753465873
   ("" (skeep :preds? t)
    (("" (expand "sem" -)
      (("" (expand "map")
        (("" (skeep -)
          (("" (inst 1 "nth(y,0)" "nth(y,1)")
            (("1" (expand "create_new_CEB")
              (("1" (expand "make_ceb")
                (("1" (replace -5 :hide? t) (("1" (assert) nil nil))
                  nil))
                nil))
              nil)
             ("2" (typepred "y")
              (("2" (rewrite "cartesian_product_intensional_def")
                (("2" (assert)
                  (("2" (flatten)
                    (("2" (expand "member") (("2" (propax) nil nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil)
             ("3" (typepred "y")
              (("3" (rewrite "cartesian_product_intensional_def")
                (("3" (assert)
                  (("3" (flatten)
                    (("3" (expand "member") (("3" (propax) nil nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((sem def-decl "(validDomain)" semantics nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nil application-judgement "above(1)" semantics nil)
    (cartesian_product_intensional_def formula-decl nil semantics nil)
    (create_new_CEB const-decl "CEB" semantics nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (make_ceb const-decl "CEB" domain nil)
    (Operator formal-nonempty-type-decl nil semantics nil)
    (RealNumber formal-nonempty-type-decl nil semantics nil)
    (FloatingPointNumber formal-nonempty-type-decl nil semantics nil)
    (FtoR formal-const-decl "[FloatingPointNumber -> RealNumber]"
     semantics nil)
    (FPAExpr type-decl nil expressions nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (FPBExpr type-decl nil expressions nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (pred type-eq-decl nil defined_types nil)
    (strict_total_order? const-decl "bool" orders nil)
    (lt_r formal-const-decl "(strict_total_order?[RealNumber])"
     semantics nil)
    (applyFun_r formal-const-decl
     "[[Operator, RealNumber, RealNumber] -> RealNumber]" semantics
     nil)
    (lt_fp formal-const-decl
     "(strict_total_order?[FloatingPointNumber])" semantics nil)
    (applyFun_fp formal-const-decl
     "[[Operator, FloatingPointNumber, FloatingPointNumber] ->
   FloatingPointNumber]" semantics nil)
    (FPAExprDomain type-decl nil domain nil)
    (RBExpr type-decl nil expressions nil)
    (RAExprDomain type-decl nil domain nil)
    (CEB type-eq-decl nil domain nil) (set type-eq-decl nil sets nil)
    (list type-decl nil list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (every adt-def-decl "boolean" list_adt nil)
    (finite_nonempty? const-decl "bool" more_set_defs "sets_aux/")
    (Environment nonempty-type-eq-decl nil semantics nil)
    (validEnvironmentForStmt const-decl "bool" semantics nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (wellFormed? inductive-decl "bool" expressions nil)
    (Domain type-eq-decl nil domain nil)
    (length def-decl "nat" list_props nil)
    (validDomain const-decl "bool" semantics nil)
    (expr1 skolem-const-decl
     "FPAExpr[Operator, RealNumber, FloatingPointNumber, FtoR]"
     semantics nil)
    (nargs skolem-const-decl "nat" semantics nil)
    (FPOperator? adt-recognizer-decl "[FPAExpr -> boolean]" expressions
     nil)
    (FPOperator adt-constructor-decl
     "[[Operator, FPAExpr, FPAExpr] -> (FPOperator?)]" expressions nil)
    (op skolem-const-decl "Operator" semantics nil)
    (expr2 skolem-const-decl
     "FPAExpr[Operator, RealNumber, FloatingPointNumber, FtoR]"
     semantics nil)
    (env skolem-const-decl "{env: (validEnvironmentForStmt) |
         wellFormed?(FPOperator(op, expr1, expr2), nargs, length(env))}"
     semantics nil)
    (< const-decl "bool" reals nil)
    (below type-eq-decl nil nat_types nil)
    (nth def-decl "T" list_props nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (PairCEB nonempty-type-eq-decl nil semantics nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (member const-decl "bool" sets nil)
    (cartesian_product def-decl "{fne |
         fne =
          ({p: PairCEB |
              member(nth(p, 0), dom1) AND member(nth(p, 1), dom2)})}"
     semantics nil)
    (y skolem-const-decl
     "(cartesian_product(sem(expr1, nargs, env), sem(expr2, nargs, env)))"
     semantics nil)
    (map const-decl "setof[T2]" more_set_props "sets_aux/"))
   shostak))
 (sem_expr_opr_rconds 0
  (sem_expr_opr_rconds-1 nil 3755345495
   ("" (skeep :preds? t)
    (("" (expand "sem" -)
      (("" (expand "map")
        (("" (skeep -)
          (("" (inst 1 "nth(y,0)" "nth(y,1)")
            (("1" (expand "create_new_CEB")
              (("1" (expand "make_ceb")
                (("1" (replace -5 :hide? t) (("1" (assert) nil nil))
                  nil))
                nil))
              nil)
             ("2" (typepred "y")
              (("2" (rewrite "cartesian_product_intensional_def")
                (("2" (assert)
                  (("2" (flatten)
                    (("2" (expand "member") (("2" (propax) nil nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil)
             ("3" (typepred "y")
              (("3" (rewrite "cartesian_product_intensional_def")
                (("3" (assert)
                  (("3" (flatten)
                    (("3" (expand "member") (("3" (propax) nil nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((sem def-decl "(validDomain)" semantics nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nil application-judgement "above(1)" semantics nil)
    (cartesian_product_intensional_def formula-decl nil semantics nil)
    (create_new_CEB const-decl "CEB" semantics nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (make_ceb const-decl "CEB" domain nil)
    (Operator formal-nonempty-type-decl nil semantics nil)
    (RealNumber formal-nonempty-type-decl nil semantics nil)
    (FloatingPointNumber formal-nonempty-type-decl nil semantics nil)
    (FtoR formal-const-decl "[FloatingPointNumber -> RealNumber]"
     semantics nil)
    (FPAExpr type-decl nil expressions nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (FPBExpr type-decl nil expressions nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (pred type-eq-decl nil defined_types nil)
    (strict_total_order? const-decl "bool" orders nil)
    (lt_r formal-const-decl "(strict_total_order?[RealNumber])"
     semantics nil)
    (applyFun_r formal-const-decl
     "[[Operator, RealNumber, RealNumber] -> RealNumber]" semantics
     nil)
    (lt_fp formal-const-decl
     "(strict_total_order?[FloatingPointNumber])" semantics nil)
    (applyFun_fp formal-const-decl
     "[[Operator, FloatingPointNumber, FloatingPointNumber] ->
   FloatingPointNumber]" semantics nil)
    (FPAExprDomain type-decl nil domain nil)
    (RBExpr type-decl nil expressions nil)
    (RAExprDomain type-decl nil domain nil)
    (CEB type-eq-decl nil domain nil) (set type-eq-decl nil sets nil)
    (list type-decl nil list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (every adt-def-decl "boolean" list_adt nil)
    (finite_nonempty? const-decl "bool" more_set_defs "sets_aux/")
    (Environment nonempty-type-eq-decl nil semantics nil)
    (validEnvironmentForStmt const-decl "bool" semantics nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (wellFormed? inductive-decl "bool" expressions nil)
    (Domain type-eq-decl nil domain nil)
    (length def-decl "nat" list_props nil)
    (validDomain const-decl "bool" semantics nil)
    (expr1 skolem-const-decl
     "FPAExpr[Operator, RealNumber, FloatingPointNumber, FtoR]"
     semantics nil)
    (nargs skolem-const-decl "nat" semantics nil)
    (FPOperator? adt-recognizer-decl "[FPAExpr -> boolean]" expressions
     nil)
    (FPOperator adt-constructor-decl
     "[[Operator, FPAExpr, FPAExpr] -> (FPOperator?)]" expressions nil)
    (op skolem-const-decl "Operator" semantics nil)
    (expr2 skolem-const-decl
     "FPAExpr[Operator, RealNumber, FloatingPointNumber, FtoR]"
     semantics nil)
    (env skolem-const-decl "{env: (validEnvironmentForStmt) |
         wellFormed?(FPOperator(op, expr1, expr2), nargs, length(env))}"
     semantics nil)
    (< const-decl "bool" reals nil)
    (below type-eq-decl nil nat_types nil)
    (nth def-decl "T" list_props nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (PairCEB nonempty-type-eq-decl nil semantics nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (member const-decl "bool" sets nil)
    (cartesian_product def-decl "{fne |
         fne =
          ({p: PairCEB |
              member(nth(p, 0), dom1) AND member(nth(p, 1), dom2)})}"
     semantics nil)
    (y skolem-const-decl
     "(cartesian_product(sem(expr1, nargs, env), sem(expr2, nargs, env)))"
     semantics nil)
    (map const-decl "setof[T2]" more_set_props "sets_aux/"))
   nil))
 (sem_expr_does_not_add_vars_to_ceb_TCC1 0
  (sem_expr_does_not_add_vars_to_ceb_TCC1-1 nil 3754570431
   ("" (subtype-tcc) nil nil) nil nil))
 (sem_expr_does_not_add_vars_to_ceb 0
  (sem_expr_does_not_add_vars_to_ceb-1 nil 3754570497
   ("" (skeep :but "expr")
    (("" (induct "expr")
      (("1" (grind) nil nil) ("2" (grind) nil nil)
       ("3" (skolem 1 "index")
        (("3" (flatten)
          (("3" (rewrite "appears?_dom_int_def")
            (("3" (skolem -2 "ceb_var" :skolem-typepreds? t)
              (("3" (rewrite "appears?_ceb_int_def")
                (("3" (use "sem_expr_var_fpconds")
                  (("3" (assert)
                    (("3" (rewrite "appears?_env_int_def")
                      (("3" (inst 1 "nth(env,index)")
                        (("1" (rewrite "appears?_dom_int_def")
                          (("1" (inst 1 "ceb_var")
                            (("1" (rewrite "appears?_ceb_int_def") nil
                              nil))
                            nil))
                          nil)
                         ("2" (use "nth_member[Domain]") nil nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("4" (grind) nil nil)
       ("5" (skolem 1 ("op" "e1" "e2"))
        (("5" (flatten)
          (("5" (rewrite "appears?_dom_int_def" -4)
            (("5" (skolem -4 "ceb_op" :skolem-typepreds? t)
              (("5" (use "sem_expr_opr_fpconds")
                (("5" (use "sem_expr_opr_rconds")
                  (("5" (assert)
                    (("5"
                      (skeep -1 :but
                       (("ceb1" "ceb1r") ("ceb2" "ceb2r")) :preds? t)
                      (("5"
                        (skeep -4 :but
                         (("ceb1" "ceb1f") ("ceb2" "ceb2f")) :preds? t)
                        (("5" (rewrite "appears?_ceb_int_def")
                          (("5" (replace -5 :hide? t)
                            (("5" (replace -5 :hide? t)
                              (("5"
                                (rewrite "appears?_form_int_def_and")
                                (("5"
                                  (rewrite
                                   "appears?_rform_int_def_and")
                                  (("5"
                                    (rewrite "wellFormed?_expr_op")
                                    (("5"
                                      (flatten)
                                      (("5"
                                        (assert)
                                        (("5"
                                          (split -8)
                                          (("1"
                                            (rewrite
                                             "appears?_dom_int_def")
                                            (("1"
                                              (inst 1 "ceb1f")
                                              (("1"
                                                (rewrite
                                                 "appears?_ceb_int_def")
                                                (("1"
                                                  (assert)
                                                  nil
                                                  nil))
                                                nil))
                                              nil))
                                            nil)
                                           ("2"
                                            (rewrite
                                             "appears?_dom_int_def"
                                             2)
                                            (("2"
                                              (inst 2 "ceb2f")
                                              (("2"
                                                (rewrite
                                                 "appears?_ceb_int_def")
                                                (("2"
                                                  (assert)
                                                  nil
                                                  nil))
                                                nil))
                                              nil))
                                            nil)
                                           ("3"
                                            (rewrite
                                             "appears?_dom_int_def")
                                            (("3"
                                              (inst 1 "ceb1r")
                                              (("3"
                                                (rewrite
                                                 "appears?_ceb_int_def")
                                                (("3"
                                                  (assert)
                                                  nil
                                                  nil))
                                                nil))
                                              nil))
                                            nil)
                                           ("4"
                                            (rewrite
                                             "appears?_dom_int_def"
                                             2)
                                            (("4"
                                              (inst 2 "ceb2r")
                                              (("4"
                                                (rewrite
                                                 "appears?_ceb_int_def")
                                                (("4"
                                                  (assert)
                                                  nil
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((FPAExpr type-decl nil expressions nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (wellFormed? inductive-decl "bool" expressions nil)
    (FPBExpr type-decl nil expressions nil)
    (pred type-eq-decl nil defined_types nil)
    (strict_total_order? const-decl "bool" orders nil)
    (lt_r formal-const-decl "(strict_total_order?[RealNumber])"
     semantics nil)
    (applyFun_r formal-const-decl
     "[[Operator, RealNumber, RealNumber] -> RealNumber]" semantics
     nil)
    (lt_fp formal-const-decl
     "(strict_total_order?[FloatingPointNumber])" semantics nil)
    (applyFun_fp formal-const-decl
     "[[Operator, FloatingPointNumber, FloatingPointNumber] ->
   FloatingPointNumber]" semantics nil)
    (FPAExprDomain type-decl nil domain nil)
    (RBExpr type-decl nil expressions nil)
    (RAExprDomain type-decl nil domain nil)
    (CEB type-eq-decl nil domain nil) (set type-eq-decl nil sets nil)
    (list type-decl nil list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (every adt-def-decl "boolean" list_adt nil)
    (finite_nonempty? const-decl "bool" more_set_defs "sets_aux/")
    (Domain type-eq-decl nil domain nil)
    (length def-decl "nat" list_props nil)
    (Environment nonempty-type-eq-decl nil semantics nil)
    (validEnvironmentForStmt const-decl "bool" semantics nil)
    (FPVariable? adt-recognizer-decl "[FPAExpr -> boolean]" expressions
     nil)
    (appears? const-decl "bool" domain nil)
    (validDomain const-decl "bool" semantics nil)
    (sem def-decl "(validDomain)" semantics nil)
    (appears? const-decl "bool" semantics nil)
    (FtoR formal-const-decl "[FloatingPointNumber -> RealNumber]"
     semantics nil)
    (FloatingPointNumber formal-nonempty-type-decl nil semantics nil)
    (RealNumber formal-nonempty-type-decl nil semantics nil)
    (Operator formal-nonempty-type-decl nil semantics nil)
    (FPAExpr_induction formula-decl nil expressions nil)
    (appearsFree? def-decl "bool" expressions nil)
    (appearsFree? def-decl "bool" expressions nil)
    (nonempty_singleton_finite application-judgement
     "non_empty_finite_set" finite_sets nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (singleton? const-decl "bool" sets nil)
    (singleton const-decl "(singleton?)" sets nil)
    (RTrue? adt-recognizer-decl "[RBExpr -> boolean]" expressions nil)
    (RTrue adt-constructor-decl "(RTrue?)" expressions nil)
    (FPTrue? adt-recognizer-decl "[FPBExpr -> boolean]" expressions
     nil)
    (FPTrue adt-constructor-decl "(FPTrue?)" expressions nil)
    (RAExpr type-decl nil expressions nil)
    (RAExpr? adt-recognizer-decl "[RAExprDomain -> boolean]" domain
     nil)
    (RAExpr adt-constructor-decl
     "[RAExpr[Operator, RealNumber, FloatingPointNumber, FtoR] -> (RAExpr?)]"
     domain nil)
    (RConstant? adt-recognizer-decl "[RAExpr -> boolean]" expressions
     nil)
    (RConstant adt-constructor-decl "[RNumber -> (RConstant?)]"
     expressions nil)
    (FPNumber nonempty-type-eq-decl nil expressions nil)
    (FPAExpr? adt-recognizer-decl "[FPAExprDomain -> boolean]" domain
     nil)
    (FPAExpr adt-constructor-decl
     "[FPAExpr[Operator, RealNumber, FloatingPointNumber, FtoR] -> (FPAExpr?)]"
     domain nil)
    (FPConstant? adt-recognizer-decl "[FPAExpr -> boolean]" expressions
     nil)
    (FPConstant adt-constructor-decl "[FPNumber -> (FPConstant?)]"
     expressions nil)
    (TRUE const-decl "bool" booleans nil)
    (appears? const-decl "bool" domain nil)
    (appears? const-decl "bool" expressions nil)
    (appears? const-decl "bool" expressions nil)
    (make_ceb const-decl "CEB" domain nil)
    (FtoR def-decl "RAExprDomain" domain nil)
    (FtoR def-decl "RAExpr" expressions nil)
    (sem_expr_var_fpconds formula-decl nil semantics nil)
    (appears?_env_int_def formula-decl nil semantics nil)
    (below type-eq-decl nil naturalnumbers nil)
    (nth_member formula-decl nil more_list_props "structures/")
    (index skolem-const-decl
           "DeBruijnIndex[Operator, RealNumber, FloatingPointNumber, FtoR]"
           semantics nil)
    (env skolem-const-decl "(validEnvironmentForStmt)" semantics nil)
    (nth def-decl "T" list_props nil)
    (below type-eq-decl nil nat_types nil)
    (< const-decl "bool" reals nil)
    (member def-decl "bool" list_props nil)
    (ftor_fpvar_rvar_j application-judgement "(RVariable?)" semantics
     nil)
    (appears?_ceb_int_def formula-decl nil domain nil)
    (appears?_dom_int_def formula-decl nil domain nil)
    (DeBruijnIndex nonempty-type-eq-decl nil expressions nil)
    (FPVariable adt-constructor-decl "[DeBruijnIndex -> (FPVariable?)]"
     expressions nil)
    (ParameterIndex nonempty-type-eq-decl nil expressions nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (RParameter? adt-recognizer-decl "[RAExpr -> boolean]" expressions
     nil)
    (RParameter adt-constructor-decl
     "[ParameterIndex -> (RParameter?)]" expressions nil)
    (FPParameter? adt-recognizer-decl "[FPAExpr -> boolean]"
     expressions nil)
    (FPParameter adt-constructor-decl
     "[ParameterIndex -> (FPParameter?)]" expressions nil)
    (sem_expr_opr_rconds formula-decl nil semantics nil)
    (RVariable? adt-recognizer-decl "[RAExpr -> boolean]" expressions
     nil)
    (appears?_rform_int_def_and formula-decl nil expressions nil)
    (wellFormed?_expr_op formula-decl nil expressions nil)
    (appears?_form_int_def_and formula-decl nil expressions nil)
    (sem_expr_opr_fpconds formula-decl nil semantics nil)
    (FPOperator? adt-recognizer-decl "[FPAExpr -> boolean]" expressions
     nil)
    (FPOperator adt-constructor-decl
     "[[Operator, FPAExpr, FPAExpr] -> (FPOperator?)]" expressions
     nil))
   shostak))
 (max_local_index_aexpr 0
  (max_local_index_aexpr-1 nil 3753782913
   ("" (induct "expr")
    (("1" (skolem 1 "ct")
      (("1" (skeep :preds? t)
        (("1"
          (case "maxFreeLocalIndex(sem(FPConstant(ct), nargs, env)) <= -1")
          (("1" (assert) nil nil)
           ("2" (use "max_local_index_dom_def")
            (("2" (flatten)
              (("2" (skolem -2 "ceb_max" :skolem-typepreds? t)
                (("2" (replace -3 :hide? t :dir rl)
                  (("2" (expand "sem" -1)
                    (("2" (expand "singleton")
                      (("2" (expand "make_ceb") (("2" (grind) nil nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("2" (skolem 1 "i")
      (("2" (skeep :preds? t)
        (("2" (expand "sem")
          (("2"
            (case "length
          [Domain
               [Operator, RealNumber, lt_r, applyFun_r,
                FloatingPointNumber, lt_fp, applyFun_fp, FtoR]]
          (env)
       - 1
       - i
       >= 0")
            (("1" (assert)
              (("1" (hide -1)
                (("1" (use "max_local_index_env_ge_dom")
                  (("1" (assert)
                    (("1" (use "nth_member[Domain]") nil nil)) nil))
                  nil))
                nil))
              nil)
             ("2" (expand "wellFormed?") (("2" (grind) nil nil)) nil))
            nil))
          nil))
        nil))
      nil)
     ("3" (skolem 1 "i")
      (("3" (skeep :preds? t)
        (("3"
          (case "maxFreeLocalIndex(sem(FPParameter(i), nargs, env)) <= -1")
          (("1" (assert) nil nil)
           ("2" (use "max_local_index_dom_def")
            (("2" (flatten)
              (("2" (skolem -2 "ceb_max" :skolem-typepreds? t)
                (("2" (replace -3 :hide? t :dir rl)
                  (("2" (expand "sem") (("2" (grind) nil nil)) nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("4" (skolem 1 ("op" "a1" "a2"))
      (("4" (flatten)
        (("4" (skeep :preds? t)
          (("4" (use "max_local_index_dom_def")
            (("4" (flatten)
              (("4" (skolem -2 "ceb_max" :skolem-typepreds? t)
                (("4" (replace -3 :hide? t :dir rl)
                  (("4" (expand "sem" -1)
                    (("4" (expand "map")
                      (("4" (skolem -1 "maxPair" :skolem-typepreds? t)
                        (("4" (replace -3 :hide? t)
                          (("4" (expand "create_new_CEB")
                            (("4" (expand "make_ceb")
                              (("4"
                                (use "max_local_index_ceb_def")
                                (("4"
                                  (replace -1 :hide? t :dir rl)
                                  (("4"
                                    (rewrite
                                     "max_local_index_stmt_and_def")
                                    (("4"
                                      (inst -8 "nargs" "env")
                                      (("4"
                                        (inst -9 "nargs" "env")
                                        (("4"
                                          (rewrite
                                           "cartesian_product_intensional_def")
                                          (("4"
                                            (assert)
                                            (("4"
                                              (flatten)
                                              (("4"
                                                (use
                                                 "max_local_index_dom_ge_ceb")
                                                (("1"
                                                  (lemma
                                                   "max_local_index_dom_ge_ceb")
                                                  (("1"
                                                    (inst
                                                     -1
                                                     "sem(a2, nargs, env)"
                                                     "nth(maxPair, 1)")
                                                    (("1"
                                                      (assert)
                                                      (("1"
                                                        (grind)
                                                        nil
                                                        nil))
                                                      nil)
                                                     ("2"
                                                      (expand "member")
                                                      (("2"
                                                        (propax)
                                                        nil
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil)
                                                 ("2"
                                                  (expand "member")
                                                  (("2"
                                                    (propax)
                                                    nil
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((map const-decl "setof[T2]" more_set_props "sets_aux/")
    (cartesian_product_intensional_def formula-decl nil semantics nil)
    (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil)
    (car adt-accessor-decl "[(cons?) -> T]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (nil application-judgement "(finite_nonempty?[T2])" more_set_props
     "sets_aux/")
    (nil application-judgement "(nonempty?[T2])" more_set_props
     "sets_aux/")
    (finite_rest application-judgement "finite_set" finite_sets nil)
    (max const-decl "{p: real | p >= m AND p >= n}" real_defs nil)
    (remove const-decl "set" sets nil) (rest const-decl "set" sets nil)
    (empty? const-decl "bool" sets nil)
    (a1 skolem-const-decl
     "FPAExpr[Operator, RealNumber, FloatingPointNumber, FtoR]"
     semantics nil)
    (nargs skolem-const-decl "nat" semantics nil)
    (op skolem-const-decl "Operator" semantics nil)
    (a2 skolem-const-decl
     "FPAExpr[Operator, RealNumber, FloatingPointNumber, FtoR]"
     semantics nil)
    (env skolem-const-decl "{env: (validEnvironmentForStmt) |
         wellFormed?(FPOperator(op, a1, a2), nargs, length(env))}"
     semantics nil)
    (maxPair skolem-const-decl
     "(cartesian_product(sem(a1, nargs, env), sem(a2, nargs, env)))"
     semantics nil)
    (max_local_index_dom_ge_ceb formula-decl nil domain nil)
    (nil application-judgement "above(1)" semantics nil)
    (int_max application-judgement "{k: int | i <= k AND j <= k}"
     real_defs nil)
    (rat_max application-judgement "{s: rat | s >= q AND s >= r}"
     real_defs nil)
    (max_local_index_stmt_and_def formula-decl nil expressions nil)
    (RAnd? adt-recognizer-decl "[RBExpr -> boolean]" expressions nil)
    (RAnd adt-constructor-decl "[[RBExpr, RBExpr] -> (RAnd?)]"
     expressions nil)
    (PairCEB nonempty-type-eq-decl nil semantics nil)
    (member const-decl "bool" sets nil)
    (cartesian_product def-decl "{fne |
         fne =
          ({p: PairCEB |
              member(nth(p, 0), dom1) AND member(nth(p, 1), dom2)})}"
     semantics nil)
    (FPAnd? adt-recognizer-decl "[FPBExpr -> boolean]" expressions nil)
    (FPAnd adt-constructor-decl "[[FPBExpr, FPBExpr] -> (FPAnd?)]"
     expressions nil)
    (RAExpr type-decl nil expressions nil)
    (RAExpr? adt-recognizer-decl "[RAExprDomain -> boolean]" domain
     nil)
    (RAExpr adt-constructor-decl
     "[RAExpr[Operator, RealNumber, FloatingPointNumber, FtoR] -> (RAExpr?)]"
     domain nil)
    (ROperator? adt-recognizer-decl "[RAExpr -> boolean]" expressions
     nil)
    (ROperator adt-constructor-decl
     "[[Operator, RAExpr, RAExpr] -> (ROperator?)]" expressions nil)
    (RBottom? adt-recognizer-decl "[RAExprDomain -> boolean]" domain
     nil)
    (RBottom adt-constructor-decl "(RBottom?)" domain nil)
    (FPAExpr? adt-recognizer-decl "[FPAExprDomain -> boolean]" domain
     nil)
    (FPAExpr adt-constructor-decl
     "[FPAExpr[Operator, RealNumber, FloatingPointNumber, FtoR] -> (FPAExpr?)]"
     domain nil)
    (FPBottom? adt-recognizer-decl "[FPAExprDomain -> boolean]" domain
     nil)
    (FPBottom adt-constructor-decl "(FPBottom?)" domain nil)
    (TRUE const-decl "bool" booleans nil)
    (max_local_index_ceb_def formula-decl nil domain nil)
    (create_new_CEB const-decl "CEB" semantics nil)
    (FPOperator adt-constructor-decl
     "[[Operator, FPAExpr, FPAExpr] -> (FPOperator?)]" expressions nil)
    (FPOperator? adt-recognizer-decl "[FPAExpr -> boolean]" expressions
     nil)
    (FPParameter adt-constructor-decl
     "[ParameterIndex -> (FPParameter?)]" expressions nil)
    (FPParameter? adt-recognizer-decl "[FPAExpr -> boolean]"
     expressions nil)
    (ParameterIndex nonempty-type-eq-decl nil expressions nil)
    (nonempty_singleton_finite application-judgement
     "non_empty_finite_set" finite_sets nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (appears? const-decl "bool" semantics nil)
    (appears? const-decl "bool" domain nil)
    (appears? const-decl "bool" domain nil)
    (appears? const-decl "bool" expressions nil)
    (appears? const-decl "bool" expressions nil)
    (conditionsHold? const-decl "bool" semantics nil)
    (conditionsHold? const-decl "bool" semantics nil)
    (conditionsHold? const-decl "bool" semantics nil)
    (stable? const-decl "bool" semantics nil)
    (stable? const-decl "bool" semantics nil)
    (bottomLess? const-decl "bool" semantics nil)
    (bottomLess? const-decl "bool" semantics nil)
    (bottomLess? const-decl "bool" semantics nil)
    (/= const-decl "boolean" notequal nil)
    (max_local_index_env_ge_dom formula-decl nil semantics nil)
    (< const-decl "bool" reals nil)
    (below type-eq-decl nil nat_types nil)
    (nth def-decl "T" list_props nil)
    (below type-eq-decl nil naturalnumbers nil)
    (nth_member formula-decl nil more_list_props "structures/")
    (FPVariable adt-constructor-decl "[DeBruijnIndex -> (FPVariable?)]"
     expressions nil)
    (FPVariable? adt-recognizer-decl "[FPAExpr -> boolean]" expressions
     nil)
    (DeBruijnIndex nonempty-type-eq-decl nil expressions nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (FPNumber nonempty-type-eq-decl nil expressions nil)
    (FPConstant adt-constructor-decl "[FPNumber -> (FPConstant?)]"
     expressions nil)
    (FPConstant? adt-recognizer-decl "[FPAExpr -> boolean]" expressions
     nil)
    (minus_odd_is_odd application-judgement "odd_int" integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (singleton const-decl "(singleton?)" sets nil)
    (FtoR def-decl "RAExpr" expressions nil)
    (FtoR def-decl "RAExprDomain" domain nil)
    (maxFreeLocalIndex def-decl "{max: upfrom(-1) |
         IF EXISTS (local: (FPVariable?)): appears?(form)(local)
           THEN (EXISTS (local: (FPVariable?) | appears?(form)(local)):
                   index(local) = max)
                 AND
                 (FORALL (local: (FPVariable?) | appears?(form)(local)):
                    index(local) <= max)
         ELSE max = -1
         ENDIF}" expressions nil)
    (make_ceb const-decl "CEB" domain nil)
    (max_local_index_dom_def formula-decl nil domain nil)
    (FPAExpr_induction formula-decl nil expressions nil)
    (Operator formal-nonempty-type-decl nil semantics nil)
    (RealNumber formal-nonempty-type-decl nil semantics nil)
    (FloatingPointNumber formal-nonempty-type-decl nil semantics nil)
    (FtoR formal-const-decl "[FloatingPointNumber -> RealNumber]"
     semantics nil)
    (maxFreeLocalIndex def-decl "upfrom(-1)" semantics nil)
    (sem def-decl "(validDomain)" semantics nil)
    (validDomain const-decl "bool" semantics nil)
    (maxFreeLocalIndex def-decl "{m: upfrom(-1) |
         (FORALL (ceb: (dom)): maxFreeLocalIndex(ceb) <= m) AND
          (EXISTS (ceb: (dom)): maxFreeLocalIndex(ceb) = m)}" domain
     nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (maxFreeLocalIndex const-decl "upfrom(-1)" domain nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (upfrom nonempty-type-eq-decl nil integers nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (<= const-decl "bool" reals nil)
    (length def-decl "nat" list_props nil)
    (Domain type-eq-decl nil domain nil)
    (wellFormed? inductive-decl "bool" expressions nil)
    (validEnvironmentForStmt const-decl "bool" semantics nil)
    (Environment nonempty-type-eq-decl nil semantics nil)
    (finite_nonempty? const-decl "bool" more_set_defs "sets_aux/")
    (every adt-def-decl "boolean" list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil) (set type-eq-decl nil sets nil)
    (CEB type-eq-decl nil domain nil)
    (RAExprDomain type-decl nil domain nil)
    (RBExpr type-decl nil expressions nil)
    (FPAExprDomain type-decl nil domain nil)
    (applyFun_fp formal-const-decl
     "[[Operator, FloatingPointNumber, FloatingPointNumber] ->
   FloatingPointNumber]" semantics nil)
    (lt_fp formal-const-decl
     "(strict_total_order?[FloatingPointNumber])" semantics nil)
    (applyFun_r formal-const-decl
     "[[Operator, RealNumber, RealNumber] -> RealNumber]" semantics
     nil)
    (lt_r formal-const-decl "(strict_total_order?[RealNumber])"
     semantics nil)
    (strict_total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (FPBExpr type-decl nil expressions nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (FPAExpr type-decl nil expressions nil))
   shostak))
 (well_formed_env_implies_well_formed_sem_aexpr 0
  (well_formed_env_implies_well_formed_sem_aexpr-1 nil 3753462588
   ("" (skeep :but "expr")
    (("" (induct "expr")
      (("1" (skolem 1 "cnt")
        (("1" (flatten)
          (("1"
            (rewrite "wellFormed?_dom_iff_every_ceb_is_wellFormed?")
            (("1" (skeep :preds? t)
              (("1" (use "sem_expr_cnt_fpconds")
                (("1" (assert)
                  (("1" (assert)
                    (("1"
                      (rewrite "wellFormed?_ceb_is_wellFormed?_fconds")
                      (("1" (replace -1) (("1" (assert) nil nil)) nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (skolem 1 ("i"))
        (("2" (flatten)
          (("2"
            (rewrite "wellFormed?_dom_iff_every_ceb_is_wellFormed?")
            (("2" (skeep :preds? t)
              (("2" (rewrite "sem_expr_var_fpconds")
                (("2" (use "wellFormed?_decl")
                  (("2" (assert)
                    (("2" (inst -1 "i")
                      (("2"
                        (rewrite
                         "wellFormed?_dom_iff_every_ceb_is_wellFormed?")
                        (("2" (inst?) nil nil)) nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("3" (skolem 1 ("i"))
        (("3" (flatten)
          (("3"
            (rewrite "wellFormed?_dom_iff_every_ceb_is_wellFormed?")
            (("3" (skeep :preds? t)
              (("3" (use "sem_expr_par_fpconds")
                (("3" (assert)
                  (("3" (assert)
                    (("3"
                      (rewrite "wellFormed?_ceb_is_wellFormed?_fconds")
                      (("3" (replace -1) (("3" (assert) nil nil)) nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("4" (skolem 1 ("op" "e1" "e2"))
        (("4" (flatten)
          (("4" (lemma "wellFormed?_dom_iff_every_ceb_is_wellFormed?")
            (("4"
              (inst -1 "sem(FPOperator(op, e1, e2),nargs,env)" "nargs"
               "nlocals")
              (("4" (replace -1 :hide? t)
                (("4" (skeep :preds? t)
                  (("4" (use "sem_expr_opr_fpconds")
                    (("4" (assert)
                      (("4"
                        (rewrite
                         "wellFormed?_ceb_is_wellFormed?_fconds")
                        (("4" (skeep -1 :preds? t)
                          (("4" (replace -3 :hide? t)
                            (("4" (expand "wellFormed?" 1)
                              (("4"
                                (split 1)
                                (("1"
                                  (split -4)
                                  (("1"
                                    (rewrite
                                     "wellFormed?_dom_iff_every_ceb_is_wellFormed?")
                                    (("1"
                                      (inst -1 "ceb1")
                                      (("1"
                                        (rewrite
                                         "wellFormed?_ceb_is_wellFormed?_fconds")
                                        nil
                                        nil))
                                      nil))
                                    nil)
                                   ("2"
                                    (rewrite "wellFormed?_expr_op")
                                    (("2" (flatten) nil nil))
                                    nil))
                                  nil)
                                 ("2"
                                  (split -5)
                                  (("1"
                                    (rewrite
                                     "wellFormed?_dom_iff_every_ceb_is_wellFormed?")
                                    (("1"
                                      (inst -1 "ceb2")
                                      (("1"
                                        (rewrite
                                         "wellFormed?_ceb_is_wellFormed?_fconds")
                                        nil
                                        nil))
                                      nil))
                                    nil)
                                   ("2"
                                    (rewrite "wellFormed?_expr_op")
                                    (("2" (flatten) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((FPAExpr type-decl nil expressions nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (wellFormed? inductive-decl "bool" expressions nil)
    (FPBExpr type-decl nil expressions nil)
    (pred type-eq-decl nil defined_types nil)
    (strict_total_order? const-decl "bool" orders nil)
    (lt_r formal-const-decl "(strict_total_order?[RealNumber])"
     semantics nil)
    (applyFun_r formal-const-decl
     "[[Operator, RealNumber, RealNumber] -> RealNumber]" semantics
     nil)
    (lt_fp formal-const-decl
     "(strict_total_order?[FloatingPointNumber])" semantics nil)
    (applyFun_fp formal-const-decl
     "[[Operator, FloatingPointNumber, FloatingPointNumber] ->
   FloatingPointNumber]" semantics nil)
    (FPAExprDomain type-decl nil domain nil)
    (RBExpr type-decl nil expressions nil)
    (RAExprDomain type-decl nil domain nil)
    (CEB type-eq-decl nil domain nil) (set type-eq-decl nil sets nil)
    (list type-decl nil list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (every adt-def-decl "boolean" list_adt nil)
    (finite_nonempty? const-decl "bool" more_set_defs "sets_aux/")
    (Domain type-eq-decl nil domain nil)
    (length def-decl "nat" list_props nil)
    (Environment nonempty-type-eq-decl nil semantics nil)
    (validEnvironmentForStmt const-decl "bool" semantics nil)
    (wellFormed? def-decl "bool" semantics nil)
    (wellFormed? const-decl "bool" domain nil)
    (validDomain const-decl "bool" semantics nil)
    (sem def-decl "(validDomain)" semantics nil)
    (FtoR formal-const-decl "[FloatingPointNumber -> RealNumber]"
     semantics nil)
    (FloatingPointNumber formal-nonempty-type-decl nil semantics nil)
    (RealNumber formal-nonempty-type-decl nil semantics nil)
    (Operator formal-nonempty-type-decl nil semantics nil)
    (FPAExpr_induction formula-decl nil expressions nil)
    (wellFormed?_ceb_is_wellFormed?_fconds formula-decl nil domain nil)
    (wellFormed?_form_true formula-decl nil expressions nil)
    (sem_expr_cnt_fpconds formula-decl nil semantics nil)
    (wellFormed?_dom_iff_every_ceb_is_wellFormed? formula-decl nil
     domain nil)
    (FPConstant? adt-recognizer-decl "[FPAExpr -> boolean]" expressions
     nil)
    (FPConstant adt-constructor-decl "[FPNumber -> (FPConstant?)]"
     expressions nil)
    (FPNumber nonempty-type-eq-decl nil expressions nil)
    (wellFormed?_decl formula-decl nil semantics nil)
    (below type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (below type-eq-decl nil nat_types nil)
    (nth def-decl "T" list_props nil)
    (sem_expr_var_fpconds formula-decl nil semantics nil)
    (DeBruijnIndex nonempty-type-eq-decl nil expressions nil)
    (FPVariable? adt-recognizer-decl "[FPAExpr -> boolean]" expressions
     nil)
    (FPVariable adt-constructor-decl "[DeBruijnIndex -> (FPVariable?)]"
     expressions nil)
    (sem_expr_par_fpconds formula-decl nil semantics nil)
    (ParameterIndex nonempty-type-eq-decl nil expressions nil)
    (FPParameter? adt-recognizer-decl "[FPAExpr -> boolean]"
     expressions nil)
    (FPParameter adt-constructor-decl
     "[ParameterIndex -> (FPParameter?)]" expressions nil)
    (FPOperator adt-constructor-decl
     "[[Operator, FPAExpr, FPAExpr] -> (FPOperator?)]" expressions nil)
    (FPOperator? adt-recognizer-decl "[FPAExpr -> boolean]" expressions
     nil)
    (wellFormed? def-decl "bool" expressions nil)
    (wellFormed?_expr_op formula-decl nil expressions nil)
    (sem_expr_opr_fpconds formula-decl nil semantics nil))
   shostak))
 (max_local_index_ceb_aexpr_cond 0
  (max_local_index_ceb_aexpr_cond-1 nil 3753552159
   ("" (induct "expr")
    (("1" (grind) nil nil)
     ("2" (skolem 1 "ind")
      (("2" (skeep)
        (("2" (rewrite "sem_expr_var_fpconds")
          (("2" (rewrite "max_local_index_ceb_def")
            (("2"
              (case "length
          [Domain
               [Operator, RealNumber, lt_r, applyFun_r,
                FloatingPointNumber, lt_fp, applyFun_fp, FtoR]]
          (env)
       - 1
       - ind
       >= 0")
              (("1" (assert)
                (("1" (hide -1)
                  (("1"
                    (use "max_local_index_ceb_leq_max_local_index_env")
                    (("1" (grind) nil nil)
                     ("2" (use "nth_member[Domain]") nil nil))
                    nil))
                  nil))
                nil)
               ("2" (typepred "env")
                (("2" (expand "wellFormed?") (("2" (grind) nil nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("3" (skolem 1 "ind")
      (("3" (skeep)
        (("3" (use "sem_expr_par_fpconds")
          (("3" (assert)
            (("3" (replace -1 :hide? t)
              (("3" (expand "maxFreeLocalIndex" 1 1)
                (("3" (grind) nil nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("4" (skolem 1 ("op" "e1" "e2"))
      (("4" (flatten)
        (("4" (skeep :preds? t)
          (("4" (use "sem_expr_opr_fpconds")
            (("4" (assert)
              (("4" (skeep :preds? t)
                (("4" (replace -3 :hide? t)
                  (("4" (rewrite "max_local_index_stmt_and_def")
                    (("4" (inst -7 "ceb1" "nargs" "env")
                      (("4" (split -7)
                        (("1" (inst -8 "ceb2" "nargs" "env")
                          (("1" (split -8)
                            (("1"
                              (rewrite "max_local_index_expr_op_def")
                              (("1"
                                (hide-all-but (1 -1 -2))
                                (("1" (grind) nil nil))
                                nil))
                              nil)
                             ("2" (propax) nil nil))
                            nil))
                          nil)
                         ("2" (propax) nil nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((max_local_index_expr_op_def formula-decl nil expressions nil)
    (max_local_index_stmt_and_def formula-decl nil expressions nil)
    (FPOperator adt-constructor-decl
     "[[Operator, FPAExpr, FPAExpr] -> (FPOperator?)]" expressions nil)
    (FPOperator? adt-recognizer-decl "[FPAExpr -> boolean]" expressions
     nil)
    (sem_expr_opr_fpconds formula-decl nil semantics nil)
    (sem_expr_par_fpconds formula-decl nil semantics nil)
    (ParameterIndex nonempty-type-eq-decl nil expressions nil)
    (FPParameter adt-constructor-decl
     "[ParameterIndex -> (FPParameter?)]" expressions nil)
    (nonempty_singleton_finite application-judgement
     "non_empty_finite_set" finite_sets nil)
    (FPVariable adt-constructor-decl "[DeBruijnIndex -> (FPVariable?)]"
     expressions nil)
    (sem_expr_var_fpconds formula-decl nil semantics nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (below type-eq-decl nil naturalnumbers nil)
    (nth_member formula-decl nil more_list_props "structures/")
    (maxFreeLocalIndex const-decl "upfrom(-1)" domain nil)
    (member def-decl "bool" list_props nil)
    (< const-decl "bool" reals nil)
    (below type-eq-decl nil nat_types nil)
    (nth def-decl "T" list_props nil)
    (ind skolem-const-decl
     "DeBruijnIndex[Operator, RealNumber, FloatingPointNumber, FtoR]"
     semantics nil)
    (nargs skolem-const-decl "nat" semantics nil)
    (env skolem-const-decl "{env: (validEnvironmentForStmt) |
         wellFormed?(FPVariable(ind), nargs, length(env))}" semantics
     nil)
    (max_local_index_ceb_leq_max_local_index_env formula-decl nil
     semantics nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_max application-judgement "{k: int | i <= k AND j <= k}"
     real_defs nil)
    (rat_max application-judgement "{s: rat | s >= q AND s >= r}"
     real_defs nil)
    (max_local_index_ceb_def formula-decl nil domain nil)
    (FtoR def-decl "RAExpr" expressions nil)
    (FtoR def-decl "RAExprDomain" domain nil)
    (make_ceb const-decl "CEB" domain nil)
    (singleton const-decl "(singleton?)" sets nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (minus_odd_is_odd application-judgement "odd_int" integers nil)
    (appears? const-decl "bool" semantics nil)
    (appears? const-decl "bool" domain nil)
    (appears? const-decl "bool" domain nil)
    (appears? const-decl "bool" expressions nil)
    (conditionsHold? const-decl "bool" semantics nil)
    (conditionsHold? const-decl "bool" semantics nil)
    (conditionsHold? const-decl "bool" semantics nil)
    (stable? const-decl "bool" semantics nil)
    (stable? const-decl "bool" semantics nil)
    (bottomLess? const-decl "bool" semantics nil)
    (bottomLess? const-decl "bool" semantics nil)
    (bottomLess? const-decl "bool" semantics nil)
    (/= const-decl "boolean" notequal nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (FPConstant? adt-recognizer-decl "[FPAExpr -> boolean]" expressions
     nil)
    (FPConstant adt-constructor-decl "[FPNumber -> (FPConstant?)]"
     expressions nil)
    (FPNumber nonempty-type-eq-decl nil expressions nil)
    (FPAExpr_induction formula-decl nil expressions nil)
    (Operator formal-nonempty-type-decl nil semantics nil)
    (RealNumber formal-nonempty-type-decl nil semantics nil)
    (FloatingPointNumber formal-nonempty-type-decl nil semantics nil)
    (FtoR formal-const-decl "[FloatingPointNumber -> RealNumber]"
     semantics nil)
    (maxFreeLocalIndex def-decl "upfrom(-1)" semantics nil)
    (maxFreeLocalIndex def-decl "{maxInd: upfrom(-1) |
         IF EXISTS (local: (FPVariable?)): subterm(local, expr)
           THEN (EXISTS (local: (FPVariable?) | subterm(local, expr)):
                   index(local) = maxInd)
                 AND
                 (FORALL (local: (FPVariable?) | subterm(local, expr)):
                    index(local) <= maxInd)
         ELSE maxInd = -1
         ENDIF}" expressions nil)
    (subterm adt-def-decl "boolean" expressions nil)
    (max const-decl "{p: real | p >= m AND p >= n}" real_defs nil)
    (maxFreeLocalIndex def-decl "{max: upfrom(-1) |
         IF EXISTS (local: (FPVariable?)): appears?(form)(local)
           THEN (EXISTS (local: (FPVariable?) | appears?(form)(local)):
                   index(local) = max)
                 AND
                 (FORALL (local: (FPVariable?) | appears?(form)(local)):
                    index(local) <= max)
         ELSE max = -1
         ENDIF}" expressions nil)
    (index shared-adt-accessor-decl
           "[{x: FPAExpr | FPVariable?(x) OR FPParameter?(x)} -> DeBruijnIndex]"
           expressions nil)
    (DeBruijnIndex nonempty-type-eq-decl nil expressions nil)
    (FPParameter? adt-recognizer-decl "[FPAExpr -> boolean]"
     expressions nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (appears? const-decl "bool" expressions nil)
    (FPVariable? adt-recognizer-decl "[FPAExpr -> boolean]" expressions
     nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (upfrom nonempty-type-eq-decl nil integers nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (<= const-decl "bool" reals nil)
    (sem def-decl "(validDomain)" semantics nil)
    (validDomain const-decl "bool" semantics nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (length def-decl "nat" list_props nil)
    (Domain type-eq-decl nil domain nil)
    (wellFormed? inductive-decl "bool" expressions nil)
    (validEnvironmentForStmt const-decl "bool" semantics nil)
    (Environment nonempty-type-eq-decl nil semantics nil)
    (finite_nonempty? const-decl "bool" more_set_defs "sets_aux/")
    (every adt-def-decl "boolean" list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil) (set type-eq-decl nil sets nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (CEB type-eq-decl nil domain nil)
    (RAExprDomain type-decl nil domain nil)
    (RBExpr type-decl nil expressions nil)
    (FPAExprDomain type-decl nil domain nil)
    (applyFun_fp formal-const-decl
     "[[Operator, FloatingPointNumber, FloatingPointNumber] ->
   FloatingPointNumber]" semantics nil)
    (lt_fp formal-const-decl
     "(strict_total_order?[FloatingPointNumber])" semantics nil)
    (applyFun_r formal-const-decl
     "[[Operator, RealNumber, RealNumber] -> RealNumber]" semantics
     nil)
    (lt_r formal-const-decl "(strict_total_order?[RealNumber])"
     semantics nil)
    (strict_total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (FPBExpr type-decl nil expressions nil)
    (boolean nonempty-type-decl nil booleans nil)
    (FPAExpr type-decl nil expressions nil))
   shostak))
 (valid_environment_extension 0
  (valid_environment_extension-1 nil 3732647008
   ("" (skeep :preds? t)
    (("" (expand "validEnvironmentForStmt" +)
      (("" (split +)
        (("1" (expand "bottomLess?" 1)
          (("1" (skeep 1 :preds? t)
            (("1" (expand "member" -2)
              (("1" (split -2)
                (("1" (grind) nil nil) ("2" (grind) nil nil)) nil))
              nil))
            nil))
          nil)
         ("2" (expand "stable?")
          (("2" (skeep 1 :preds? t)
            (("2" (expand "member" -2)
              (("2" (split -2)
                (("1" (replace -1 :hide? t)
                  (("1" (expand "validDomain")
                    (("1" (flatten) nil nil)) nil))
                  nil)
                 ("2" (expand "validEnvironmentForStmt")
                  (("2" (flatten)
                    (("2" (expand "stable?" -)
                      (("2" (inst - "dom_1") nil nil)) nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("3" (expand "conditionsHold?" 1)
          (("3" (skeep 1 :preds? t)
            (("3" (expand "member" -2)
              (("3" (split -2)
                (("1" (replace -1 :hide? t)
                  (("1" (lemma "valid_domain_assures_conditions_hold")
                    (("1" (inst -1 "dom") nil nil)) nil))
                  nil)
                 ("2"
                  (lemma "valid_environment_assures_conditions_hold")
                  (("2" (inst -1 "env")
                    (("2" (expand "conditionsHold?" -1)
                      (("2" (inst -1 "dom_1") nil nil)) nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("4" (expand "validDomain")
          (("4" (flatten)
            (("4" (skeep 1)
              (("4" (inst -9 "local")
                (("4" (expand "validEnvironmentForStmt")
                  (("4" (flatten)
                    (("4" (inst -8 "local")
                      (("4" (rewrite "appears?_env_int_def")
                        (("4" (skeep -1 :preds? t)
                          (("4" (expand "member" -2)
                            (("4" (split -2)
                              (("1" (assert) nil nil)
                               ("2"
                                (rewrite "appears?_env_int_def")
                                (("2" (inst 1 "dom_1") nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((validEnvironmentForStmt const-decl "bool" semantics nil)
    (dom_1 skolem-const-decl
     "{dom_1: Domain | member(dom_1, cons(dom, env))}" semantics nil)
    (appears?_env_int_def formula-decl nil semantics nil)
    (FPVariable? adt-recognizer-decl "[FPAExpr -> boolean]" expressions
     nil)
    (FPAExpr type-decl nil expressions nil)
    (valid_environment_assures_conditions_hold formula-decl nil
     semantics nil)
    (dom_1 skolem-const-decl
     "{dom_1: Domain | member(dom_1, cons(dom, env))}" semantics nil)
    (valid_domain_assures_conditions_hold formula-decl nil semantics
     nil)
    (dom_1 skolem-const-decl
     "{dom_1: Domain | member(dom_1, cons(dom, env))}" semantics nil)
    (bottomLess? const-decl "bool" semantics nil)
    (member def-decl "bool" list_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (validDomain const-decl "bool" semantics nil)
    (appears? const-decl "bool" semantics nil)
    (appears? const-decl "bool" domain nil)
    (appears? const-decl "bool" domain nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (pred type-eq-decl nil defined_types nil)
    (strict_total_order? const-decl "bool" orders nil)
    (lt_r formal-const-decl "(strict_total_order?[RealNumber])"
     semantics nil)
    (applyFun_r formal-const-decl
     "[[Operator, RealNumber, RealNumber] -> RealNumber]" semantics
     nil)
    (lt_fp formal-const-decl
     "(strict_total_order?[FloatingPointNumber])" semantics nil)
    (applyFun_fp formal-const-decl
     "[[Operator, FloatingPointNumber, FloatingPointNumber] ->
   FloatingPointNumber]" semantics nil)
    (appears? const-decl "bool" expressions nil)
    (FtoR def-decl "RAExpr" expressions nil)
    (appears? const-decl "bool" expressions nil)
    (Operator formal-nonempty-type-decl nil semantics nil)
    (RealNumber formal-nonempty-type-decl nil semantics nil)
    (FloatingPointNumber formal-nonempty-type-decl nil semantics nil)
    (FtoR formal-const-decl "[FloatingPointNumber -> RealNumber]"
     semantics nil)
    (conditionsHold? const-decl "bool" semantics nil)
    (conditionsHold? const-decl "bool" semantics nil)
    (conditionsHold? const-decl "bool" semantics nil)
    (stable? const-decl "bool" semantics nil)
    (stable? const-decl "bool" semantics nil)
    (bottomLess? const-decl "bool" semantics nil)
    (bottomLess? const-decl "bool" semantics nil)
    (/= const-decl "boolean" notequal nil)
    (finite_nonempty? const-decl "bool" more_set_defs "sets_aux/")
    (nonempty? const-decl "bool" sets nil)
    (empty? const-decl "bool" sets nil)
    (member const-decl "bool" sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (injective? const-decl "bool" functions nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (>= const-decl "bool" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (dom_1 skolem-const-decl
     "{dom_1: Domain | member(dom_1, cons(dom, env))}" semantics nil)
    (env skolem-const-decl "Environment" semantics nil)
    (dom skolem-const-decl "Domain
    [Operator, RealNumber, lt_r, applyFun_r, FloatingPointNumber, lt_fp,
     applyFun_fp, FtoR]" semantics nil)
    (FPBExpr type-decl nil expressions nil)
    (FPAExprDomain type-decl nil domain nil)
    (RBExpr type-decl nil expressions nil)
    (RAExprDomain type-decl nil domain nil)
    (CEB type-eq-decl nil domain nil) (set type-eq-decl nil sets nil)
    (Domain type-eq-decl nil domain nil)
    (list type-decl nil list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (every adt-def-decl "boolean" list_adt nil)
    (Environment nonempty-type-eq-decl nil semantics nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil))
   shostak))
 (valid_environment_shortening 0
  (valid_environment_shortening-1 nil 3754472635
   ("" (skeep)
    (("" (expand "validEnvironmentForStmt")
      (("" (flatten)
        (("" (split 1)
          (("1" (expand "bottomLess?")
            (("1" (skeep 1 :preds? t)
              (("1" (inst -3 "dom")
                (("1" (use "takeFromRight_member[Domain]")
                  (("1" (assert) nil nil)) nil))
                nil))
              nil))
            nil)
           ("2" (expand "stable?")
            (("2" (skeep 1 :preds? t)
              (("2" (inst -4 "dom")
                (("2" (use "takeFromRight_member[Domain]")
                  (("2" (assert) nil nil)) nil))
                nil))
              nil))
            nil)
           ("3" (expand "conditionsHold?")
            (("3" (skeep 1 :preds? t)
              (("3" (inst -5 "dom")
                (("3" (use "takeFromRight_member[Domain]")
                  (("3" (assert) nil nil)) nil))
                nil))
              nil))
            nil)
           ("4" (skeep 1)
            (("4" (inst -5 "local")
              (("4" (rewrite "appears?_env_int_def")
                (("4" (rewrite "appears?_env_int_def")
                  (("4" (skeep -1 :preds? t)
                    (("4" (inst 1 "dom")
                      (("4" (use "takeFromRight_member[Domain]")
                        (("4" (assert) nil nil)) nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((validEnvironmentForStmt const-decl "bool" semantics nil)
    (takeFromRight_member formula-decl nil more_list_props
     "structures/")
    (env skolem-const-decl "Environment" semantics nil)
    (n skolem-const-decl "nat" semantics nil)
    (dom skolem-const-decl
     "{dom: Domain | member(dom, takeFromRight(env, n))}" semantics
     nil)
    (takeFromRight def-decl "list[T]" more_list_props "structures/")
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (Environment nonempty-type-eq-decl nil semantics nil)
    (member def-decl "bool" list_props nil)
    (every adt-def-decl "boolean" list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (Domain type-eq-decl nil domain nil)
    (finite_nonempty? const-decl "bool" more_set_defs "sets_aux/")
    (set type-eq-decl nil sets nil) (CEB type-eq-decl nil domain nil)
    (RAExprDomain type-decl nil domain nil)
    (RBExpr type-decl nil expressions nil)
    (FPAExprDomain type-decl nil domain nil)
    (applyFun_fp formal-const-decl
     "[[Operator, FloatingPointNumber, FloatingPointNumber] ->
   FloatingPointNumber]" semantics nil)
    (lt_fp formal-const-decl
     "(strict_total_order?[FloatingPointNumber])" semantics nil)
    (applyFun_r formal-const-decl
     "[[Operator, RealNumber, RealNumber] -> RealNumber]" semantics
     nil)
    (lt_r formal-const-decl "(strict_total_order?[RealNumber])"
     semantics nil)
    (strict_total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (FPBExpr type-decl nil expressions nil)
    (FtoR formal-const-decl "[FloatingPointNumber -> RealNumber]"
     semantics nil)
    (FloatingPointNumber formal-nonempty-type-decl nil semantics nil)
    (RealNumber formal-nonempty-type-decl nil semantics nil)
    (Operator formal-nonempty-type-decl nil semantics nil)
    (bottomLess? const-decl "bool" semantics nil)
    (dom skolem-const-decl
     "{dom: Domain | member(dom, takeFromRight(env, n))}" semantics
     nil)
    (stable? const-decl "bool" semantics nil)
    (dom skolem-const-decl
     "{dom: Domain | member(dom, takeFromRight(env, n))}" semantics
     nil)
    (conditionsHold? const-decl "bool" semantics nil)
    (FPAExpr type-decl nil expressions nil)
    (FPVariable? adt-recognizer-decl "[FPAExpr -> boolean]" expressions
     nil)
    (dom skolem-const-decl
     "{dom: Domain | member(dom, takeFromRight(env, n))}" semantics
     nil)
    (appears?_env_int_def formula-decl nil semantics nil))
   shostak))
 (valid_environment_ext 0
  (valid_environment_ext-1 nil 3753782735
   ("" (skeep :preds? t)
    (("" (use "valid_environment_extension") (("" (assert) nil nil))
      nil))
    nil)
   ((valid_environment_extension formula-decl nil semantics nil)
    (sem def-decl "(validDomain)" semantics nil)
    (validDomain const-decl "bool" semantics nil)
    (length def-decl "nat" list_props nil)
    (wellFormed? inductive-decl "bool" expressions nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (FPAExpr type-decl nil expressions nil)
    (Domain type-eq-decl nil domain nil)
    (validEnvironmentForStmt const-decl "bool" semantics nil)
    (Environment nonempty-type-eq-decl nil semantics nil)
    (finite_nonempty? const-decl "bool" more_set_defs "sets_aux/")
    (every adt-def-decl "boolean" list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil) (set type-eq-decl nil sets nil)
    (CEB type-eq-decl nil domain nil)
    (RAExprDomain type-decl nil domain nil)
    (RBExpr type-decl nil expressions nil)
    (FPAExprDomain type-decl nil domain nil)
    (applyFun_fp formal-const-decl
     "[[Operator, FloatingPointNumber, FloatingPointNumber] ->
   FloatingPointNumber]" semantics nil)
    (lt_fp formal-const-decl
     "(strict_total_order?[FloatingPointNumber])" semantics nil)
    (applyFun_r formal-const-decl
     "[[Operator, RealNumber, RealNumber] -> RealNumber]" semantics
     nil)
    (lt_r formal-const-decl "(strict_total_order?[RealNumber])"
     semantics nil)
    (strict_total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (FPBExpr type-decl nil expressions nil)
    (FtoR formal-const-decl "[FloatingPointNumber -> RealNumber]"
     semantics nil)
    (FloatingPointNumber formal-nonempty-type-decl nil semantics nil)
    (RealNumber formal-nonempty-type-decl nil semantics nil)
    (Operator formal-nonempty-type-decl nil semantics nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil))
   shostak))
 (sem_fpaexpr_is_stable 0
  (sem_fpaexpr_is_stable-1 nil 3732697676
   ("" (with-labels (skeep :preds? t) ((nil)))
    (("" (lemma "valid_domain__ceb_stable")
      (("" (inst -1 "sem(expr, nargs, env)" "ceb")
        (("" (expand "belongsToDom") (("" (propax) nil nil)) nil))
        nil))
      nil))
    nil)
   ((valid_domain__ceb_stable formula-decl nil semantics nil)
    (sem def-decl "(validDomain)" semantics nil)
    (length def-decl "nat" list_props nil)
    (wellFormed? inductive-decl "bool" expressions nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (validEnvironmentForStmt const-decl "bool" semantics nil)
    (Environment nonempty-type-eq-decl nil semantics nil)
    (every adt-def-decl "boolean" list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (FPAExpr type-decl nil expressions nil)
    (validDomain const-decl "bool" semantics nil)
    (Domain type-eq-decl nil domain nil)
    (finite_nonempty? const-decl "bool" more_set_defs "sets_aux/")
    (set type-eq-decl nil sets nil) (CEB type-eq-decl nil domain nil)
    (RAExprDomain type-decl nil domain nil)
    (RBExpr type-decl nil expressions nil)
    (FPAExprDomain type-decl nil domain nil)
    (applyFun_fp formal-const-decl
     "[[Operator, FloatingPointNumber, FloatingPointNumber] ->
   FloatingPointNumber]" semantics nil)
    (lt_fp formal-const-decl
     "(strict_total_order?[FloatingPointNumber])" semantics nil)
    (applyFun_r formal-const-decl
     "[[Operator, RealNumber, RealNumber] -> RealNumber]" semantics
     nil)
    (lt_r formal-const-decl "(strict_total_order?[RealNumber])"
     semantics nil)
    (strict_total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (FPBExpr type-decl nil expressions nil)
    (FtoR formal-const-decl "[FloatingPointNumber -> RealNumber]"
     semantics nil)
    (FloatingPointNumber formal-nonempty-type-decl nil semantics nil)
    (RealNumber formal-nonempty-type-decl nil semantics nil)
    (Operator formal-nonempty-type-decl nil semantics nil))
   shostak))
 (sem_fpaexpr_is_bottomless 0
  (sem_fpaexpr_is_bottomless-1 nil 3732308907
   ("" (with-labels (skeep :preds? t) ((nil)))
    (("" (lemma "valid_domain__ceb_bottomless")
      (("" (inst -1 "sem(expr, nargs, env)" "ceb") nil nil)) nil))
    nil)
   ((valid_domain__ceb_bottomless formula-decl nil semantics nil)
    (sem def-decl "(validDomain)" semantics nil)
    (length def-decl "nat" list_props nil)
    (wellFormed? inductive-decl "bool" expressions nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (validEnvironmentForStmt const-decl "bool" semantics nil)
    (Environment nonempty-type-eq-decl nil semantics nil)
    (every adt-def-decl "boolean" list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (FPAExpr type-decl nil expressions nil)
    (validDomain const-decl "bool" semantics nil)
    (Domain type-eq-decl nil domain nil)
    (finite_nonempty? const-decl "bool" more_set_defs "sets_aux/")
    (set type-eq-decl nil sets nil) (CEB type-eq-decl nil domain nil)
    (RAExprDomain type-decl nil domain nil)
    (RBExpr type-decl nil expressions nil)
    (FPAExprDomain type-decl nil domain nil)
    (applyFun_fp formal-const-decl
     "[[Operator, FloatingPointNumber, FloatingPointNumber] ->
   FloatingPointNumber]" semantics nil)
    (lt_fp formal-const-decl
     "(strict_total_order?[FloatingPointNumber])" semantics nil)
    (applyFun_r formal-const-decl
     "[[Operator, RealNumber, RealNumber] -> RealNumber]" semantics
     nil)
    (lt_r formal-const-decl "(strict_total_order?[RealNumber])"
     semantics nil)
    (strict_total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (FPBExpr type-decl nil expressions nil)
    (FtoR formal-const-decl "[FloatingPointNumber -> RealNumber]"
     semantics nil)
    (FloatingPointNumber formal-nonempty-type-decl nil semantics nil)
    (RealNumber formal-nonempty-type-decl nil semantics nil)
    (Operator formal-nonempty-type-decl nil semantics nil))
   shostak))
 (sem_fpaexpr_conditions_hold 0
  (sem_fpaexpr_conditions_hold-1 nil 3732436475
   ("" (with-labels (skeep :preds? t) ((nil)))
    (("" (lemma "valid_domain__ceb_conditions_hold")
      (("" (inst -1 "sem(expr, nargs, env)" "ceb") nil nil)) nil))
    nil)
   ((valid_domain__ceb_conditions_hold formula-decl nil semantics nil)
    (sem def-decl "(validDomain)" semantics nil)
    (length def-decl "nat" list_props nil)
    (wellFormed? inductive-decl "bool" expressions nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (validEnvironmentForStmt const-decl "bool" semantics nil)
    (Environment nonempty-type-eq-decl nil semantics nil)
    (every adt-def-decl "boolean" list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (FPAExpr type-decl nil expressions nil)
    (validDomain const-decl "bool" semantics nil)
    (Domain type-eq-decl nil domain nil)
    (finite_nonempty? const-decl "bool" more_set_defs "sets_aux/")
    (set type-eq-decl nil sets nil) (CEB type-eq-decl nil domain nil)
    (RAExprDomain type-decl nil domain nil)
    (RBExpr type-decl nil expressions nil)
    (FPAExprDomain type-decl nil domain nil)
    (applyFun_fp formal-const-decl
     "[[Operator, FloatingPointNumber, FloatingPointNumber] ->
   FloatingPointNumber]" semantics nil)
    (lt_fp formal-const-decl
     "(strict_total_order?[FloatingPointNumber])" semantics nil)
    (applyFun_r formal-const-decl
     "[[Operator, RealNumber, RealNumber] -> RealNumber]" semantics
     nil)
    (lt_r formal-const-decl "(strict_total_order?[RealNumber])"
     semantics nil)
    (strict_total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (FPBExpr type-decl nil expressions nil)
    (FtoR formal-const-decl "[FloatingPointNumber -> RealNumber]"
     semantics nil)
    (FloatingPointNumber formal-nonempty-type-decl nil semantics nil)
    (RealNumber formal-nonempty-type-decl nil semantics nil)
    (Operator formal-nonempty-type-decl nil semantics nil))
   shostak))
 (sem_fpaexpr_is_valid_domain 0
  (sem_fpaexpr_is_valid_domain-1 nil 3732698797 ("" (grind) nil nil)
   nil shostak))
 (valid_env_for_stmt__stable 0
  (valid_env_for_stmt__stable-1 nil 3732699724
   ("" (skeep* :preds? t)
    (("" (lemma "valid_environment_assures_stable")
      (("" (inst -1 "env")
        (("" (expand "stable?" -1)
          (("" (expand "belongsToEnv")
            (("" (skeep -2)
              (("" (inst -1 "nth(env,i)")
                (("1" (expand "stable?" -1)
                  (("1" (inst -1 "ceb") nil nil)) nil)
                 ("2" (use "nth_member[Domain]") nil nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((valid_environment_assures_stable formula-decl nil semantics nil)
    (stable? const-decl "bool" semantics nil)
    (nth_member formula-decl nil more_list_props "structures/")
    (stable? const-decl "bool" semantics nil)
    (ceb skolem-const-decl "(belongsToEnv(env))" semantics nil)
    (Domain type-eq-decl nil domain nil)
    (member def-decl "bool" list_props nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (length def-decl "nat" list_props nil)
    (below type-eq-decl nil nat_types nil)
    (nth def-decl "T" list_props nil)
    (below type-eq-decl nil naturalnumbers nil)
    (i skolem-const-decl "below(length(env))" semantics nil)
    (belongsToEnv const-decl "bool" semantics nil)
    (Operator formal-nonempty-type-decl nil semantics nil)
    (RealNumber formal-nonempty-type-decl nil semantics nil)
    (FloatingPointNumber formal-nonempty-type-decl nil semantics nil)
    (FtoR formal-const-decl "[FloatingPointNumber -> RealNumber]"
     semantics nil)
    (FPBExpr type-decl nil expressions nil)
    (pred type-eq-decl nil defined_types nil)
    (strict_total_order? const-decl "bool" orders nil)
    (lt_r formal-const-decl "(strict_total_order?[RealNumber])"
     semantics nil)
    (applyFun_r formal-const-decl
     "[[Operator, RealNumber, RealNumber] -> RealNumber]" semantics
     nil)
    (lt_fp formal-const-decl
     "(strict_total_order?[FloatingPointNumber])" semantics nil)
    (applyFun_fp formal-const-decl
     "[[Operator, FloatingPointNumber, FloatingPointNumber] ->
   FloatingPointNumber]" semantics nil)
    (FPAExprDomain type-decl nil domain nil)
    (RBExpr type-decl nil expressions nil)
    (RAExprDomain type-decl nil domain nil)
    (CEB type-eq-decl nil domain nil) (set type-eq-decl nil sets nil)
    (list type-decl nil list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (every adt-def-decl "boolean" list_adt nil)
    (finite_nonempty? const-decl "bool" more_set_defs "sets_aux/")
    (Environment nonempty-type-eq-decl nil semantics nil)
    (validEnvironmentForStmt const-decl "bool" semantics nil)
    (env skolem-const-decl "Environment" semantics nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   shostak))
 (valid_env_for_stmt__conditions_hold 0
  (valid_env_for_stmt__conditions_hold-1 nil 3732700041
   ("" (skeep* :preds? t)
    (("" (lemma "valid_environment_assures_conditions_hold")
      (("" (inst -1 "env")
        (("" (expand "conditionsHold?" -1)
          (("" (expand "belongsToEnv")
            (("" (skeep -2)
              (("" (inst -1 "nth(env,i)")
                (("1" (expand "conditionsHold?" -1)
                  (("1" (inst -1 "ceb") nil nil)) nil)
                 ("2" (use "nth_member[Domain]") nil nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((valid_environment_assures_conditions_hold formula-decl nil
     semantics nil)
    (conditionsHold? const-decl "bool" semantics nil)
    (nth_member formula-decl nil more_list_props "structures/")
    (conditionsHold? const-decl "bool" semantics nil)
    (ceb skolem-const-decl "(belongsToEnv(env))" semantics nil)
    (Domain type-eq-decl nil domain nil)
    (member def-decl "bool" list_props nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (length def-decl "nat" list_props nil)
    (below type-eq-decl nil nat_types nil)
    (nth def-decl "T" list_props nil)
    (below type-eq-decl nil naturalnumbers nil)
    (i skolem-const-decl "below(length(env))" semantics nil)
    (belongsToEnv const-decl "bool" semantics nil)
    (Operator formal-nonempty-type-decl nil semantics nil)
    (RealNumber formal-nonempty-type-decl nil semantics nil)
    (FloatingPointNumber formal-nonempty-type-decl nil semantics nil)
    (FtoR formal-const-decl "[FloatingPointNumber -> RealNumber]"
     semantics nil)
    (FPBExpr type-decl nil expressions nil)
    (pred type-eq-decl nil defined_types nil)
    (strict_total_order? const-decl "bool" orders nil)
    (lt_r formal-const-decl "(strict_total_order?[RealNumber])"
     semantics nil)
    (applyFun_r formal-const-decl
     "[[Operator, RealNumber, RealNumber] -> RealNumber]" semantics
     nil)
    (lt_fp formal-const-decl
     "(strict_total_order?[FloatingPointNumber])" semantics nil)
    (applyFun_fp formal-const-decl
     "[[Operator, FloatingPointNumber, FloatingPointNumber] ->
   FloatingPointNumber]" semantics nil)
    (FPAExprDomain type-decl nil domain nil)
    (RBExpr type-decl nil expressions nil)
    (RAExprDomain type-decl nil domain nil)
    (CEB type-eq-decl nil domain nil) (set type-eq-decl nil sets nil)
    (list type-decl nil list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (every adt-def-decl "boolean" list_adt nil)
    (finite_nonempty? const-decl "bool" more_set_defs "sets_aux/")
    (Environment nonempty-type-eq-decl nil semantics nil)
    (validEnvironmentForStmt const-decl "bool" semantics nil)
    (env skolem-const-decl "Environment" semantics nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   shostak))
 (replace_local_var_TCC1 0
  (replace_local_var_TCC1-1 nil 3753550439
   ("" (termination-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (Operator formal-nonempty-type-decl nil semantics nil)
    (RealNumber formal-nonempty-type-decl nil semantics nil)
    (FloatingPointNumber formal-nonempty-type-decl nil semantics nil)
    (FtoR formal-const-decl "[FloatingPointNumber -> RealNumber]"
     semantics nil)
    (DeBruijnIndex nonempty-type-eq-decl nil expressions nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil))
   nil))
 (replace_local_var_TCC2 0
  (replace_local_var_TCC2-1 nil 3753550439
   ("" (termination-tcc) nil nil)
   ((FtoR formal-const-decl "[FloatingPointNumber -> RealNumber]"
     semantics nil)
    (FloatingPointNumber formal-nonempty-type-decl nil semantics nil)
    (RealNumber formal-nonempty-type-decl nil semantics nil)
    (Operator formal-nonempty-type-decl nil semantics nil)
    (<< adt-def-decl "(strict_well_founded?[FPAExpr])" expressions
     nil))
   nil))
 (replace_local_var_TCC3 0
  (replace_local_var_TCC3-1 nil 3753550439
   ("" (termination-tcc) nil nil)
   ((FtoR formal-const-decl "[FloatingPointNumber -> RealNumber]"
     semantics nil)
    (FloatingPointNumber formal-nonempty-type-decl nil semantics nil)
    (RealNumber formal-nonempty-type-decl nil semantics nil)
    (Operator formal-nonempty-type-decl nil semantics nil)
    (<< adt-def-decl "(strict_well_founded?[FPAExpr])" expressions
     nil))
   nil))
 (replace_local_var_TCC4 0
  (replace_local_var_TCC4-1 nil 3753550439
   ("" (termination-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (Operator formal-nonempty-type-decl nil semantics nil)
    (RealNumber formal-nonempty-type-decl nil semantics nil)
    (FloatingPointNumber formal-nonempty-type-decl nil semantics nil)
    (FtoR formal-const-decl "[FloatingPointNumber -> RealNumber]"
     semantics nil)
    (DeBruijnIndex nonempty-type-eq-decl nil expressions nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil))
   nil))
 (replace_local_var_TCC5 0
  (replace_local_var_TCC5-1 nil 3753550439
   ("" (termination-tcc) nil nil)
   ((FtoR formal-const-decl "[FloatingPointNumber -> RealNumber]"
     semantics nil)
    (FloatingPointNumber formal-nonempty-type-decl nil semantics nil)
    (RealNumber formal-nonempty-type-decl nil semantics nil)
    (Operator formal-nonempty-type-decl nil semantics nil)
    (<< adt-def-decl "(strict_well_founded?[RAExpr])" expressions nil))
   nil))
 (replace_local_var_TCC6 0
  (replace_local_var_TCC6-1 nil 3754217098
   ("" (termination-tcc) nil nil)
   ((FtoR formal-const-decl "[FloatingPointNumber -> RealNumber]"
     semantics nil)
    (FloatingPointNumber formal-nonempty-type-decl nil semantics nil)
    (RealNumber formal-nonempty-type-decl nil semantics nil)
    (Operator formal-nonempty-type-decl nil semantics nil)
    (<< adt-def-decl "(strict_well_founded?[RAExpr])" expressions nil))
   nil))
 (max_local_index_expr_replaced_var 0
  (max_local_index_expr_replaced_var-1 nil 3753550440
   ("" (skeep :but "expr1")
    (("" (induct "expr1")
      (("1" (grind) nil nil) ("2" (grind) nil nil)
       ("3" (skolem 1 "ind") (("3" (grind) nil nil)) nil)
       ("4" (skolem 1 ("op" "e1" "e2"))
        (("4" (flatten) (("4" (grind) nil nil)) nil)) nil))
      nil))
    nil)
   ((int_minus_int_is_int application-judgement "int" integers nil)
    (minus_odd_is_odd application-judgement "odd_int" integers nil)
    (FPAExpr type-decl nil expressions nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (<= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (upfrom nonempty-type-eq-decl nil integers nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (FPVariable? adt-recognizer-decl "[FPAExpr -> boolean]" expressions
     nil)
    (subterm adt-def-decl "boolean" expressions nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (FPParameter? adt-recognizer-decl "[FPAExpr -> boolean]"
     expressions nil)
    (DeBruijnIndex nonempty-type-eq-decl nil expressions nil)
    (index shared-adt-accessor-decl
           "[{x: FPAExpr | FPVariable?(x) OR FPParameter?(x)} -> DeBruijnIndex]"
           expressions nil)
    (maxFreeLocalIndex def-decl "{maxInd: upfrom(-1) |
         IF EXISTS (local: (FPVariable?)): subterm(local, expr)
           THEN (EXISTS (local: (FPVariable?) | subterm(local, expr)):
                   index(local) = maxInd)
                 AND
                 (FORALL (local: (FPVariable?) | subterm(local, expr)):
                    index(local) <= maxInd)
         ELSE maxInd = -1
         ENDIF}" expressions nil)
    (replace_local_var def-decl "FPAExpr" semantics nil)
    (max const-decl "{p: real | p >= m AND p >= n}" real_defs nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (FtoR formal-const-decl "[FloatingPointNumber -> RealNumber]"
     semantics nil)
    (FloatingPointNumber formal-nonempty-type-decl nil semantics nil)
    (RealNumber formal-nonempty-type-decl nil semantics nil)
    (Operator formal-nonempty-type-decl nil semantics nil)
    (FPAExpr_induction formula-decl nil expressions nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (even_minus_odd_is_odd application-judgement "odd_int" integers
     nil)
    (rat_max application-judgement "{s: rat | s >= q AND s >= r}"
     real_defs nil)
    (int_max application-judgement "{k: int | i <= k AND j <= k}"
     real_defs nil)
    (real_minus_real_is_real application-judgement "real" reals nil))
   shostak))
 (replace_local_var_in_fpexpr_evaluable_in_TCC1 0
  (replace_local_var_in_fpexpr_evaluable_in_TCC1-1 nil 3755693132
   ("" (subtype-tcc) nil nil) nil nil))
 (replace_local_var_in_fpexpr_evaluable_in 0
  (replace_local_var_in_fpexpr_evaluable_in-2 "" 3753979408
   ("" (skeep :but "expr2")
    (("" (induct "expr2")
      (("1" (grind) nil nil)
       ("2" (skolem 1 "idx")
        (("2" (expand "replace_local_var")
          (("2" (lift-if 1)
            (("2" (split 1)
              (("1" (flatten) (("1" (grind) nil nil)) nil)
               ("2" (flatten)
                (("2" (expand "bounded_by?")
                  (("2" (iff)
                    (("2" (split 2)
                      (("1" (flatten)
                        (("1" (skeep 1 :preds? t)
                          (("1" (split -2)
                            (("1" (inst -3 "FPVariable(idx)")
                              (("1" (grind) nil nil)) nil)
                             ("2" (grind) nil nil))
                            nil))
                          nil))
                        nil)
                       ("2" (flatten)
                        (("2" (skeep :preds? t)
                          (("2" (inst -3 "FPVariable(idx-1)")
                            (("1" (grind) nil nil)
                             ("2" (grind) nil nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("3" (grind) nil nil)
       ("4" (skolem 1 ("op" "a1" "a2"))
        (("4" (flatten)
          (("4" (expand "replace_local_var" 1)
            (("4" (rewrite "evaluable_in_fpaexpr_def_op")
              (("4" (rewrite "evaluable_in_fpaexpr_def_op")
                (("4" (assert) (("4" (grind) nil nil)) nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((FPAExpr type-decl nil expressions nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (FPVariable? adt-recognizer-decl "[FPAExpr -> boolean]" expressions
     nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (pred type-eq-decl nil defined_types nil)
    (strict_total_order? const-decl "bool" orders nil)
    (lt_r formal-const-decl "(strict_total_order?[RealNumber])"
     semantics nil)
    (applyFun_r formal-const-decl
     "[[Operator, RealNumber, RealNumber] -> RealNumber]" semantics
     nil)
    (lt_fp formal-const-decl
     "(strict_total_order?[FloatingPointNumber])" semantics nil)
    (applyFun_fp formal-const-decl
     "[[Operator, FloatingPointNumber, FloatingPointNumber] ->
   FloatingPointNumber]" semantics nil)
    (fpVarIndex const-decl "nat" expressions_semantics nil)
    (strict_well_founded? const-decl "bool" orders nil)
    (<< adt-def-decl "(strict_well_founded?[FPAExpr])" expressions nil)
    (LocalEnvironment nonempty-type-decl nil u_local_environment nil)
    (bounded_by? const-decl "bool" u_local_environment nil)
    (cons const-decl "LocalEnvironment" u_local_environment nil)
    (FPLocalEnvironment type-eq-decl nil expressions_semantics nil)
    (replace_local_var def-decl "FPAExpr" semantics nil)
    (FtoR formal-const-decl "[FloatingPointNumber -> RealNumber]"
     semantics nil)
    (FloatingPointNumber formal-nonempty-type-decl nil semantics nil)
    (RealNumber formal-nonempty-type-decl nil semantics nil)
    (Operator formal-nonempty-type-decl nil semantics nil)
    (FPAExpr_induction formula-decl nil expressions nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (FPConstant? adt-recognizer-decl "[FPAExpr -> boolean]" expressions
     nil)
    (FPConstant adt-constructor-decl "[FPNumber -> (FPConstant?)]"
     expressions nil)
    (FPNumber nonempty-type-eq-decl nil expressions nil)
    (size_cons_def formula-decl nil u_local_environment nil)
    (fpLocalEnv skolem-const-decl "FPLocalEnvironment
    [Operator, RealNumber, lt_r, applyFun_r, FloatingPointNumber, lt_fp,
     applyFun_fp, FtoR]" semantics nil)
    (expr1 skolem-const-decl
     "{expr1: FPAExpr | bounded_by?(fpLocalEnv)(expr1)}" semantics nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (DeBruijnIndex nonempty-type-eq-decl nil expressions nil)
    (FPVariable adt-constructor-decl "[DeBruijnIndex -> (FPVariable?)]"
     expressions nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (idx skolem-const-decl
     "DeBruijnIndex[Operator, RealNumber, FloatingPointNumber, FtoR]"
     semantics nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (ParameterIndex nonempty-type-eq-decl nil expressions nil)
    (FPParameter? adt-recognizer-decl "[FPAExpr -> boolean]"
     expressions nil)
    (FPParameter adt-constructor-decl
     "[ParameterIndex -> (FPParameter?)]" expressions nil)
    (evaluable_in_fpaexpr_def_op formula-decl nil expressions_semantics
     nil))
   shostak)
  (replace_local_var_in_fpexpr_evaluable_in-1 nil 3753960237
   ("" (skeep :but "expr2")
    (("" (induct "expr2")
      (("1" (grind) nil nil)
       ("2" (skolem 1 "idx")
        (("2" (flatten)
          (("2" (expand "replace_local_var")
            (("2" (split 1)
              (("1" (flatten) (("1" (assert) nil nil)) nil)
               ("2" (flatten)
                (("2" (expand "bounded_by?")
                  (("2" (skeep 2 :preds? t)
                    (("2" (assert)
                      (("2" (split -2)
                        (("1" (inst -3 "v") (("1" (grind) nil nil))
                          nil)
                         ("2" (grind) nil nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("3" (grind) nil nil)
       ("4" (skolem 1 ("op" "a1" "a2"))
        (("4" (flatten)
          (("4" (expand "replace_local_var" 1)
            (("4" (rewrite "evaluable_in_fpaexpr_def_op")
              (("4" (rewrite "evaluable_in_fpaexpr_def_op")
                (("4" (flatten)
                  (("4" (split 1)
                    (("1" (assert) nil nil) ("2" (assert) nil nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("5" (grind) nil nil) ("6" (grind) nil nil))
      nil))
    nil)
   ((fpVarIndex const-decl "nat" expressions_semantics nil)
    (FPVariable? adt-recognizer-decl "[FPAExpr -> boolean]" expressions
     nil)
    (FPAExpr type-decl nil expressions nil)
    (FPParameter? adt-recognizer-decl "[FPAExpr -> boolean]"
     expressions nil)
    (DeBruijnIndex nonempty-type-eq-decl nil expressions nil)
    (index shared-adt-accessor-decl
           "[{x: FPAExpr | FPVariable?(x) OR FPParameter?(x)} -> DeBruijnIndex]"
           expressions nil)
    (<< adt-def-decl "(strict_well_founded?[FPAExpr])" expressions nil)
    (FPLocalEnvironment type-eq-decl nil expressions_semantics nil)
    (FPAExpr_induction formula-decl nil expressions nil)
    (FPConstant? adt-recognizer-decl "[FPAExpr -> boolean]" expressions
     nil)
    (FPConstant adt-constructor-decl "[FPNumber -> (FPConstant?)]"
     expressions nil)
    (FPNumber nonempty-type-eq-decl nil expressions nil)
    (FPVariable adt-constructor-decl "[DeBruijnIndex -> (FPVariable?)]"
     expressions nil)
    (ParameterIndex nonempty-type-eq-decl nil expressions nil)
    (FPParameter adt-constructor-decl
     "[ParameterIndex -> (FPParameter?)]" expressions nil)
    (evaluable_in_fpaexpr_def_op formula-decl nil expressions_semantics
     nil)
    (FPOperator? adt-recognizer-decl "[FPAExpr -> boolean]" expressions
     nil)
    (FPOperator adt-constructor-decl
     "[[Operator, FPAExpr, FPAExpr] -> (FPOperator?)]" expressions
     nil))
   shostak))
 (replace_local_var_in_rexpr_evaluable_in_TCC1 0
  (replace_local_var_in_rexpr_evaluable_in_TCC1-1 nil 3755693132
   ("" (subtype-tcc) nil nil) nil nil))
 (replace_local_var_in_rexpr_evaluable_in 0
  (replace_local_var_in_rexpr_evaluable_in-2 "" 3754409214
   ("" (skeep :but "expr2")
    (("" (induct "expr2")
      (("1" (grind) nil nil)
       ("2" (skolem 1 "idx")
        (("2" (expand "replace_local_var")
          (("2" (lift-if 1)
            (("2" (split 1)
              (("1" (flatten)
                (("1" (replace -1 :hide? t)
                  (("1" (typepred "expr1")
                    (("1" (assert)
                      (("1" (expand "bounded_by?")
                        (("1" (skeep 1 :preds? t)
                          (("1" (split -2)
                            (("1" (replace -1 :hide? t)
                              (("1"
                                (expand "rVarIndex")
                                (("1"
                                  (use "r_local_env.size_cons_def")
                                  (("1" (assert) nil nil))
                                  nil))
                                nil))
                              nil)
                             ("2" (assert) (("2" (grind) nil nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("2" (flatten)
                (("2" (expand "bounded_by?")
                  (("2" (iff)
                    (("2" (split 2)
                      (("1" (flatten)
                        (("1" (skeep 1 :preds? t)
                          (("1" (split -2)
                            (("1" (inst -3 "RVariable(idx)")
                              (("1" (grind) nil nil)) nil)
                             ("2" (expand "<<")
                              (("2" (propax) nil nil)) nil))
                            nil))
                          nil))
                        nil)
                       ("2" (flatten)
                        (("2" (skeep :preds? t)
                          (("2" (inst -3 "RVariable(idx-1)")
                            (("1" (grind) nil nil)
                             ("2" (grind) nil nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("3" (grind) nil nil)
       ("4" (skolem 1 ("op" "a1" "a2"))
        (("4" (flatten)
          (("4" (expand "replace_local_var" 1)
            (("4" (rewrite "evaluable_in_raexpr_def_op")
              (("4" (rewrite "evaluable_in_raexpr_def_op")
                (("4" (assert) (("4" (grind) nil nil)) nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((RAExpr type-decl nil expressions nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (RVariable? adt-recognizer-decl "[RAExpr -> boolean]" expressions
     nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (pred type-eq-decl nil defined_types nil)
    (strict_total_order? const-decl "bool" orders nil)
    (lt_r formal-const-decl "(strict_total_order?[RealNumber])"
     semantics nil)
    (applyFun_r formal-const-decl
     "[[Operator, RealNumber, RealNumber] -> RealNumber]" semantics
     nil)
    (lt_fp formal-const-decl
     "(strict_total_order?[FloatingPointNumber])" semantics nil)
    (applyFun_fp formal-const-decl
     "[[Operator, FloatingPointNumber, FloatingPointNumber] ->
   FloatingPointNumber]" semantics nil)
    (rVarIndex const-decl "nat" expressions_semantics nil)
    (strict_well_founded? const-decl "bool" orders nil)
    (<< adt-def-decl "(strict_well_founded?[RAExpr])" expressions nil)
    (LocalEnvironment nonempty-type-decl nil u_local_environment nil)
    (bounded_by? const-decl "bool" u_local_environment nil)
    (cons const-decl "LocalEnvironment" u_local_environment nil)
    (FPAExpr type-decl nil expressions nil)
    (FtoR def-decl "RAExpr" expressions nil)
    (RLocalEnvironment type-eq-decl nil expressions_semantics nil)
    (replace_local_var def-decl "RAExpr" semantics nil)
    (FtoR formal-const-decl "[FloatingPointNumber -> RealNumber]"
     semantics nil)
    (FloatingPointNumber formal-nonempty-type-decl nil semantics nil)
    (RealNumber formal-nonempty-type-decl nil semantics nil)
    (Operator formal-nonempty-type-decl nil semantics nil)
    (RAExpr_induction formula-decl nil expressions nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (RConstant? adt-recognizer-decl "[RAExpr -> boolean]" expressions
     nil)
    (RConstant adt-constructor-decl "[RNumber -> (RConstant?)]"
     expressions nil)
    (RNumber nonempty-type-eq-decl nil expressions nil)
    (size_cons_def formula-decl nil u_local_environment nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (RVariable adt-constructor-decl "[DeBruijnIndex -> (RVariable?)]"
     expressions nil)
    (DeBruijnIndex nonempty-type-eq-decl nil expressions nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (idx skolem-const-decl
     "DeBruijnIndex[Operator, RealNumber, FloatingPointNumber, FtoR]"
     semantics nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (ParameterIndex nonempty-type-eq-decl nil expressions nil)
    (RParameter? adt-recognizer-decl "[RAExpr -> boolean]" expressions
     nil)
    (RParameter adt-constructor-decl
     "[ParameterIndex -> (RParameter?)]" expressions nil)
    (evaluable_in_raexpr_def_op formula-decl nil expressions_semantics
     nil))
   shostak)
  (replace_local_var_in_rexpr_evaluable_in-1 nil 3754224620
   ("" (skeep :but "expr2")
    (("" (induct "expr2")
      (("1" (grind) nil nil)
       ("2" (skolem 1 "idx")
        (("2" (expand "replace_local_var")
          (("2" (lift-if 1)
            (("2" (split 1)
              (("1" (flatten)
                (("1" (replace -1 :hide? t)
                  (("1" (typepred "expr1")
                    (("1" (assert)
                      (("1" (expand "bounded_by?")
                        (("1" (skeep 1 :preds? t)
                          (("1" (split -2)
                            (("1" (replace -1 :hide? t)
                              (("1"
                                (expand "rVarIndex")
                                (("1"
                                  (use "r_local_env.size_cons_def")
                                  (("1" (assert) nil nil))
                                  nil))
                                nil))
                              nil)
                             ("2" (assert) (("2" (grind) nil nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("2" (flatten)
                (("2" (expand "bounded_by?")
                  (("2" (iff)
                    (("2" (split 2)
                      (("1" (flatten)
                        (("1" (skeep 1 :preds? t)
                          (("1" (split -2)
                            (("1" (inst -3 "v") (("1" (grind) nil nil))
                              nil)
                             ("2" (expand "<<")
                              (("2" (propax) nil nil)) nil))
                            nil))
                          nil))
                        nil)
                       ("2" (flatten)
                        (("2" (skeep :preds? t)
                          (("2" (inst -3 "v") (("2" (grind) nil nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("3" (grind) nil nil)
       ("4" (skolem 1 ("op" "a1" "a2"))
        (("4" (flatten)
          (("4" (expand "replace_local_var" 1)
            (("4" (rewrite "evaluable_in_raexpr_def_op")
              (("4" (rewrite "evaluable_in_raexpr_def_op")
                (("4" (assert) (("4" (grind) nil nil)) nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((evaluable_in_raexpr_def_op formula-decl nil expressions_semantics
     nil)
    (RParameter adt-constructor-decl
     "[ParameterIndex -> (RParameter?)]" expressions nil)
    (ParameterIndex nonempty-type-eq-decl nil expressions nil)
    (RVariable adt-constructor-decl "[DeBruijnIndex -> (RVariable?)]"
     expressions nil)
    (size_cons_def formula-decl nil u_local_environment nil)
    (RNumber nonempty-type-eq-decl nil expressions nil)
    (RConstant adt-constructor-decl "[RNumber -> (RConstant?)]"
     expressions nil)
    (RConstant? adt-recognizer-decl "[RAExpr -> boolean]" expressions
     nil)
    (RAExpr_induction formula-decl nil expressions nil)
    (RLocalEnvironment type-eq-decl nil expressions_semantics nil)
    (FtoR def-decl "RAExpr" expressions nil)
    (FPAExpr type-decl nil expressions nil)
    (cons const-decl "LocalEnvironment" u_local_environment nil)
    (bounded_by? const-decl "bool" u_local_environment nil)
    (LocalEnvironment nonempty-type-decl nil u_local_environment nil)
    (<< adt-def-decl "(strict_well_founded?[RAExpr])" expressions nil)
    (maxFreeLocalIndex_RAExpr def-decl "{maxInd: upfrom(-1) |
         IF EXISTS (local: (RVariable?)): subterm(local, rexpr)
           THEN (EXISTS (local: (RVariable?) | subterm(local, rexpr)):
                   index(local) = maxInd)
                 AND
                 (FORALL (local: (RVariable?) | subterm(local, rexpr)):
                    index(local) <= maxInd)
         ELSE maxInd = -1
         ENDIF}" expressions nil)
    (index shared-adt-accessor-decl
           "[{x: RAExpr | RVariable?(x) OR RParameter?(x)} -> DeBruijnIndex]"
           expressions nil)
    (DeBruijnIndex nonempty-type-eq-decl nil expressions nil)
    (RParameter? adt-recognizer-decl "[RAExpr -> boolean]" expressions
     nil)
    (rVarIndex const-decl "nat" expressions_semantics nil)
    (RVariable? adt-recognizer-decl "[RAExpr -> boolean]" expressions
     nil)
    (RAExpr type-decl nil expressions nil))
   nil))
 (replace_local_var_in_fpexpr_val_TCC1 0
  (replace_local_var_in_fpexpr_val_TCC1-1 nil 3753984123
   ("" (skeep :preds? t)
    (("" (use "replace_local_var_in_fpexpr_evaluable_in")
      (("" (assert) nil nil)) nil))
    nil)
   ((replace_local_var_in_fpexpr_evaluable_in formula-decl nil
     semantics nil)
    (FPLocalEnvironment type-eq-decl nil expressions_semantics nil)
    (cons const-decl "LocalEnvironment" u_local_environment nil)
    (bounded_by? const-decl "bool" u_local_environment nil)
    (LocalEnvironment nonempty-type-decl nil u_local_environment nil)
    (<< adt-def-decl "(strict_well_founded?[FPAExpr])" expressions nil)
    (strict_well_founded? const-decl "bool" orders nil)
    (fpVarIndex const-decl "nat" expressions_semantics nil)
    (applyFun_fp formal-const-decl
     "[[Operator, FloatingPointNumber, FloatingPointNumber] ->
   FloatingPointNumber]" semantics nil)
    (lt_fp formal-const-decl
     "(strict_total_order?[FloatingPointNumber])" semantics nil)
    (applyFun_r formal-const-decl
     "[[Operator, RealNumber, RealNumber] -> RealNumber]" semantics
     nil)
    (lt_r formal-const-decl "(strict_total_order?[RealNumber])"
     semantics nil)
    (strict_total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (FPVariable? adt-recognizer-decl "[FPAExpr -> boolean]" expressions
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (FPAExpr type-decl nil expressions nil)
    (FtoR formal-const-decl "[FloatingPointNumber -> RealNumber]"
     semantics nil)
    (FloatingPointNumber formal-nonempty-type-decl nil semantics nil)
    (RealNumber formal-nonempty-type-decl nil semantics nil)
    (Operator formal-nonempty-type-decl nil semantics nil))
   nil))
 (replace_local_var_in_fpexpr_val 0
  (replace_local_var_in_fpexpr_val-1 nil 3754067255
   ("" (skeep :but expr2)
    (("" (induct "expr2")
      (("1" (grind) nil nil) ("2" (grind) nil nil)
       ("3" (skolem 1 "idx")
        (("3" (flatten)
          (("3" (expand "replace_local_var" 1)
            (("3" (lift-if 1)
              (("3" (split 1)
                (("1" (flatten)
                  (("1" (replace -1 :hide? t)
                    (("1" (expand "eval" 1 1)
                      (("1" (use "fp_local_env.shrink_for_last_added")
                        (("1" (replace -1 :hide? t)
                          (("1" (use "fp_local_env.get_last_added")
                            (("1" (assert) nil nil)) nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (flatten)
                  (("2" (expand "eval" 2)
                    (("2" (case "idx <= size(fpLocalEnv)")
                      (("1"
                        (use "fp_local_env.shrink_env_monotonocity")
                        (("1" (use "fp_local_env.get_env_monotonocity")
                          (("1" (assert) nil nil)
                           ("2" (assert) nil nil))
                          nil)
                         ("2" (assert) nil nil))
                        nil)
                       ("2" (expand "bounded_by?")
                        (("2" (inst -1 "FPVariable(idx)")
                          (("2" (expand "fpVarIndex")
                            (("2" (assert) nil nil)) nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("4" (grind) nil nil)
       ("5" (skolem 1 ("op" "a1" "a2"))
        (("5" (flatten)
          (("5" (expand "replace_local_var" 1)
            (("5" (expand "eval" 1)
              (("5" (use "evaluable_in_fpaexpr_def_op")
                (("5" (replace -1 :hide? t)
                  (("5" (flatten) (("5" (assert) nil nil)) nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("6" (skeep)
        (("6" (use "replace_local_var_in_fpexpr_evaluable_in")
          (("6" (assert) nil nil)) nil))
        nil))
      nil))
    nil)
   ((replace_local_var def-decl "FPAExpr" semantics nil)
    (expr1 skolem-const-decl
     "{expr1: FPAExpr | bounded_by?(fpLocalEnv)(expr1)}" semantics nil)
    (fpLocalEnv skolem-const-decl "FPLocalEnvironment
    [Operator, RealNumber, lt_r, applyFun_r, FloatingPointNumber, lt_fp,
     applyFun_fp, FtoR]" semantics nil)
    (FPLocalEnvironment type-eq-decl nil expressions_semantics nil)
    (cons const-decl "LocalEnvironment" u_local_environment nil)
    (bounded_by? const-decl "bool" u_local_environment nil)
    (LocalEnvironment nonempty-type-decl nil u_local_environment nil)
    (<< adt-def-decl "(strict_well_founded?[FPAExpr])" expressions nil)
    (strict_well_founded? const-decl "bool" orders nil)
    (fpVarIndex const-decl "nat" expressions_semantics nil)
    (applyFun_fp formal-const-decl
     "[[Operator, FloatingPointNumber, FloatingPointNumber] ->
   FloatingPointNumber]" semantics nil)
    (lt_fp formal-const-decl
     "(strict_total_order?[FloatingPointNumber])" semantics nil)
    (applyFun_r formal-const-decl
     "[[Operator, RealNumber, RealNumber] -> RealNumber]" semantics
     nil)
    (lt_r formal-const-decl "(strict_total_order?[RealNumber])"
     semantics nil)
    (strict_total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (FPVariable? adt-recognizer-decl "[FPAExpr -> boolean]" expressions
     nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (FPAExpr type-decl nil expressions nil)
    (FPNumber nonempty-type-eq-decl nil expressions nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (ParameterIndex nonempty-type-eq-decl nil expressions nil)
    (FPEnvironment nonempty-type-eq-decl nil expressions_semantics nil)
    (eval def-decl "FPNumber" expressions_semantics nil)
    (FtoR formal-const-decl "[FloatingPointNumber -> RealNumber]"
     semantics nil)
    (FloatingPointNumber formal-nonempty-type-decl nil semantics nil)
    (RealNumber formal-nonempty-type-decl nil semantics nil)
    (Operator formal-nonempty-type-decl nil semantics nil)
    (FPAExpr_induction formula-decl nil expressions nil)
    (size_cons_def formula-decl nil u_local_environment nil)
    (<= const-decl "bool" reals nil)
    (DeBruijnIndex nonempty-type-eq-decl nil expressions nil)
    (size const-decl "nat" u_local_environment nil)
    (get_env_monotonocity formula-decl nil u_local_environment nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (idx skolem-const-decl
     "DeBruijnIndex[Operator, RealNumber, FloatingPointNumber, FtoR]"
     semantics nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (shrink_env_monotonocity formula-decl nil u_local_environment nil)
    (FPVariable adt-constructor-decl "[DeBruijnIndex -> (FPVariable?)]"
     expressions nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (get_last_added formula-decl nil u_local_environment nil)
    (shrink_for_last_added formula-decl nil u_local_environment nil)
    (evaluable_in_fpaexpr_def_op formula-decl nil expressions_semantics
     nil)
    (replace_local_var_in_fpexpr_evaluable_in formula-decl nil
     semantics nil))
   shostak))
 (replace_local_var_in_rexpr_val_TCC1 0
  (replace_local_var_in_rexpr_val_TCC1-2 nil 3754227013
   ("" (skosimp*)
    (("" (use "replace_local_var_in_rexpr_evaluable_in")
      (("" (assert) nil nil)) nil))
    nil)
   ((replace_local_var_in_rexpr_evaluable_in formula-decl nil semantics
     nil)
    (RLocalEnvironment type-eq-decl nil expressions_semantics nil)
    (FtoR def-decl "RAExpr" expressions nil)
    (FPAExpr type-decl nil expressions nil)
    (cons const-decl "LocalEnvironment" u_local_environment nil)
    (bounded_by? const-decl "bool" u_local_environment nil)
    (LocalEnvironment nonempty-type-decl nil u_local_environment nil)
    (<< adt-def-decl "(strict_well_founded?[RAExpr])" expressions nil)
    (strict_well_founded? const-decl "bool" orders nil)
    (rVarIndex const-decl "nat" expressions_semantics nil)
    (applyFun_fp formal-const-decl
     "[[Operator, FloatingPointNumber, FloatingPointNumber] ->
   FloatingPointNumber]" semantics nil)
    (lt_fp formal-const-decl
     "(strict_total_order?[FloatingPointNumber])" semantics nil)
    (applyFun_r formal-const-decl
     "[[Operator, RealNumber, RealNumber] -> RealNumber]" semantics
     nil)
    (lt_r formal-const-decl "(strict_total_order?[RealNumber])"
     semantics nil)
    (strict_total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (RVariable? adt-recognizer-decl "[RAExpr -> boolean]" expressions
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (RAExpr type-decl nil expressions nil)
    (FtoR formal-const-decl "[FloatingPointNumber -> RealNumber]"
     semantics nil)
    (FloatingPointNumber formal-nonempty-type-decl nil semantics nil)
    (RealNumber formal-nonempty-type-decl nil semantics nil)
    (Operator formal-nonempty-type-decl nil semantics nil))
   nil)
  (replace_local_var_in_rexpr_val_TCC1-1 nil 3754225291
   ("" (subtype-tcc) nil nil) nil nil))
 (replace_local_var_in_rexpr_val 0
  (replace_local_var_in_rexpr_val-2 nil 3754410877
   ("" (skeep :but expr2)
    (("" (induct "expr2")
      (("1" (grind) nil nil) ("2" (grind) nil nil)
       ("3" (skolem 1 "idx")
        (("3" (flatten)
          (("3" (expand "replace_local_var" 1)
            (("3" (lift-if 1)
              (("3" (split 1)
                (("1" (flatten)
                  (("1" (replace -1 :hide? t)
                    (("1" (expand "eval" 1 1)
                      (("1" (use "r_local_env.shrink_for_last_added")
                        (("1" (replace -1 :hide? t)
                          (("1" (use "r_local_env.get_last_added")
                            (("1" (assert) nil nil)) nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (flatten)
                  (("2" (expand "eval" 2)
                    (("2" (case "idx <= size(rLocalEnv)")
                      (("1" (use "r_local_env.shrink_env_monotonocity")
                        (("1" (use "r_local_env.get_env_monotonocity")
                          (("1" (assert) nil nil)
                           ("2" (assert) nil nil))
                          nil)
                         ("2" (assert) nil nil))
                        nil)
                       ("2" (expand "bounded_by?")
                        (("2" (inst -1 "RVariable(idx)")
                          (("2" (expand "rVarIndex")
                            (("2" (assert) nil nil)) nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("4" (grind) nil nil)
       ("5" (skolem 1 ("op" "a1" "a2"))
        (("5" (flatten)
          (("5" (expand "replace_local_var" 1)
            (("5" (expand "eval" 1)
              (("5" (use "evaluable_in_raexpr_def_op")
                (("5" (replace -1 :hide? t)
                  (("5" (flatten) (("5" (assert) nil nil)) nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("6" (skeep)
        (("6" (use "replace_local_var_in_rexpr_evaluable_in")
          (("6" (assert) nil nil)) nil))
        nil))
      nil))
    nil)
   ((replace_local_var def-decl "RAExpr" semantics nil)
    (expr1 skolem-const-decl
     "{expr1: FPAExpr | bounded_by?(rLocalEnv)(FtoR(expr1))}" semantics
     nil)
    (rLocalEnv skolem-const-decl "RLocalEnvironment
    [Operator, RealNumber, lt_r, applyFun_r, FloatingPointNumber, lt_fp,
     applyFun_fp, FtoR]" semantics nil)
    (RLocalEnvironment type-eq-decl nil expressions_semantics nil)
    (FtoR def-decl "RAExpr" expressions nil)
    (FPAExpr type-decl nil expressions nil)
    (cons const-decl "LocalEnvironment" u_local_environment nil)
    (bounded_by? const-decl "bool" u_local_environment nil)
    (LocalEnvironment nonempty-type-decl nil u_local_environment nil)
    (<< adt-def-decl "(strict_well_founded?[RAExpr])" expressions nil)
    (strict_well_founded? const-decl "bool" orders nil)
    (rVarIndex const-decl "nat" expressions_semantics nil)
    (applyFun_fp formal-const-decl
     "[[Operator, FloatingPointNumber, FloatingPointNumber] ->
   FloatingPointNumber]" semantics nil)
    (lt_fp formal-const-decl
     "(strict_total_order?[FloatingPointNumber])" semantics nil)
    (applyFun_r formal-const-decl
     "[[Operator, RealNumber, RealNumber] -> RealNumber]" semantics
     nil)
    (lt_r formal-const-decl "(strict_total_order?[RealNumber])"
     semantics nil)
    (strict_total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (RVariable? adt-recognizer-decl "[RAExpr -> boolean]" expressions
     nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (RAExpr type-decl nil expressions nil)
    (RNumber nonempty-type-eq-decl nil expressions nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (ParameterIndex nonempty-type-eq-decl nil expressions nil)
    (REnvironment nonempty-type-eq-decl nil expressions_semantics nil)
    (eval def-decl "RNumber" expressions_semantics nil)
    (FtoR formal-const-decl "[FloatingPointNumber -> RealNumber]"
     semantics nil)
    (FloatingPointNumber formal-nonempty-type-decl nil semantics nil)
    (RealNumber formal-nonempty-type-decl nil semantics nil)
    (Operator formal-nonempty-type-decl nil semantics nil)
    (RAExpr_induction formula-decl nil expressions nil)
    (size_cons_def formula-decl nil u_local_environment nil)
    (<= const-decl "bool" reals nil)
    (DeBruijnIndex nonempty-type-eq-decl nil expressions nil)
    (size const-decl "nat" u_local_environment nil)
    (get_env_monotonocity formula-decl nil u_local_environment nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (idx skolem-const-decl
     "DeBruijnIndex[Operator, RealNumber, FloatingPointNumber, FtoR]"
     semantics nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (shrink_env_monotonocity formula-decl nil u_local_environment nil)
    (RVariable adt-constructor-decl "[DeBruijnIndex -> (RVariable?)]"
     expressions nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (get_last_added formula-decl nil u_local_environment nil)
    (shrink_for_last_added formula-decl nil u_local_environment nil)
    (evaluable_in_raexpr_def_op formula-decl nil expressions_semantics
     nil)
    (replace_local_var_in_rexpr_evaluable_in formula-decl nil semantics
     nil))
   nil)
  (replace_local_var_in_rexpr_val-1 nil 3754225384
   ("" (skeep :but expr2)
    (("" (induct "expr2")
      (("1" (grind) nil nil) ("2" (grind) nil nil)
       ("3" (skolem 1 "idx")
        (("3" (flatten)
          (("3" (expand "replace_local_var" 1)
            (("3" (lift-if 1)
              (("3" (split 1)
                (("1" (flatten)
                  (("1" (replace -1 :hide? t)
                    (("1" (expand "eval" 1 1)
                      (("1" (use "r_local_env.shrink_for_last_added")
                        (("1" (replace -1 :hide? t)
                          (("1" (use "r_local_env.get_last_added")
                            (("1" (assert) nil nil)) nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (flatten)
                  (("2" (expand "eval" 2)
                    (("2" (case "idx < size(rLocalEnv)")
                      (("1" (use "r_local_env.shrink_env_monotonocity")
                        (("1" (use "r_local_env.get_env_monotonocity")
                          (("1" (assert) nil nil)) nil))
                        nil)
                       ("2" (expand "bounded_by?")
                        (("2" (inst -1 "RVariable(idx)")
                          (("2" (expand "rVarIndex")
                            (("2" (assert) nil nil)) nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("4" (grind) nil nil)
       ("5" (skolem 1 ("op" "a1" "a2"))
        (("5" (flatten)
          (("5" (expand "replace_local_var" 1)
            (("5" (expand "eval" 1)
              (("5" (use "evaluable_in_raexpr_def_op")
                (("5" (replace -1 :hide? t)
                  (("5" (flatten) (("5" (assert) nil nil)) nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("6" (skeep)
        (("6" (use "replace_local_var_in_rexpr_evaluable_in")
          (("6" (assert) nil nil)) nil))
        nil))
      nil))
    nil)
   ((size const-decl "nat" u_local_environment nil)
    (RLocalEnvironment type-eq-decl nil expressions_semantics nil)
    (FtoR def-decl "RAExpr" expressions nil)
    (FPAExpr type-decl nil expressions nil)
    (cons const-decl "LocalEnvironment" u_local_environment nil)
    (bounded_by? const-decl "bool" u_local_environment nil)
    (LocalEnvironment nonempty-type-decl nil u_local_environment nil)
    (<< adt-def-decl "(strict_well_founded?[RAExpr])" expressions nil)
    (maxFreeLocalIndex_RAExpr def-decl "{maxInd: upfrom(-1) |
         IF EXISTS (local: (RVariable?)): subterm(local, rexpr)
           THEN (EXISTS (local: (RVariable?) | subterm(local, rexpr)):
                   index(local) = maxInd)
                 AND
                 (FORALL (local: (RVariable?) | subterm(local, rexpr)):
                    index(local) <= maxInd)
         ELSE maxInd = -1
         ENDIF}" expressions nil)
    (index shared-adt-accessor-decl
           "[{x: RAExpr | RVariable?(x) OR RParameter?(x)} -> DeBruijnIndex]"
           expressions nil)
    (DeBruijnIndex nonempty-type-eq-decl nil expressions nil)
    (RParameter? adt-recognizer-decl "[RAExpr -> boolean]" expressions
     nil)
    (rVarIndex const-decl "nat" expressions_semantics nil)
    (RVariable? adt-recognizer-decl "[RAExpr -> boolean]" expressions
     nil)
    (RAExpr type-decl nil expressions nil)
    (RNumber nonempty-type-eq-decl nil expressions nil)
    (ParameterIndex nonempty-type-eq-decl nil expressions nil)
    (REnvironment nonempty-type-eq-decl nil expressions_semantics nil)
    (eval def-decl "RNumber" expressions_semantics nil)
    (RAExpr_induction formula-decl nil expressions nil)
    (size_cons_def formula-decl nil u_local_environment nil)
    (RVariable adt-constructor-decl "[DeBruijnIndex -> (RVariable?)]"
     expressions nil)
    (evaluable_in_raexpr_def_op formula-decl nil expressions_semantics
     nil))
   nil))
 (var_appears_in_replaced_expr_dec_var_appears_in_orig_expr 0
  (var_appears_in_replaced_expr_dec_var_appears_in_orig_expr-1 nil
   3754838825
   ("" (skeep :but "expr2")
    (("" (induct "expr2")
      (("1" (grind) nil nil) ("2" (grind) nil nil)
       ("3" (grind) nil nil) ("4" (grind) nil nil))
      nil))
    nil)
   ((nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (FPAExpr type-decl nil expressions nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (FPVariable? adt-recognizer-decl "[FPAExpr -> boolean]" expressions
     nil)
    (appears? const-decl "bool" expressions nil)
    (replace_local_var def-decl "FPAExpr" semantics nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (DeBruijnIndex nonempty-type-eq-decl nil expressions nil)
    (FPVariable adt-constructor-decl "[DeBruijnIndex -> (FPVariable?)]"
     expressions nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (FtoR formal-const-decl "[FloatingPointNumber -> RealNumber]"
     semantics nil)
    (FloatingPointNumber formal-nonempty-type-decl nil semantics nil)
    (RealNumber formal-nonempty-type-decl nil semantics nil)
    (Operator formal-nonempty-type-decl nil semantics nil)
    (FPAExpr_induction formula-decl nil expressions nil)
    (appearsFree? def-decl "bool" expressions nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (even_minus_odd_is_odd application-judgement "odd_int" integers
     nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil))
   shostak))
 (var_appears_in_replaced_rexpr_dec_var_appears_in_orig_rexpr 0
  (var_appears_in_replaced_rexpr_dec_var_appears_in_orig_rexpr-2 nil
   3755349279
   ("" (skeep :but "rexpr2")
    (("" (induct "rexpr2")
      (("1" (grind) nil nil) ("2" (grind) nil nil)
       ("3" (grind) nil nil) ("4" (grind) nil nil))
      nil))
    nil)
   ((nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (RAExpr type-decl nil expressions nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (RVariable? adt-recognizer-decl "[RAExpr -> boolean]" expressions
     nil)
    (appears? const-decl "bool" expressions nil)
    (replace_local_var def-decl "RAExpr" semantics nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (DeBruijnIndex nonempty-type-eq-decl nil expressions nil)
    (RVariable adt-constructor-decl "[DeBruijnIndex -> (RVariable?)]"
     expressions nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (FtoR formal-const-decl "[FloatingPointNumber -> RealNumber]"
     semantics nil)
    (FloatingPointNumber formal-nonempty-type-decl nil semantics nil)
    (RealNumber formal-nonempty-type-decl nil semantics nil)
    (Operator formal-nonempty-type-decl nil semantics nil)
    (RAExpr_induction formula-decl nil expressions nil)
    (appearsFree? def-decl "bool" expressions nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (even_minus_odd_is_odd application-judgement "odd_int" integers
     nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil))
   nil)
  (var_appears_in_replaced_rexpr_dec_var_appears_in_orig_rexpr-1 nil
   3755349255 ("" (postpone) nil nil) nil shostak))
 (eld_post_eval_ftor_TCC1 0
  (eld_post_eval_ftor_TCC1-1 nil 3756636729
   ("" (skeep* :preds? t)
    (("" (use "evaluable_in_expr_FtoR") (("" (assert) nil nil)) nil))
    nil)
   ((evaluable_in_expr_FtoR formula-decl nil expressions_semantics nil)
    (Operator formal-nonempty-type-decl nil semantics nil)
    (RealNumber formal-nonempty-type-decl nil semantics nil)
    (pred type-eq-decl nil defined_types nil)
    (strict_total_order? const-decl "bool" orders nil)
    (lt_r formal-const-decl "(strict_total_order?[RealNumber])"
     semantics nil)
    (applyFun_r formal-const-decl
     "[[Operator, RealNumber, RealNumber] -> RealNumber]" semantics
     nil)
    (FloatingPointNumber formal-nonempty-type-decl nil semantics nil)
    (lt_fp formal-const-decl
     "(strict_total_order?[FloatingPointNumber])" semantics nil)
    (applyFun_fp formal-const-decl
     "[[Operator, FloatingPointNumber, FloatingPointNumber] ->
   FloatingPointNumber]" semantics nil)
    (FtoR formal-const-decl "[FloatingPointNumber -> RealNumber]"
     semantics nil)
    (bounded_by? const-decl "bool" u_local_environment nil)
    (FtoR const-decl "{rle: RLocalEnvironment |
         size(fle) = size(rle) AND
          (FORALL (i: below(size(rle))): get(rle)(i) = FtoR(get(fle)(i)))}"
     expressions_semantics nil)
    (FtoR def-decl "RAExpr" expressions nil)
    (get const-decl "T" u_local_environment nil)
    (below type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (size const-decl "nat" u_local_environment nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (FPLocalEnvironment type-eq-decl nil expressions_semantics nil)
    (<< adt-def-decl "(strict_well_founded?[FPAExpr])" expressions nil)
    (fpVarIndex const-decl "nat" expressions_semantics nil)
    (FPVariable? adt-recognizer-decl "[FPAExpr -> boolean]" expressions
     nil)
    (FPAExpr type-decl nil expressions nil)
    (RLocalEnvironment type-eq-decl nil expressions_semantics nil)
    (LocalEnvironment nonempty-type-decl nil u_local_environment nil)
    (<< adt-def-decl "(strict_well_founded?[RAExpr])" expressions nil)
    (strict_well_founded? const-decl "bool" orders nil)
    (rVarIndex const-decl "nat" expressions_semantics nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (RVariable? adt-recognizer-decl "[RAExpr -> boolean]" expressions
     nil)
    (RAExpr type-decl nil expressions nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil))
 (eld_post_eval_ftor_TCC2 0
  (eld_post_eval_ftor_TCC2-1 nil 3756636729
   ("" (skeep* :preds? t)
    (("" (lemma "no_local_vars_evaluable_in")
      (("" (inst -1 "fpLocalEnv2" "res")
        (("" (use "evaluable_in_expr_FtoR") (("" (assert) nil nil))
          nil))
        nil))
      nil))
    nil)
   ((FtoR formal-const-decl "[FloatingPointNumber -> RealNumber]"
     semantics nil)
    (applyFun_fp formal-const-decl
     "[[Operator, FloatingPointNumber, FloatingPointNumber] ->
   FloatingPointNumber]" semantics nil)
    (lt_fp formal-const-decl
     "(strict_total_order?[FloatingPointNumber])" semantics nil)
    (FloatingPointNumber formal-nonempty-type-decl nil semantics nil)
    (applyFun_r formal-const-decl
     "[[Operator, RealNumber, RealNumber] -> RealNumber]" semantics
     nil)
    (lt_r formal-const-decl "(strict_total_order?[RealNumber])"
     semantics nil)
    (strict_total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (RealNumber formal-nonempty-type-decl nil semantics nil)
    (Operator formal-nonempty-type-decl nil semantics nil)
    (no_local_vars_evaluable_in formula-decl nil expressions_semantics
     nil)
    (evaluable_in_expr_FtoR formula-decl nil expressions_semantics nil)
    (FtoR const-decl "{rle: RLocalEnvironment |
         size(fle) = size(rle) AND
          (FORALL (i: below(size(rle))): get(rle)(i) = FtoR(get(fle)(i)))}"
     expressions_semantics nil)
    (FtoR def-decl "RAExpr" expressions nil)
    (get const-decl "T" u_local_environment nil)
    (below type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (size const-decl "nat" u_local_environment nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (RLocalEnvironment type-eq-decl nil expressions_semantics nil)
    (<< adt-def-decl "(strict_well_founded?[RAExpr])" expressions nil)
    (rVarIndex const-decl "nat" expressions_semantics nil)
    (RVariable? adt-recognizer-decl "[RAExpr -> boolean]" expressions
     nil)
    (RAExpr type-decl nil expressions nil)
    (NoLocalVars? const-decl "bool" expressions nil)
    (FPLocalEnvironment type-eq-decl nil expressions_semantics nil)
    (LocalEnvironment nonempty-type-decl nil u_local_environment nil)
    (<< adt-def-decl "(strict_well_founded?[FPAExpr])" expressions nil)
    (strict_well_founded? const-decl "bool" orders nil)
    (fpVarIndex const-decl "nat" expressions_semantics nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (FPVariable? adt-recognizer-decl "[FPAExpr -> boolean]" expressions
     nil)
    (FPAExpr type-decl nil expressions nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil))
 (expandLocalDefs_TCC1 0
  (expandLocalDefs_TCC1-1 nil 3756580677
   ("" (skeep* :preds? t)
    (("" (use "no_local_vars_evaluable_in") nil nil)) nil)
   ((res skolem-const-decl
         "FPAExpr[Operator, RealNumber, FloatingPointNumber, FtoR]"
         semantics nil)
    (NoLocalVars? const-decl "bool" expressions nil)
    (FPLocalEnvironment type-eq-decl nil expressions_semantics nil)
    (LocalEnvironment nonempty-type-decl nil u_local_environment nil)
    (<< adt-def-decl "(strict_well_founded?[FPAExpr])" expressions nil)
    (strict_well_founded? const-decl "bool" orders nil)
    (fpVarIndex const-decl "nat" expressions_semantics nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (FPVariable? adt-recognizer-decl "[FPAExpr -> boolean]" expressions
     nil)
    (FPAExpr type-decl nil expressions nil)
    (no_local_vars_evaluable_in formula-decl nil expressions_semantics
     nil)
    (Operator formal-nonempty-type-decl nil semantics nil)
    (RealNumber formal-nonempty-type-decl nil semantics nil)
    (pred type-eq-decl nil defined_types nil)
    (strict_total_order? const-decl "bool" orders nil)
    (lt_r formal-const-decl "(strict_total_order?[RealNumber])"
     semantics nil)
    (applyFun_r formal-const-decl
     "[[Operator, RealNumber, RealNumber] -> RealNumber]" semantics
     nil)
    (FloatingPointNumber formal-nonempty-type-decl nil semantics nil)
    (lt_fp formal-const-decl
     "(strict_total_order?[FloatingPointNumber])" semantics nil)
    (applyFun_fp formal-const-decl
     "[[Operator, FloatingPointNumber, FloatingPointNumber] ->
   FloatingPointNumber]" semantics nil)
    (FtoR formal-const-decl "[FloatingPointNumber -> RealNumber]"
     semantics nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil))
 (expandLocalDefs_TCC2 0
  (expandLocalDefs_TCC2-2 nil 3756634597
   ("" (use "fp_local_env.doublelessp_swf") (("" (grind) nil nil)) nil)
   ((well_founded? const-decl "bool" orders nil)
    (strict_order? const-decl "bool" orders nil)
    (transitive? const-decl "bool" relations nil)
    (irreflexive? const-decl "bool" relations nil)
    (<< const-decl "[EvaluationContext, EvaluationContext -> bool]"
     u_local_environment nil)
    (<< adt-def-decl "(strict_well_founded?[FPAExpr])" expressions nil)
    (strict_well_founded? const-decl "bool" orders nil)
    (fpVarIndex const-decl "nat" expressions_semantics nil)
    (applyFun_fp formal-const-decl
     "[[Operator, FloatingPointNumber, FloatingPointNumber] ->
   FloatingPointNumber]" semantics nil)
    (lt_fp formal-const-decl
     "(strict_total_order?[FloatingPointNumber])" semantics nil)
    (applyFun_r formal-const-decl
     "[[Operator, RealNumber, RealNumber] -> RealNumber]" semantics
     nil)
    (lt_r formal-const-decl "(strict_total_order?[RealNumber])"
     semantics nil)
    (strict_total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (FPVariable? adt-recognizer-decl "[FPAExpr -> boolean]" expressions
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (FPAExpr type-decl nil expressions nil)
    (FtoR formal-const-decl "[FloatingPointNumber -> RealNumber]"
     semantics nil)
    (FloatingPointNumber formal-nonempty-type-decl nil semantics nil)
    (RealNumber formal-nonempty-type-decl nil semantics nil)
    (Operator formal-nonempty-type-decl nil semantics nil)
    (doublelessp_swf formula-decl nil u_local_environment nil))
   nil)
  (expandLocalDefs_TCC2-1 nil 3756580677 ("" (grind) nil nil)
   ((FPAExpr type-decl nil expressions nil)
    (FPVariable? adt-recognizer-decl "[FPAExpr -> boolean]" expressions
     nil)
    (fpVarIndex const-decl "nat" expressions_semantics nil)
    (FPParameter? adt-recognizer-decl "[FPAExpr -> boolean]"
     expressions nil)
    (DeBruijnIndex nonempty-type-eq-decl nil expressions nil)
    (index shared-adt-accessor-decl
           "[{x: FPAExpr | FPVariable?(x) OR FPParameter?(x)} -> DeBruijnIndex]"
           expressions nil)
    (maxFreeLocalIndex def-decl "{maxInd: upfrom(-1) |
         IF EXISTS (local: (FPVariable?)): subterm(local, expr)
           THEN (EXISTS (local: (FPVariable?) | subterm(local, expr)):
                   index(local) = maxInd)
                 AND
                 (FORALL (local: (FPVariable?) | subterm(local, expr)):
                    index(local) <= maxInd)
         ELSE maxInd = -1
         ENDIF}" expressions nil)
    (LocalEnvironment nonempty-type-decl nil u_local_environment nil)
    (bounded_by? const-decl "bool" u_local_environment nil)
    (FPLocalEnvironment type-eq-decl nil expressions_semantics nil)
    (FPVariable adt-constructor-decl "[DeBruijnIndex -> (FPVariable?)]"
     expressions nil)
    (<< adt-def-decl "(strict_well_founded?[FPAExpr])" expressions
     nil))
   nil))
 (expandLocalDefs_TCC3 0
  (expandLocalDefs_TCC3-2 nil 3756634584 ("" (grind) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (FPAExpr type-decl nil expressions nil)
    (FPVariable? adt-recognizer-decl "[FPAExpr -> boolean]" expressions
     nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (pred type-eq-decl nil defined_types nil)
    (strict_total_order? const-decl "bool" orders nil)
    (lt_r formal-const-decl "(strict_total_order?[RealNumber])"
     semantics nil)
    (applyFun_r formal-const-decl
     "[[Operator, RealNumber, RealNumber] -> RealNumber]" semantics
     nil)
    (lt_fp formal-const-decl
     "(strict_total_order?[FloatingPointNumber])" semantics nil)
    (applyFun_fp formal-const-decl
     "[[Operator, FloatingPointNumber, FloatingPointNumber] ->
   FloatingPointNumber]" semantics nil)
    (fpVarIndex const-decl "nat" expressions_semantics nil)
    (strict_well_founded? const-decl "bool" orders nil)
    (LocalEnvironment nonempty-type-decl nil u_local_environment nil)
    (bounded_by? const-decl "bool" u_local_environment nil)
    (FPLocalEnvironment type-eq-decl nil expressions_semantics nil)
    (DeBruijnIndex nonempty-type-eq-decl nil expressions nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (FPVariable adt-constructor-decl "[DeBruijnIndex -> (FPVariable?)]"
     expressions nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (<< adt-def-decl "(strict_well_founded?[FPAExpr])" expressions nil)
    (Operator formal-nonempty-type-decl nil semantics nil)
    (RealNumber formal-nonempty-type-decl nil semantics nil)
    (FloatingPointNumber formal-nonempty-type-decl nil semantics nil)
    (FtoR formal-const-decl "[FloatingPointNumber -> RealNumber]"
     semantics nil))
   nil)
  (expandLocalDefs_TCC3-1 nil 3756580677
   ("" (skeep* :preds? t) (("" (assert) nil nil)) nil)
   ((local_definitions_are_evaluable_in_smaller_env formula-decl nil
     u_local_environment nil)
    (FPAExpr type-decl nil expressions nil)
    (FPVariable? adt-recognizer-decl "[FPAExpr -> boolean]" expressions
     nil)
    (fpVarIndex const-decl "nat" expressions_semantics nil)
    (FPParameter? adt-recognizer-decl "[FPAExpr -> boolean]"
     expressions nil)
    (DeBruijnIndex nonempty-type-eq-decl nil expressions nil)
    (index shared-adt-accessor-decl
           "[{x: FPAExpr | FPVariable?(x) OR FPParameter?(x)} -> DeBruijnIndex]"
           expressions nil)
    (maxFreeLocalIndex def-decl "{maxInd: upfrom(-1) |
         IF EXISTS (local: (FPVariable?)): subterm(local, expr)
           THEN (EXISTS (local: (FPVariable?) | subterm(local, expr)):
                   index(local) = maxInd)
                 AND
                 (FORALL (local: (FPVariable?) | subterm(local, expr)):
                    index(local) <= maxInd)
         ELSE maxInd = -1
         ENDIF}" expressions nil)
    (<< adt-def-decl "(strict_well_founded?[FPAExpr])" expressions
     nil))
   nil))
 (expandLocalDefs_TCC4 0
  (expandLocalDefs_TCC4-3 nil 3756634574
   ("" (skeep* :preds? t) (("" (assert) nil nil)) nil)
   ((real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (local_definitions_are_evaluable_in_smaller_env formula-decl nil
     u_local_environment nil)
    (Operator formal-nonempty-type-decl nil semantics nil)
    (RealNumber formal-nonempty-type-decl nil semantics nil)
    (FloatingPointNumber formal-nonempty-type-decl nil semantics nil)
    (FtoR formal-const-decl "[FloatingPointNumber -> RealNumber]"
     semantics nil)
    (FPAExpr type-decl nil expressions nil)
    (FPVariable? adt-recognizer-decl "[FPAExpr -> boolean]" expressions
     nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (pred type-eq-decl nil defined_types nil)
    (strict_total_order? const-decl "bool" orders nil)
    (lt_r formal-const-decl "(strict_total_order?[RealNumber])"
     semantics nil)
    (applyFun_r formal-const-decl
     "[[Operator, RealNumber, RealNumber] -> RealNumber]" semantics
     nil)
    (lt_fp formal-const-decl
     "(strict_total_order?[FloatingPointNumber])" semantics nil)
    (applyFun_fp formal-const-decl
     "[[Operator, FloatingPointNumber, FloatingPointNumber] ->
   FloatingPointNumber]" semantics nil)
    (fpVarIndex const-decl "nat" expressions_semantics nil)
    (strict_well_founded? const-decl "bool" orders nil)
    (<< adt-def-decl "(strict_well_founded?[FPAExpr])" expressions nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil)
  (expandLocalDefs_TCC4-2 nil 3756581261
   ("" (skeep :preds? t)
    (("" (expand "<<")
      (("" (flatten)
        ((""
          (use "fp_local_env.local_definitions_are_evaluable_in_smaller_env")
          (("" (expand "bounded_by?" -2)
            (("" (replace -4 :hide? t)
              (("" (expand "fpVarIndex")
                (("" (rewrite "size_shrink") (("" (grind) nil nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((size const-decl "nat" u_local_environment nil)
    (FPLocalEnvironment type-eq-decl nil expressions_semantics nil)
    (LocalEnvironment nonempty-type-decl nil u_local_environment nil)
    (local_definitions_are_evaluable_in_smaller_env formula-decl nil
     u_local_environment nil)
    (FPAExpr type-decl nil expressions nil)
    (FPVariable? adt-recognizer-decl "[FPAExpr -> boolean]" expressions
     nil)
    (fpVarIndex const-decl "nat" expressions_semantics nil)
    (FPParameter? adt-recognizer-decl "[FPAExpr -> boolean]"
     expressions nil)
    (DeBruijnIndex nonempty-type-eq-decl nil expressions nil)
    (index shared-adt-accessor-decl
           "[{x: FPAExpr | FPVariable?(x) OR FPParameter?(x)} -> DeBruijnIndex]"
           expressions nil)
    (maxFreeLocalIndex def-decl "{maxInd: upfrom(-1) |
         IF EXISTS (local: (FPVariable?)): subterm(local, expr)
           THEN (EXISTS (local: (FPVariable?) | subterm(local, expr)):
                   index(local) = maxInd)
                 AND
                 (FORALL (local: (FPVariable?) | subterm(local, expr)):
                    index(local) <= maxInd)
         ELSE maxInd = -1
         ENDIF}" expressions nil)
    (<< adt-def-decl "(strict_well_founded?[FPAExpr])" expressions
     nil))
   nil)
  (expandLocalDefs_TCC4-1 nil 3756580677 ("" (subtype-tcc) nil nil) nil
   nil))
 (expandLocalDefs_TCC5 0
  (expandLocalDefs_TCC5-2 nil 3756634556
   ("" (skeep :preds? t)
    (("" (expand "<<")
      (("" (flatten)
        ((""
          (use "fp_local_env.local_definitions_are_evaluable_in_smaller_env")
          (("" (expand "bounded_by?" -2)
            (("" (replace -4 :hide? t)
              (("" (expand "fpVarIndex")
                (("" (rewrite "size_shrink") (("" (grind) nil nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((<< const-decl "[EvaluationContext, EvaluationContext -> bool]"
     u_local_environment nil)
    (local_definitions_are_evaluable_in_smaller_env formula-decl nil
     u_local_environment nil)
    (Operator formal-nonempty-type-decl nil semantics nil)
    (RealNumber formal-nonempty-type-decl nil semantics nil)
    (FloatingPointNumber formal-nonempty-type-decl nil semantics nil)
    (FtoR formal-const-decl "[FloatingPointNumber -> RealNumber]"
     semantics nil)
    (FPAExpr type-decl nil expressions nil)
    (boolean nonempty-type-decl nil booleans nil)
    (FPVariable? adt-recognizer-decl "[FPAExpr -> boolean]" expressions
     nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (pred type-eq-decl nil defined_types nil)
    (strict_total_order? const-decl "bool" orders nil)
    (lt_r formal-const-decl "(strict_total_order?[RealNumber])"
     semantics nil)
    (applyFun_r formal-const-decl
     "[[Operator, RealNumber, RealNumber] -> RealNumber]" semantics
     nil)
    (lt_fp formal-const-decl
     "(strict_total_order?[FloatingPointNumber])" semantics nil)
    (applyFun_fp formal-const-decl
     "[[Operator, FloatingPointNumber, FloatingPointNumber] ->
   FloatingPointNumber]" semantics nil)
    (fpVarIndex const-decl "nat" expressions_semantics nil)
    (strict_well_founded? const-decl "bool" orders nil)
    (<< adt-def-decl "(strict_well_founded?[FPAExpr])" expressions nil)
    (DeBruijnIndex nonempty-type-eq-decl nil expressions nil)
    (below type-eq-decl nil naturalnumbers nil)
    (size const-decl "nat" u_local_environment nil)
    (< const-decl "bool" reals nil)
    (FPLocalEnvironment type-eq-decl nil expressions_semantics nil)
    (LocalEnvironment nonempty-type-decl nil u_local_environment nil)
    (size_shrink formula-decl nil u_local_environment nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (bounded_by? const-decl "bool" u_local_environment nil))
   nil)
  (expandLocalDefs_TCC5-1 nil 3756580677
   ("" (skeep :preds? t)
    (("" (use "evaluable_in_fpaexpr_def_op") (("" (assert) nil nil))
      nil))
    nil)
   ((evaluable_in_fpaexpr_def_op formula-decl nil expressions_semantics
     nil)
    (bounded_by? const-decl "bool" u_local_environment nil)
    (FPLocalEnvironment type-eq-decl nil expressions_semantics nil)
    (LocalEnvironment nonempty-type-decl nil u_local_environment nil)
    (<< adt-def-decl "(strict_well_founded?[FPAExpr])" expressions nil)
    (maxFreeLocalIndex def-decl "{maxInd: upfrom(-1) |
         IF EXISTS (local: (FPVariable?)): subterm(local, expr)
           THEN (EXISTS (local: (FPVariable?) | subterm(local, expr)):
                   index(local) = maxInd)
                 AND
                 (FORALL (local: (FPVariable?) | subterm(local, expr)):
                    index(local) <= maxInd)
         ELSE maxInd = -1
         ENDIF}" expressions nil)
    (index shared-adt-accessor-decl
           "[{x: FPAExpr | FPVariable?(x) OR FPParameter?(x)} -> DeBruijnIndex]"
           expressions nil)
    (DeBruijnIndex nonempty-type-eq-decl nil expressions nil)
    (FPParameter? adt-recognizer-decl "[FPAExpr -> boolean]"
     expressions nil)
    (fpVarIndex const-decl "nat" expressions_semantics nil)
    (FPVariable? adt-recognizer-decl "[FPAExpr -> boolean]" expressions
     nil)
    (FPAExpr type-decl nil expressions nil)
    (fp_eval_termination_1 formula-decl nil expressions_semantics nil))
   nil))
 (expandLocalDefs_TCC6 0
  (expandLocalDefs_TCC6-1 nil 3756581019
   ("" (skeep* :preds? t)
    (("" (with-tccs (name-replace "newEnv" "shrink(fpLocalEnv,idx)"))
      (("" (with-tccs (name-replace "newExpr" "get(fpLocalEnv)(idx)"))
        (("" (with-tccs (invoke (typepred "%1") (! 1 1 1)))
          (("" (split 1)
            (("1" (propax) nil nil)
             ("2" (skeep)
              (("2" (inst? -2)
                (("2" (expand "eval" 1 1)
                  (("2" (expand "newEnv")
                    (("2" (expand "newExpr")
                      (("2" (assert)
                        (("2" (replace -6) (("2" (assert) nil nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil)
             ("3" (expand "eld_post_eval_ftor")
              (("3" (skeep)
                (("3" (inst? -3)
                  (("3" (replace -6)
                    (("3" (expand "eval" 1 1)
                      (("3" (expand "FtoR" 1 1)
                        (("3" (expand "newEnv")
                          (("3" (expand "newExpr")
                            (("3" (replace -3 :dir rl)
                              (("3"
                                (rewrite "ftor_get")
                                (("3" (rewrite "ftor_shrink") nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((eval_NoLocalVars? rec-application-judgement
     "{res: FPNumber[Operator, RealNumber, FloatingPointNumber, FtoR] |
         FORALL (fpLocalEnv2:
                   FPLocalEnvironment
                       [Operator, RealNumber, lt_r, applyFun_r,
                        FloatingPointNumber, lt_fp, applyFun_fp, FtoR]):
           eval(fpParamEnv, fpLocalEnv2)(nlv_expr) = res}" semantics
     nil)
    (bijective? const-decl "bool" functions nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (Operator formal-nonempty-type-decl nil semantics nil)
    (RealNumber formal-nonempty-type-decl nil semantics nil)
    (FloatingPointNumber formal-nonempty-type-decl nil semantics nil)
    (FtoR formal-const-decl "[FloatingPointNumber -> RealNumber]"
     semantics nil)
    (DeBruijnIndex nonempty-type-eq-decl nil expressions nil)
    (FPAExpr type-decl nil expressions nil)
    (FPVariable? adt-recognizer-decl "[FPAExpr -> boolean]" expressions
     nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (pred type-eq-decl nil defined_types nil)
    (strict_total_order? const-decl "bool" orders nil)
    (lt_r formal-const-decl "(strict_total_order?[RealNumber])"
     semantics nil)
    (applyFun_r formal-const-decl
     "[[Operator, RealNumber, RealNumber] -> RealNumber]" semantics
     nil)
    (lt_fp formal-const-decl
     "(strict_total_order?[FloatingPointNumber])" semantics nil)
    (applyFun_fp formal-const-decl
     "[[Operator, FloatingPointNumber, FloatingPointNumber] ->
   FloatingPointNumber]" semantics nil)
    (fpVarIndex const-decl "nat" expressions_semantics nil)
    (strict_well_founded? const-decl "bool" orders nil)
    (<< adt-def-decl "(strict_well_founded?[FPAExpr])" expressions nil)
    (LocalEnvironment nonempty-type-decl nil u_local_environment nil)
    (size const-decl "nat" u_local_environment nil)
    (FPLocalEnvironment type-eq-decl nil expressions_semantics nil)
    (bounded_by? const-decl "bool" u_local_environment nil)
    (below type-eq-decl nil naturalnumbers nil)
    (shrink const-decl "LocalEnvironment" u_local_environment nil)
    (get const-decl "T" u_local_environment nil)
    (EvaluationContext type-eq-decl nil u_local_environment nil)
    (<< const-decl "[EvaluationContext, EvaluationContext -> bool]"
     u_local_environment nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (NoLocalVars? const-decl "bool" expressions nil)
    (ParameterIndex nonempty-type-eq-decl nil expressions nil)
    (FPNumber nonempty-type-eq-decl nil expressions nil)
    (FPEnvironment nonempty-type-eq-decl nil expressions_semantics nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (eval def-decl "FPNumber" expressions_semantics nil)
    (eld_post_eval_ftor const-decl "bool" semantics nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (eval def-decl "RNumber" expressions_semantics nil)
    (ftor_shrink formula-decl nil expressions_semantics nil)
    (ftor_get formula-decl nil expressions_semantics nil)
    (FtoR def-decl "RAExpr" expressions nil)
    (newExpr skolem-const-decl
     "FPAExpr[Operator, RealNumber, FloatingPointNumber, FtoR]"
     semantics nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (newEnv skolem-const-decl "LocalEnvironment
    [FPAExpr[Operator, RealNumber, FloatingPointNumber, FtoR], FPVariable?,
     fpVarIndex, <<]" semantics nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil))
 (expandLocalDefs_TCC7 1
  (expandLocalDefs_TCC7-3 nil 3756634503
   ("" (skeep :preds? t)
    (("" (use "evaluable_in_fpaexpr_def_op") (("" (assert) nil)))) nil)
   ((FPVariable? adt-recognizer-decl "[FPAExpr -> boolean]" expressions
     nil)
    (fpVarIndex const-decl "nat" expressions_semantics nil)
    (FPParameter? adt-recognizer-decl "[FPAExpr -> boolean]"
     expressions nil)
    (DeBruijnIndex nonempty-type-eq-decl nil expressions nil)
    (index shared-adt-accessor-decl
           "[{x: FPAExpr | FPVariable?(x) OR FPParameter?(x)} -> DeBruijnIndex]"
           expressions nil)
    (maxFreeLocalIndex def-decl "{maxInd: upfrom(-1) |
         IF EXISTS (local: (FPVariable?)): subterm(local, expr)
           THEN (EXISTS (local: (FPVariable?) | subterm(local, expr)):
                   index(local) = maxInd)
                 AND
                 (FORALL (local: (FPVariable?) | subterm(local, expr)):
                    index(local) <= maxInd)
         ELSE maxInd = -1
         ENDIF}" expressions nil)
    (<< adt-def-decl "(strict_well_founded?[FPAExpr])" expressions nil)
    (LocalEnvironment nonempty-type-decl nil u_local_environment nil)
    (FPLocalEnvironment type-eq-decl nil expressions_semantics nil)
    (FPAExpr type-decl nil expressions nil)
    (evaluable_in_fpaexpr_def_op formula-decl nil expressions_semantics
     nil))
   nil)
  (expandLocalDefs_TCC7-2 nil 3756581690
   ("" (skeep :preds? t)
    (("" (use "evaluable_in_fpaexpr_def_op") (("" (assert) nil nil))
      nil))
    nil)
   ((evaluable_in_fpaexpr_def_op formula-decl nil expressions_semantics
     nil)
    (Operator formal-nonempty-type-decl nil semantics nil)
    (RealNumber formal-nonempty-type-decl nil semantics nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (pred type-eq-decl nil defined_types nil)
    (strict_total_order? const-decl "bool" orders nil)
    (lt_r formal-const-decl "(strict_total_order?[RealNumber])"
     semantics nil)
    (applyFun_r formal-const-decl
     "[[Operator, RealNumber, RealNumber] -> RealNumber]" semantics
     nil)
    (FloatingPointNumber formal-nonempty-type-decl nil semantics nil)
    (lt_fp formal-const-decl
     "(strict_total_order?[FloatingPointNumber])" semantics nil)
    (applyFun_fp formal-const-decl
     "[[Operator, FloatingPointNumber, FloatingPointNumber] ->
   FloatingPointNumber]" semantics nil)
    (FtoR formal-const-decl "[FloatingPointNumber -> RealNumber]"
     semantics nil)
    (FPAExpr type-decl nil expressions nil)
    (FPLocalEnvironment type-eq-decl nil expressions_semantics nil)
    (LocalEnvironment nonempty-type-decl nil u_local_environment nil)
    (<< adt-def-decl "(strict_well_founded?[FPAExpr])" expressions nil)
    (strict_well_founded? const-decl "bool" orders nil)
    (fpVarIndex const-decl "nat" expressions_semantics nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (FPVariable? adt-recognizer-decl "[FPAExpr -> boolean]" expressions
     nil))
   nil)
  (expandLocalDefs_TCC7-1 nil 3756581019 ("" (subtype-tcc) nil nil) nil
   nil))
 (expandLocalDefs_TCC8 0
  (expandLocalDefs_TCC8-2 nil 3756634476 ("" (termination-tcc) nil nil)
   ((NOT const-decl "[bool -> bool]" booleans nil)
    (LocalEnvironment nonempty-type-decl nil u_local_environment nil)
    (bounded_by? const-decl "bool" u_local_environment nil)
    (FPLocalEnvironment type-eq-decl nil expressions_semantics nil)
    (<< adt-def-decl "(strict_well_founded?[FPAExpr])" expressions nil)
    (strict_well_founded? const-decl "bool" orders nil)
    (fpVarIndex const-decl "nat" expressions_semantics nil)
    (applyFun_fp formal-const-decl
     "[[Operator, FloatingPointNumber, FloatingPointNumber] ->
   FloatingPointNumber]" semantics nil)
    (lt_fp formal-const-decl
     "(strict_total_order?[FloatingPointNumber])" semantics nil)
    (applyFun_r formal-const-decl
     "[[Operator, RealNumber, RealNumber] -> RealNumber]" semantics
     nil)
    (lt_r formal-const-decl "(strict_total_order?[RealNumber])"
     semantics nil)
    (strict_total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (FPVariable? adt-recognizer-decl "[FPAExpr -> boolean]" expressions
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (FPAExpr type-decl nil expressions nil)
    (FtoR formal-const-decl "[FloatingPointNumber -> RealNumber]"
     semantics nil)
    (FloatingPointNumber formal-nonempty-type-decl nil semantics nil)
    (RealNumber formal-nonempty-type-decl nil semantics nil)
    (Operator formal-nonempty-type-decl nil semantics nil)
    (<< const-decl "[EvaluationContext, EvaluationContext -> bool]"
     u_local_environment nil))
   nil)
  (expandLocalDefs_TCC8-1 nil 3756581019 ("" (termination-tcc) nil nil)
   ((LocalEnvironment nonempty-type-decl nil u_local_environment nil)
    (bounded_by? const-decl "bool" u_local_environment nil)
    (FPLocalEnvironment type-eq-decl nil expressions_semantics nil)
    (<< adt-def-decl "(strict_well_founded?[FPAExpr])" expressions nil)
    (maxFreeLocalIndex def-decl "{maxInd: upfrom(-1) |
         IF EXISTS (local: (FPVariable?)): subterm(local, expr)
           THEN (EXISTS (local: (FPVariable?) | subterm(local, expr)):
                   index(local) = maxInd)
                 AND
                 (FORALL (local: (FPVariable?) | subterm(local, expr)):
                    index(local) <= maxInd)
         ELSE maxInd = -1
         ENDIF}" expressions nil)
    (index shared-adt-accessor-decl
           "[{x: FPAExpr | FPVariable?(x) OR FPParameter?(x)} -> DeBruijnIndex]"
           expressions nil)
    (DeBruijnIndex nonempty-type-eq-decl nil expressions nil)
    (FPParameter? adt-recognizer-decl "[FPAExpr -> boolean]"
     expressions nil)
    (fpVarIndex const-decl "nat" expressions_semantics nil)
    (FPVariable? adt-recognizer-decl "[FPAExpr -> boolean]" expressions
     nil)
    (FPAExpr type-decl nil expressions nil)
    (<< const-decl "[EvaluationContext, EvaluationContext -> bool]"
     u_local_environment nil))
   nil))
 (expandLocalDefs_TCC9 0
  (expandLocalDefs_TCC9-2 nil 3756634456
   ("" (skeep :preds? t)
    (("" (use "evaluable_in_fpaexpr_def_op") (("" (assert) nil nil))
      nil))
    nil)
   ((evaluable_in_fpaexpr_def_op formula-decl nil expressions_semantics
     nil)
    (Operator formal-nonempty-type-decl nil semantics nil)
    (RealNumber formal-nonempty-type-decl nil semantics nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (pred type-eq-decl nil defined_types nil)
    (strict_total_order? const-decl "bool" orders nil)
    (lt_r formal-const-decl "(strict_total_order?[RealNumber])"
     semantics nil)
    (applyFun_r formal-const-decl
     "[[Operator, RealNumber, RealNumber] -> RealNumber]" semantics
     nil)
    (FloatingPointNumber formal-nonempty-type-decl nil semantics nil)
    (lt_fp formal-const-decl
     "(strict_total_order?[FloatingPointNumber])" semantics nil)
    (applyFun_fp formal-const-decl
     "[[Operator, FloatingPointNumber, FloatingPointNumber] ->
   FloatingPointNumber]" semantics nil)
    (FtoR formal-const-decl "[FloatingPointNumber -> RealNumber]"
     semantics nil)
    (FPAExpr type-decl nil expressions nil)
    (FPLocalEnvironment type-eq-decl nil expressions_semantics nil)
    (LocalEnvironment nonempty-type-decl nil u_local_environment nil)
    (<< adt-def-decl "(strict_well_founded?[FPAExpr])" expressions nil)
    (strict_well_founded? const-decl "bool" orders nil)
    (fpVarIndex const-decl "nat" expressions_semantics nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (FPVariable? adt-recognizer-decl "[FPAExpr -> boolean]" expressions
     nil))
   nil)
  (expandLocalDefs_TCC9-1 nil 3756631959 ("" (subtype-tcc) nil nil) nil
   nil))
 (expandLocalDefs_TCC10 0
  (expandLocalDefs_TCC10-2 nil 3756634277
   ("" (termination-tcc) nil nil)
   ((NOT const-decl "[bool -> bool]" booleans nil)
    (LocalEnvironment nonempty-type-decl nil u_local_environment nil)
    (bounded_by? const-decl "bool" u_local_environment nil)
    (FPLocalEnvironment type-eq-decl nil expressions_semantics nil)
    (<< adt-def-decl "(strict_well_founded?[FPAExpr])" expressions nil)
    (strict_well_founded? const-decl "bool" orders nil)
    (fpVarIndex const-decl "nat" expressions_semantics nil)
    (applyFun_fp formal-const-decl
     "[[Operator, FloatingPointNumber, FloatingPointNumber] ->
   FloatingPointNumber]" semantics nil)
    (lt_fp formal-const-decl
     "(strict_total_order?[FloatingPointNumber])" semantics nil)
    (applyFun_r formal-const-decl
     "[[Operator, RealNumber, RealNumber] -> RealNumber]" semantics
     nil)
    (lt_r formal-const-decl "(strict_total_order?[RealNumber])"
     semantics nil)
    (strict_total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (FPVariable? adt-recognizer-decl "[FPAExpr -> boolean]" expressions
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (FPAExpr type-decl nil expressions nil)
    (FtoR formal-const-decl "[FloatingPointNumber -> RealNumber]"
     semantics nil)
    (FloatingPointNumber formal-nonempty-type-decl nil semantics nil)
    (RealNumber formal-nonempty-type-decl nil semantics nil)
    (Operator formal-nonempty-type-decl nil semantics nil)
    (<< const-decl "[EvaluationContext, EvaluationContext -> bool]"
     u_local_environment nil))
   nil)
  (expandLocalDefs_TCC10-1 nil 3756631959
   ("" (termination-tcc) nil nil)
   ((LocalEnvironment nonempty-type-decl nil u_local_environment nil)
    (bounded_by? const-decl "bool" u_local_environment nil)
    (FPLocalEnvironment type-eq-decl nil expressions_semantics nil)
    (<< adt-def-decl "(strict_well_founded?[FPAExpr])" expressions nil)
    (maxFreeLocalIndex def-decl "{maxInd: upfrom(-1) |
         IF EXISTS (local: (FPVariable?)): subterm(local, expr)
           THEN (EXISTS (local: (FPVariable?) | subterm(local, expr)):
                   index(local) = maxInd)
                 AND
                 (FORALL (local: (FPVariable?) | subterm(local, expr)):
                    index(local) <= maxInd)
         ELSE maxInd = -1
         ENDIF}" expressions nil)
    (index shared-adt-accessor-decl
           "[{x: FPAExpr | FPVariable?(x) OR FPParameter?(x)} -> DeBruijnIndex]"
           expressions nil)
    (DeBruijnIndex nonempty-type-eq-decl nil expressions nil)
    (FPParameter? adt-recognizer-decl "[FPAExpr -> boolean]"
     expressions nil)
    (fpVarIndex const-decl "nat" expressions_semantics nil)
    (FPVariable? adt-recognizer-decl "[FPAExpr -> boolean]" expressions
     nil)
    (FPAExpr type-decl nil expressions nil)
    (<< const-decl "[EvaluationContext, EvaluationContext -> bool]"
     u_local_environment nil))
   nil))
 (expandLocalDefs_TCC11 0
  (expandLocalDefs_TCC11-1 nil 3756631959
   ("" (skeep* :preds? t)
    (("" (with-tccs (invoke (typepred "%1") (! 1 1 1 2)))
      (("" (with-tccs (invoke (typepred "%1") (! 1 1 1 3)))
        (("" (split 1)
          (("1" (expand "NoLocalVars?")
            (("1" (skeep)
              (("1" (inst -2 "local")
                (("1" (inst -4 "local")
                  (("1" (rewrite "appears?_expr_subterm")
                    (("1" (rewrite "appears?_expr_subterm")
                      (("1" (rewrite "appears?_expr_subterm")
                        (("1" (grind) nil nil)) nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil)
           ("2" (skeep)
            (("2" (insteep -2)
              (("2" (insteep -5)
                (("2" (replace -8 :hide? t)
                  (("2" (expand "eval" 1) (("2" (assert) nil nil))
                    nil))
                  nil))
                nil))
              nil))
            nil)
           ("3" (expand "eld_post_eval_ftor")
            (("3" (skeep)
              (("3" (insteep -3)
                (("3" (insteep -6)
                  (("3" (replace -8 :hide? t)
                    (("3" (expand "FtoR" 1 (3 6))
                      (("3" (expand "eval" 1)
                        (("3" (replace -3 :hide? t)
                          (("3" (replace -5 :hide? t)
                            (("3" (propax) nil nil)) nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((bijective? const-decl "bool" functions nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (Operator formal-nonempty-type-decl nil semantics nil)
    (RealNumber formal-nonempty-type-decl nil semantics nil)
    (FloatingPointNumber formal-nonempty-type-decl nil semantics nil)
    (FtoR formal-const-decl "[FloatingPointNumber -> RealNumber]"
     semantics nil)
    (FPAExpr type-decl nil expressions nil)
    (FPVariable? adt-recognizer-decl "[FPAExpr -> boolean]" expressions
     nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (pred type-eq-decl nil defined_types nil)
    (strict_total_order? const-decl "bool" orders nil)
    (lt_r formal-const-decl "(strict_total_order?[RealNumber])"
     semantics nil)
    (applyFun_r formal-const-decl
     "[[Operator, RealNumber, RealNumber] -> RealNumber]" semantics
     nil)
    (lt_fp formal-const-decl
     "(strict_total_order?[FloatingPointNumber])" semantics nil)
    (applyFun_fp formal-const-decl
     "[[Operator, FloatingPointNumber, FloatingPointNumber] ->
   FloatingPointNumber]" semantics nil)
    (fpVarIndex const-decl "nat" expressions_semantics nil)
    (strict_well_founded? const-decl "bool" orders nil)
    (<< adt-def-decl "(strict_well_founded?[FPAExpr])" expressions nil)
    (LocalEnvironment nonempty-type-decl nil u_local_environment nil)
    (bounded_by? const-decl "bool" u_local_environment nil)
    (FPLocalEnvironment type-eq-decl nil expressions_semantics nil)
    (EvaluationContext type-eq-decl nil u_local_environment nil)
    (<< const-decl "[EvaluationContext, EvaluationContext -> bool]"
     u_local_environment nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (NoLocalVars? const-decl "bool" expressions nil)
    (FPOperator? adt-recognizer-decl "[FPAExpr -> boolean]" expressions
     nil)
    (FPOperator adt-constructor-decl
     "[[Operator, FPAExpr, FPAExpr] -> (FPOperator?)]" expressions nil)
    (ParameterIndex nonempty-type-eq-decl nil expressions nil)
    (FPNumber nonempty-type-eq-decl nil expressions nil)
    (FPEnvironment nonempty-type-eq-decl nil expressions_semantics nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (eval def-decl "FPNumber" expressions_semantics nil)
    (eld_post_eval_ftor const-decl "bool" semantics nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (subterm adt-def-decl "boolean" expressions nil)
    (FtoR const-decl "{rle: RLocalEnvironment |
         size(fle) = size(rle) AND
          (FORALL (i: below(size(rle))): get(rle)(i) = FtoR(get(fle)(i)))}"
     expressions_semantics nil)
    (appears?_expr_subterm formula-decl nil expressions nil)
    (FtoR def-decl "RAExpr" expressions nil)
    (eval def-decl "RNumber" expressions_semantics nil)
    (eval_NoLocalVars? rec-application-judgement
     "{res: FPNumber[Operator, RealNumber, FloatingPointNumber, FtoR] |
         FORALL (fpLocalEnv2:
                   FPLocalEnvironment
                       [Operator, RealNumber, lt_r, applyFun_r,
                        FloatingPointNumber, lt_fp, applyFun_fp, FtoR]):
           eval(fpParamEnv, fpLocalEnv2)(nlv_expr) = res}" semantics
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil))
 (expandLocalDefs_TCC12 0
  (expandLocalDefs_TCC12-1 nil 3756631959
   ("" (skeep* :preds? t)
    (("" (split 3)
      (("1" (grind) nil nil)
       ("2" (skeep)
        (("2" (expand "eval")
          (("2" (assert) (("2" (grind) nil nil)) nil)) nil))
        nil)
       ("3" (expand "eld_post_eval_ftor")
        (("3" (skeep)
          (("3" (expand "FtoR") (("3" (grind) nil nil)) nil)) nil))
        nil))
      nil))
    nil)
   ((appearsFree? def-decl "bool" expressions nil)
    (FtoR formal-const-decl "[FloatingPointNumber -> RealNumber]"
     semantics nil)
    (FloatingPointNumber formal-nonempty-type-decl nil semantics nil)
    (RealNumber formal-nonempty-type-decl nil semantics nil)
    (Operator formal-nonempty-type-decl nil semantics nil)
    (appears? const-decl "bool" expressions nil)
    (NoLocalVars? const-decl "bool" expressions nil)
    (applyFun_fp formal-const-decl
     "[[Operator, FloatingPointNumber, FloatingPointNumber] ->
   FloatingPointNumber]" semantics nil)
    (lt_fp formal-const-decl
     "(strict_total_order?[FloatingPointNumber])" semantics nil)
    (applyFun_r formal-const-decl
     "[[Operator, RealNumber, RealNumber] -> RealNumber]" semantics
     nil)
    (lt_r formal-const-decl "(strict_total_order?[RealNumber])"
     semantics nil)
    (strict_total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (fpVarIndex const-decl "nat" expressions_semantics nil)
    (<< adt-def-decl "(strict_well_founded?[FPAExpr])" expressions nil)
    (strict_well_founded? const-decl "bool" orders nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (FPVariable? adt-recognizer-decl "[FPAExpr -> boolean]" expressions
     nil)
    (FPAExpr type-decl nil expressions nil)
    (bounded_by? const-decl "bool" u_local_environment nil)
    (eval def-decl "FPNumber" expressions_semantics nil)
    (eval def-decl "RNumber" expressions_semantics nil)
    (FtoR const-decl "InducedREnv(fpEnv)" expressions_semantics nil)
    (FtoR const-decl "{rle: RLocalEnvironment |
         size(fle) = size(rle) AND
          (FORALL (i: below(size(rle))): get(rle)(i) = FtoR(get(fle)(i)))}"
     expressions_semantics nil)
    (FtoR def-decl "RAExpr" expressions nil)
    (eld_post_eval_ftor const-decl "bool" semantics nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil))
 (expandLocalDefs_no_local_vars 0
  (expandLocalDefs_no_local_vars-1 nil 3756581729
   ("" (skeep :preds? t)
    (("" (invoke (typepred "%1") (! 1 1)) nil nil)) nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (Operator formal-nonempty-type-decl nil semantics nil)
    (RealNumber formal-nonempty-type-decl nil semantics nil)
    (FloatingPointNumber formal-nonempty-type-decl nil semantics nil)
    (FtoR formal-const-decl "[FloatingPointNumber -> RealNumber]"
     semantics nil)
    (FPAExpr type-decl nil expressions nil)
    (NoLocalVars? const-decl "bool" expressions nil)
    (FPVariable? adt-recognizer-decl "[FPAExpr -> boolean]" expressions
     nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (pred type-eq-decl nil defined_types nil)
    (strict_total_order? const-decl "bool" orders nil)
    (lt_r formal-const-decl "(strict_total_order?[RealNumber])"
     semantics nil)
    (applyFun_r formal-const-decl
     "[[Operator, RealNumber, RealNumber] -> RealNumber]" semantics
     nil)
    (lt_fp formal-const-decl
     "(strict_total_order?[FloatingPointNumber])" semantics nil)
    (applyFun_fp formal-const-decl
     "[[Operator, FloatingPointNumber, FloatingPointNumber] ->
   FloatingPointNumber]" semantics nil)
    (fpVarIndex const-decl "nat" expressions_semantics nil)
    (strict_well_founded? const-decl "bool" orders nil)
    (<< adt-def-decl "(strict_well_founded?[FPAExpr])" expressions nil)
    (LocalEnvironment nonempty-type-decl nil u_local_environment nil)
    (FPLocalEnvironment type-eq-decl nil expressions_semantics nil)
    (bounded_by? const-decl "bool" u_local_environment nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (ParameterIndex nonempty-type-eq-decl nil expressions nil)
    (FPNumber nonempty-type-eq-decl nil expressions nil)
    (FPEnvironment nonempty-type-eq-decl nil expressions_semantics nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (eval def-decl "FPNumber" expressions_semantics nil)
    (eld_post_eval_ftor const-decl "bool" semantics nil)
    (expandLocalDefs def-decl "{res: FPAExpr |
         NoLocalVars?(res) AND
          (FORALL (fpParamEnv, fpLocalEnv2):
             eval(fpParamEnv, fpLocalEnv)(expr) =
              eval(fpParamEnv, fpLocalEnv2)(res))
           AND eld_post_eval_ftor(fpLocalEnv, expr, res)}" semantics
     nil))
   shostak))
 (expandLocalDefs_eval_TCC1 0
  (expandLocalDefs_eval_TCC1-1 nil 3756579547
   ("" (skeep* :preds? t)
    (("" (use "expandLocalDefs_no_local_vars")
      (("" (lemma "no_local_vars_evaluable_in")
        (("" (inst? -1 :where 1) nil nil)) nil))
      nil))
    nil)
   ((expandLocalDefs_no_local_vars formula-decl nil semantics nil)
    (FPLocalEnvironment type-eq-decl nil expressions_semantics nil)
    (LocalEnvironment nonempty-type-decl nil u_local_environment nil)
    (<< adt-def-decl "(strict_well_founded?[FPAExpr])" expressions nil)
    (strict_well_founded? const-decl "bool" orders nil)
    (fpVarIndex const-decl "nat" expressions_semantics nil)
    (applyFun_fp formal-const-decl
     "[[Operator, FloatingPointNumber, FloatingPointNumber] ->
   FloatingPointNumber]" semantics nil)
    (lt_fp formal-const-decl
     "(strict_total_order?[FloatingPointNumber])" semantics nil)
    (applyFun_r formal-const-decl
     "[[Operator, RealNumber, RealNumber] -> RealNumber]" semantics
     nil)
    (lt_r formal-const-decl "(strict_total_order?[RealNumber])"
     semantics nil)
    (strict_total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (FPVariable? adt-recognizer-decl "[FPAExpr -> boolean]" expressions
     nil)
    (FPAExpr type-decl nil expressions nil)
    (FtoR formal-const-decl "[FloatingPointNumber -> RealNumber]"
     semantics nil)
    (FloatingPointNumber formal-nonempty-type-decl nil semantics nil)
    (RealNumber formal-nonempty-type-decl nil semantics nil)
    (Operator formal-nonempty-type-decl nil semantics nil)
    (bounded_by? const-decl "bool" u_local_environment nil)
    (expandLocalDefs def-decl "{res: FPAExpr |
         NoLocalVars?(res) AND
          (FORALL (fpParamEnv, fpLocalEnv2):
             eval(fpParamEnv, fpLocalEnv)(expr) =
              eval(fpParamEnv, fpLocalEnv2)(res))
           AND eld_post_eval_ftor(fpLocalEnv, expr, res)}" semantics
     nil)
    (eld_post_eval_ftor const-decl "bool" semantics nil)
    (eval def-decl "FPNumber" expressions_semantics nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (FPEnvironment nonempty-type-eq-decl nil expressions_semantics nil)
    (FPNumber nonempty-type-eq-decl nil expressions nil)
    (ParameterIndex nonempty-type-eq-decl nil expressions nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (NoLocalVars? const-decl "bool" expressions nil)
    (no_local_vars_evaluable_in formula-decl nil expressions_semantics
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil))
 (expandLocalDefs_eval 0
  (expandLocalDefs_eval-2 nil 3756632014
   ("" (skeep :preds? t)
    (("" (invoke (typepred "%1") (! 1 2 1)) (("" (inst? -2) nil nil))
      nil))
    nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (Operator formal-nonempty-type-decl nil semantics nil)
    (RealNumber formal-nonempty-type-decl nil semantics nil)
    (FloatingPointNumber formal-nonempty-type-decl nil semantics nil)
    (FtoR formal-const-decl "[FloatingPointNumber -> RealNumber]"
     semantics nil)
    (FPAExpr type-decl nil expressions nil)
    (NoLocalVars? const-decl "bool" expressions nil)
    (FPVariable? adt-recognizer-decl "[FPAExpr -> boolean]" expressions
     nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (pred type-eq-decl nil defined_types nil)
    (strict_total_order? const-decl "bool" orders nil)
    (lt_r formal-const-decl "(strict_total_order?[RealNumber])"
     semantics nil)
    (applyFun_r formal-const-decl
     "[[Operator, RealNumber, RealNumber] -> RealNumber]" semantics
     nil)
    (lt_fp formal-const-decl
     "(strict_total_order?[FloatingPointNumber])" semantics nil)
    (applyFun_fp formal-const-decl
     "[[Operator, FloatingPointNumber, FloatingPointNumber] ->
   FloatingPointNumber]" semantics nil)
    (fpVarIndex const-decl "nat" expressions_semantics nil)
    (strict_well_founded? const-decl "bool" orders nil)
    (<< adt-def-decl "(strict_well_founded?[FPAExpr])" expressions nil)
    (LocalEnvironment nonempty-type-decl nil u_local_environment nil)
    (FPLocalEnvironment type-eq-decl nil expressions_semantics nil)
    (bounded_by? const-decl "bool" u_local_environment nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (ParameterIndex nonempty-type-eq-decl nil expressions nil)
    (FPNumber nonempty-type-eq-decl nil expressions nil)
    (FPEnvironment nonempty-type-eq-decl nil expressions_semantics nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (eval def-decl "FPNumber" expressions_semantics nil)
    (eld_post_eval_ftor const-decl "bool" semantics nil)
    (expandLocalDefs def-decl "{res: FPAExpr |
         NoLocalVars?(res) AND
          (FORALL (fpParamEnv, fpLocalEnv2):
             eval(fpParamEnv, fpLocalEnv)(expr) =
              eval(fpParamEnv, fpLocalEnv2)(res))
           AND eld_post_eval_ftor(fpLocalEnv, expr, res)}" semantics
     nil))
   nil)
  (expandLocalDefs_eval-1 nil 3756581883
   ("" (skeep :but "expr")
    (("" (induct "expr")
      (("1" (grind) nil nil) ("2" (grind) nil nil)
       ("3" (skolem 1 "idx")
        (("3" (flatten)
          (("3" (expand "expandLocalDefs")
            (("3" (expand "eval" 1 1) (("3" (postpone) nil nil)) nil))
            nil))
          nil))
        nil)
       ("4" (postpone) nil nil) ("5" (postpone) nil nil)
       ("6" (postpone) nil nil))
      nil))
    nil)
   nil shostak))
 (expandLocalDefs_eval_ftor_TCC1 0
  (expandLocalDefs_eval_ftor_TCC1-1 nil 3756579547
   ("" (skeep* :preds? t)
    (("" (use "evaluable_in_expr_FtoR") (("" (assert) nil nil)) nil))
    nil)
   ((evaluable_in_expr_FtoR formula-decl nil expressions_semantics nil)
    (Operator formal-nonempty-type-decl nil semantics nil)
    (RealNumber formal-nonempty-type-decl nil semantics nil)
    (pred type-eq-decl nil defined_types nil)
    (strict_total_order? const-decl "bool" orders nil)
    (lt_r formal-const-decl "(strict_total_order?[RealNumber])"
     semantics nil)
    (applyFun_r formal-const-decl
     "[[Operator, RealNumber, RealNumber] -> RealNumber]" semantics
     nil)
    (FloatingPointNumber formal-nonempty-type-decl nil semantics nil)
    (lt_fp formal-const-decl
     "(strict_total_order?[FloatingPointNumber])" semantics nil)
    (applyFun_fp formal-const-decl
     "[[Operator, FloatingPointNumber, FloatingPointNumber] ->
   FloatingPointNumber]" semantics nil)
    (FtoR formal-const-decl "[FloatingPointNumber -> RealNumber]"
     semantics nil)
    (bounded_by? const-decl "bool" u_local_environment nil)
    (FtoR const-decl "{rle: RLocalEnvironment |
         size(fle) = size(rle) AND
          (FORALL (i: below(size(rle))): get(rle)(i) = FtoR(get(fle)(i)))}"
     expressions_semantics nil)
    (FtoR def-decl "RAExpr" expressions nil)
    (get const-decl "T" u_local_environment nil)
    (below type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (size const-decl "nat" u_local_environment nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (FPLocalEnvironment type-eq-decl nil expressions_semantics nil)
    (<< adt-def-decl "(strict_well_founded?[FPAExpr])" expressions nil)
    (fpVarIndex const-decl "nat" expressions_semantics nil)
    (FPVariable? adt-recognizer-decl "[FPAExpr -> boolean]" expressions
     nil)
    (FPAExpr type-decl nil expressions nil)
    (RLocalEnvironment type-eq-decl nil expressions_semantics nil)
    (LocalEnvironment nonempty-type-decl nil u_local_environment nil)
    (<< adt-def-decl "(strict_well_founded?[RAExpr])" expressions nil)
    (strict_well_founded? const-decl "bool" orders nil)
    (rVarIndex const-decl "nat" expressions_semantics nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (RVariable? adt-recognizer-decl "[RAExpr -> boolean]" expressions
     nil)
    (RAExpr type-decl nil expressions nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil))
 (expandLocalDefs_eval_ftor_TCC2 0
  (expandLocalDefs_eval_ftor_TCC2-1 nil 3756579547
   ("" (skeep* :preds? t)
    (("" (use "expandLocalDefs_no_local_vars")
      (("" (lemma "no_local_vars_evaluable_in")
        ((""
          (inst -1 "fpLocalEnv2" "expandLocalDefs(fpLocalEnv, expr)")
          (("" (use "evaluable_in_expr_FtoR") (("" (assert) nil nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((expandLocalDefs_no_local_vars formula-decl nil semantics nil)
    (FPLocalEnvironment type-eq-decl nil expressions_semantics nil)
    (LocalEnvironment nonempty-type-decl nil u_local_environment nil)
    (<< adt-def-decl "(strict_well_founded?[FPAExpr])" expressions nil)
    (strict_well_founded? const-decl "bool" orders nil)
    (fpVarIndex const-decl "nat" expressions_semantics nil)
    (applyFun_fp formal-const-decl
     "[[Operator, FloatingPointNumber, FloatingPointNumber] ->
   FloatingPointNumber]" semantics nil)
    (lt_fp formal-const-decl
     "(strict_total_order?[FloatingPointNumber])" semantics nil)
    (applyFun_r formal-const-decl
     "[[Operator, RealNumber, RealNumber] -> RealNumber]" semantics
     nil)
    (lt_r formal-const-decl "(strict_total_order?[RealNumber])"
     semantics nil)
    (strict_total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (FPVariable? adt-recognizer-decl "[FPAExpr -> boolean]" expressions
     nil)
    (FPAExpr type-decl nil expressions nil)
    (FtoR formal-const-decl "[FloatingPointNumber -> RealNumber]"
     semantics nil)
    (FloatingPointNumber formal-nonempty-type-decl nil semantics nil)
    (RealNumber formal-nonempty-type-decl nil semantics nil)
    (Operator formal-nonempty-type-decl nil semantics nil)
    (bounded_by? const-decl "bool" u_local_environment nil)
    (NoLocalVars? const-decl "bool" expressions nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (ParameterIndex nonempty-type-eq-decl nil expressions nil)
    (FPNumber nonempty-type-eq-decl nil expressions nil)
    (FPEnvironment nonempty-type-eq-decl nil expressions_semantics nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (eval def-decl "FPNumber" expressions_semantics nil)
    (eld_post_eval_ftor const-decl "bool" semantics nil)
    (expandLocalDefs def-decl "{res: FPAExpr |
         NoLocalVars?(res) AND
          (FORALL (fpParamEnv, fpLocalEnv2):
             eval(fpParamEnv, fpLocalEnv)(expr) =
              eval(fpParamEnv, fpLocalEnv2)(res))
           AND eld_post_eval_ftor(fpLocalEnv, expr, res)}" semantics
     nil)
    (RAExpr type-decl nil expressions nil)
    (RVariable? adt-recognizer-decl "[RAExpr -> boolean]" expressions
     nil)
    (rVarIndex const-decl "nat" expressions_semantics nil)
    (<< adt-def-decl "(strict_well_founded?[RAExpr])" expressions nil)
    (RLocalEnvironment type-eq-decl nil expressions_semantics nil)
    (size const-decl "nat" u_local_environment nil)
    (< const-decl "bool" reals nil)
    (below type-eq-decl nil naturalnumbers nil)
    (get const-decl "T" u_local_environment nil)
    (FtoR def-decl "RAExpr" expressions nil)
    (FtoR const-decl "{rle: RLocalEnvironment |
         size(fle) = size(rle) AND
          (FORALL (i: below(size(rle))): get(rle)(i) = FtoR(get(fle)(i)))}"
     expressions_semantics nil)
    (evaluable_in_expr_FtoR formula-decl nil expressions_semantics nil)
    (no_local_vars_evaluable_in formula-decl nil expressions_semantics
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil))
 (expandLocalDefs_eval_ftor 0
  (expandLocalDefs_eval_ftor-1 nil 3756636142
   ("" (skeep :preds? t)
    (("" (invoke (typepred "%1") (! 1 2 1 1))
      (("" (expand "eld_post_eval_ftor") (("" (inst? -3) nil nil))
        nil))
      nil))
    nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (Operator formal-nonempty-type-decl nil semantics nil)
    (RealNumber formal-nonempty-type-decl nil semantics nil)
    (FloatingPointNumber formal-nonempty-type-decl nil semantics nil)
    (FtoR formal-const-decl "[FloatingPointNumber -> RealNumber]"
     semantics nil)
    (FPAExpr type-decl nil expressions nil)
    (NoLocalVars? const-decl "bool" expressions nil)
    (FPVariable? adt-recognizer-decl "[FPAExpr -> boolean]" expressions
     nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (pred type-eq-decl nil defined_types nil)
    (strict_total_order? const-decl "bool" orders nil)
    (lt_r formal-const-decl "(strict_total_order?[RealNumber])"
     semantics nil)
    (applyFun_r formal-const-decl
     "[[Operator, RealNumber, RealNumber] -> RealNumber]" semantics
     nil)
    (lt_fp formal-const-decl
     "(strict_total_order?[FloatingPointNumber])" semantics nil)
    (applyFun_fp formal-const-decl
     "[[Operator, FloatingPointNumber, FloatingPointNumber] ->
   FloatingPointNumber]" semantics nil)
    (fpVarIndex const-decl "nat" expressions_semantics nil)
    (strict_well_founded? const-decl "bool" orders nil)
    (<< adt-def-decl "(strict_well_founded?[FPAExpr])" expressions nil)
    (LocalEnvironment nonempty-type-decl nil u_local_environment nil)
    (FPLocalEnvironment type-eq-decl nil expressions_semantics nil)
    (bounded_by? const-decl "bool" u_local_environment nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (ParameterIndex nonempty-type-eq-decl nil expressions nil)
    (FPNumber nonempty-type-eq-decl nil expressions nil)
    (FPEnvironment nonempty-type-eq-decl nil expressions_semantics nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (eval def-decl "FPNumber" expressions_semantics nil)
    (eld_post_eval_ftor const-decl "bool" semantics nil)
    (expandLocalDefs def-decl "{res: FPAExpr |
         NoLocalVars?(res) AND
          (FORALL (fpParamEnv, fpLocalEnv2):
             eval(fpParamEnv, fpLocalEnv)(expr) =
              eval(fpParamEnv, fpLocalEnv2)(res))
           AND eld_post_eval_ftor(fpLocalEnv, expr, res)}" semantics
     nil))
   shostak))
 (replace_local_var_TCC7 0
  (replace_local_var_TCC7-1 nil 3754217098
   ("" (termination-tcc) nil nil)
   ((FtoR formal-const-decl "[FloatingPointNumber -> RealNumber]"
     semantics nil)
    (FloatingPointNumber formal-nonempty-type-decl nil semantics nil)
    (RealNumber formal-nonempty-type-decl nil semantics nil)
    (Operator formal-nonempty-type-decl nil semantics nil)
    (<< adt-def-decl "(strict_well_founded?[FPBExpr])" expressions
     nil))
   nil))
 (replace_local_var_TCC8 0
  (replace_local_var_TCC8-1 nil 3754217098
   ("" (termination-tcc) nil nil)
   ((FtoR formal-const-decl "[FloatingPointNumber -> RealNumber]"
     semantics nil)
    (FloatingPointNumber formal-nonempty-type-decl nil semantics nil)
    (RealNumber formal-nonempty-type-decl nil semantics nil)
    (Operator formal-nonempty-type-decl nil semantics nil)
    (<< adt-def-decl "(strict_well_founded?[FPBExpr])" expressions
     nil))
   nil))
 (replace_local_var_TCC9 0
  (replace_local_var_TCC9-1 nil 3754217098
   ("" (termination-tcc) nil nil)
   ((FtoR formal-const-decl "[FloatingPointNumber -> RealNumber]"
     semantics nil)
    (FloatingPointNumber formal-nonempty-type-decl nil semantics nil)
    (RealNumber formal-nonempty-type-decl nil semantics nil)
    (Operator formal-nonempty-type-decl nil semantics nil)
    (<< adt-def-decl "(strict_well_founded?[FPBExpr])" expressions
     nil))
   nil))
 (replace_local_var_TCC10 0
  (replace_local_var_TCC10-1 nil 3754217098
   ("" (termination-tcc) nil nil)
   ((FtoR formal-const-decl "[FloatingPointNumber -> RealNumber]"
     semantics nil)
    (FloatingPointNumber formal-nonempty-type-decl nil semantics nil)
    (RealNumber formal-nonempty-type-decl nil semantics nil)
    (Operator formal-nonempty-type-decl nil semantics nil)
    (<< adt-def-decl "(strict_well_founded?[RBExpr])" expressions nil))
   nil))
 (replace_local_var_TCC11 0
  (replace_local_var_TCC11-1 nil 3754324205
   ("" (termination-tcc) nil nil)
   ((FtoR formal-const-decl "[FloatingPointNumber -> RealNumber]"
     semantics nil)
    (FloatingPointNumber formal-nonempty-type-decl nil semantics nil)
    (RealNumber formal-nonempty-type-decl nil semantics nil)
    (Operator formal-nonempty-type-decl nil semantics nil)
    (<< adt-def-decl "(strict_well_founded?[RBExpr])" expressions nil))
   nil))
 (replace_local_var_TCC12 0
  (replace_local_var_TCC12-1 nil 3754324205
   ("" (termination-tcc) nil nil)
   ((FtoR formal-const-decl "[FloatingPointNumber -> RealNumber]"
     semantics nil)
    (FloatingPointNumber formal-nonempty-type-decl nil semantics nil)
    (RealNumber formal-nonempty-type-decl nil semantics nil)
    (Operator formal-nonempty-type-decl nil semantics nil)
    (<< adt-def-decl "(strict_well_founded?[RBExpr])" expressions nil))
   nil))
 (replace_local_var_in_fpform_evaluable_in 0
  (replace_local_var_in_fpform_evaluable_in-1 nil 3753966381
   ("" (skeep :but "form")
    (("" (induct "form")
      (("1" (grind) nil nil) ("2" (grind) nil nil)
       ("3" (skolem 1 "form")
        (("3" (flatten)
          (("3" (expand "replace_local_var" 1)
            (("3" (use "evaluable_in_not")
              (("3" (replace -1 :hide? t)
                (("3" (lemma "evaluable_in_not")
                  (("3" (inst? -1 :where 1)
                    (("1" (replace -1 :hide? t)
                      (("1" (propax) nil nil)) nil)
                     ("2" (grind) nil nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("4" (skolem 1 ("form1" "form2"))
        (("4" (flatten)
          (("4" (use "evaluable_in_and")
            (("4" (replace -1 :hide? t)
              (("4" (expand "replace_local_var" 1)
                (("4" (lemma "evaluable_in_and")
                  (("4" (inst? -1 :where 1)
                    (("1" (replace -1 :hide? t)
                      (("1" (assert) (("1" (grind) nil nil)) nil)) nil)
                     ("2" (grind) nil nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("5" (skolem 1 ("expr1" "expr2"))
        (("5" (use "evaluable_in_lt")
          (("5" (replace -1 :hide? t)
            (("5" (expand "replace_local_var" 1)
              (("5" (lemma "evaluable_in_lt")
                (("5" (inst? -1 :where 1)
                  (("1" (replace -1 :hide? t)
                    (("1"
                      (use "replace_local_var_in_fpexpr_evaluable_in")
                      (("1"
                        (lemma
                         "replace_local_var_in_fpexpr_evaluable_in")
                        (("1" (inst -1 "expr2" "fpLocalEnv" "aexpr")
                          (("1" (assert) (("1" (grind) nil nil)) nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("2" (grind) nil nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("6" (grind) nil nil))
      nil))
    nil)
   ((FPBExpr type-decl nil expressions nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (FPAExpr type-decl nil expressions nil)
    (FPVariable? adt-recognizer-decl "[FPAExpr -> boolean]" expressions
     nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (pred type-eq-decl nil defined_types nil)
    (strict_total_order? const-decl "bool" orders nil)
    (lt_r formal-const-decl "(strict_total_order?[RealNumber])"
     semantics nil)
    (applyFun_r formal-const-decl
     "[[Operator, RealNumber, RealNumber] -> RealNumber]" semantics
     nil)
    (lt_fp formal-const-decl
     "(strict_total_order?[FloatingPointNumber])" semantics nil)
    (applyFun_fp formal-const-decl
     "[[Operator, FloatingPointNumber, FloatingPointNumber] ->
   FloatingPointNumber]" semantics nil)
    (fpVarIndex const-decl "nat" expressions_semantics nil)
    (strict_well_founded? const-decl "bool" orders nil)
    (<< adt-def-decl "(strict_well_founded?[FPAExpr])" expressions nil)
    (LocalEnvironment nonempty-type-decl nil u_local_environment nil)
    (FPLocalEnvironment type-eq-decl nil expressions_semantics nil)
    (bounded_by? def-decl "bool" expressions_semantics nil)
    (bounded_by? const-decl "bool" u_local_environment nil)
    (cons const-decl "LocalEnvironment" u_local_environment nil)
    (replace_local_var def-decl "FPBExpr" semantics nil)
    (FtoR formal-const-decl "[FloatingPointNumber -> RealNumber]"
     semantics nil)
    (FloatingPointNumber formal-nonempty-type-decl nil semantics nil)
    (RealNumber formal-nonempty-type-decl nil semantics nil)
    (Operator formal-nonempty-type-decl nil semantics nil)
    (FPBExpr_induction formula-decl nil expressions nil)
    (evaluable_in_not formula-decl nil expressions_semantics nil)
    (evaluable_in_and formula-decl nil expressions_semantics nil)
    (evaluable_in_lt formula-decl nil expressions_semantics nil)
    (replace_local_var def-decl "FPAExpr" semantics nil)
    (replace_local_var_in_fpexpr_evaluable_in formula-decl nil
     semantics nil))
   shostak))
 (replace_local_var_in_rform_evaluable_in 0
  (replace_local_var_in_rform_evaluable_in-1 nil 3754223710
   ("" (skeep :but "form")
    (("" (induct "form")
      (("1" (grind) nil nil) ("2" (grind) nil nil)
       ("3" (skolem 1 "form")
        (("3" (flatten)
          (("3" (expand "replace_local_var" 1)
            (("3" (use "evaluable_in_r_not")
              (("3" (replace -1 :hide? t)
                (("3" (lemma "evaluable_in_r_not")
                  (("3" (inst? -1 :where 1)
                    (("3" (replace -1 :hide? t)
                      (("3" (propax) nil nil)) nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("4" (skolem 1 ("form1" "form2"))
        (("4" (flatten)
          (("4" (use "evaluable_in_r_and")
            (("4" (replace -1 :hide? t)
              (("4" (expand "replace_local_var" 1)
                (("4" (lemma "evaluable_in_r_and")
                  (("4" (inst? -1 :where 1)
                    (("4" (replace -1 :hide? t)
                      (("4" (assert) (("4" (grind) nil nil)) nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("5" (skolem 1 ("expr1" "expr2"))
        (("5" (use "evaluable_in_r_lt")
          (("5" (replace -1 :hide? t)
            (("5" (expand "replace_local_var" 1)
              (("5" (lemma "evaluable_in_r_lt")
                (("5" (inst? -1 :where 1)
                  (("5" (replace -1 :hide? t)
                    (("5"
                      (use "replace_local_var_in_rexpr_evaluable_in")
                      (("5"
                        (lemma
                         "replace_local_var_in_rexpr_evaluable_in")
                        (("5" (inst -1 "expr2" "rLocalEnv" "aexpr")
                          (("5" (assert) (("5" (grind) nil nil)) nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((RBExpr type-decl nil expressions nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (RAExpr type-decl nil expressions nil)
    (RVariable? adt-recognizer-decl "[RAExpr -> boolean]" expressions
     nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (pred type-eq-decl nil defined_types nil)
    (strict_total_order? const-decl "bool" orders nil)
    (lt_r formal-const-decl "(strict_total_order?[RealNumber])"
     semantics nil)
    (applyFun_r formal-const-decl
     "[[Operator, RealNumber, RealNumber] -> RealNumber]" semantics
     nil)
    (lt_fp formal-const-decl
     "(strict_total_order?[FloatingPointNumber])" semantics nil)
    (applyFun_fp formal-const-decl
     "[[Operator, FloatingPointNumber, FloatingPointNumber] ->
   FloatingPointNumber]" semantics nil)
    (rVarIndex const-decl "nat" expressions_semantics nil)
    (strict_well_founded? const-decl "bool" orders nil)
    (<< adt-def-decl "(strict_well_founded?[RAExpr])" expressions nil)
    (LocalEnvironment nonempty-type-decl nil u_local_environment nil)
    (RLocalEnvironment type-eq-decl nil expressions_semantics nil)
    (bounded_by? def-decl "bool" expressions_semantics nil)
    (bounded_by? const-decl "bool" u_local_environment nil)
    (cons const-decl "LocalEnvironment" u_local_environment nil)
    (FPAExpr type-decl nil expressions nil)
    (FtoR def-decl "RAExpr" expressions nil)
    (replace_local_var def-decl "RBExpr" semantics nil)
    (FtoR formal-const-decl "[FloatingPointNumber -> RealNumber]"
     semantics nil)
    (FloatingPointNumber formal-nonempty-type-decl nil semantics nil)
    (RealNumber formal-nonempty-type-decl nil semantics nil)
    (Operator formal-nonempty-type-decl nil semantics nil)
    (RBExpr_induction formula-decl nil expressions nil)
    (evaluable_in_r_not formula-decl nil expressions_semantics nil)
    (evaluable_in_r_and formula-decl nil expressions_semantics nil)
    (evaluable_in_r_lt formula-decl nil expressions_semantics nil)
    (replace_local_var def-decl "RAExpr" semantics nil)
    (replace_local_var_in_rexpr_evaluable_in formula-decl nil semantics
     nil))
   nil))
 (replace_local_var_in_fpform_val_TCC1 0
  (replace_local_var_in_fpform_val_TCC1-1 nil 3753959267
   ("" (skeep)
    (("" (use "replace_local_var_in_fpform_evaluable_in")
      (("" (assert) nil nil)) nil))
    nil)
   ((replace_local_var_in_fpform_evaluable_in formula-decl nil
     semantics nil)
    (cons const-decl "LocalEnvironment" u_local_environment nil)
    (bounded_by? const-decl "bool" u_local_environment nil)
    (bounded_by? def-decl "bool" expressions_semantics nil)
    (FPLocalEnvironment type-eq-decl nil expressions_semantics nil)
    (LocalEnvironment nonempty-type-decl nil u_local_environment nil)
    (<< adt-def-decl "(strict_well_founded?[FPAExpr])" expressions nil)
    (strict_well_founded? const-decl "bool" orders nil)
    (fpVarIndex const-decl "nat" expressions_semantics nil)
    (applyFun_fp formal-const-decl
     "[[Operator, FloatingPointNumber, FloatingPointNumber] ->
   FloatingPointNumber]" semantics nil)
    (lt_fp formal-const-decl
     "(strict_total_order?[FloatingPointNumber])" semantics nil)
    (applyFun_r formal-const-decl
     "[[Operator, RealNumber, RealNumber] -> RealNumber]" semantics
     nil)
    (lt_r formal-const-decl "(strict_total_order?[RealNumber])"
     semantics nil)
    (strict_total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (FPVariable? adt-recognizer-decl "[FPAExpr -> boolean]" expressions
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (FPAExpr type-decl nil expressions nil)
    (FPBExpr type-decl nil expressions nil)
    (FtoR formal-const-decl "[FloatingPointNumber -> RealNumber]"
     semantics nil)
    (FloatingPointNumber formal-nonempty-type-decl nil semantics nil)
    (RealNumber formal-nonempty-type-decl nil semantics nil)
    (Operator formal-nonempty-type-decl nil semantics nil))
   nil))
 (replace_local_var_in_fpform_val 0
  (replace_local_var_in_fpform_val-1 nil 3753984131
   ("" (skeep :but "form")
    (("" (induct "form")
      (("1" (grind) nil nil) ("2" (grind) nil nil)
       ("3" (flatten) (("3" (grind) nil nil)) nil)
       ("4" (skolem 1 "form")
        (("4" (flatten)
          (("4" (use "evaluable_in_not")
            (("4" (replace -1 :hide? t)
              (("4" (assert)
                (("4" (expand "replace_local_var" 1)
                  (("4" (grind) nil nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("5" (skolem 1 ("form1" "form2"))
        (("5" (flatten) (("5" (grind) nil nil)) nil)) nil)
       ("6" (skolem 1 ("expr1" "expr2"))
        (("6" (flatten)
          (("6" (expand "replace_local_var")
            (("6" (expand "val" 1)
              (("6" (use "replace_local_var_in_fpexpr_val")
                (("6" (replace -1 :hide? t)
                  (("6" (use "replace_local_var_in_fpexpr_val")
                    (("6" (replace -1 :hide? t)
                      (("6" (propax) nil nil)) nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("7" (skeep)
        (("7" (use "replace_local_var_in_fpform_evaluable_in")
          (("7" (assert) nil nil)) nil))
        nil)
       ("8" (grind) nil nil))
      nil))
    nil)
   ((replace_local_var def-decl "FPBExpr" semantics nil)
    (aexpr skolem-const-decl
     "{aexpr: FPAExpr | bounded_by?(fpLocalEnv)(aexpr)}" semantics nil)
    (fpLocalEnv skolem-const-decl "FPLocalEnvironment
    [Operator, RealNumber, lt_r, applyFun_r, FloatingPointNumber, lt_fp,
     applyFun_fp, FtoR]" semantics nil)
    (cons const-decl "LocalEnvironment" u_local_environment nil)
    (bounded_by? const-decl "bool" u_local_environment nil)
    (bounded_by? def-decl "bool" expressions_semantics nil)
    (FPLocalEnvironment type-eq-decl nil expressions_semantics nil)
    (LocalEnvironment nonempty-type-decl nil u_local_environment nil)
    (<< adt-def-decl "(strict_well_founded?[FPAExpr])" expressions nil)
    (strict_well_founded? const-decl "bool" orders nil)
    (fpVarIndex const-decl "nat" expressions_semantics nil)
    (applyFun_fp formal-const-decl
     "[[Operator, FloatingPointNumber, FloatingPointNumber] ->
   FloatingPointNumber]" semantics nil)
    (lt_fp formal-const-decl
     "(strict_total_order?[FloatingPointNumber])" semantics nil)
    (applyFun_r formal-const-decl
     "[[Operator, RealNumber, RealNumber] -> RealNumber]" semantics
     nil)
    (lt_r formal-const-decl "(strict_total_order?[RealNumber])"
     semantics nil)
    (strict_total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (FPVariable? adt-recognizer-decl "[FPAExpr -> boolean]" expressions
     nil)
    (FPAExpr type-decl nil expressions nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (FPBExpr type-decl nil expressions nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (ParameterIndex nonempty-type-eq-decl nil expressions nil)
    (FPNumber nonempty-type-eq-decl nil expressions nil)
    (FPEnvironment nonempty-type-eq-decl nil expressions_semantics nil)
    (FPEvaluableBExpr type-eq-decl nil expressions_semantics nil)
    (val def-decl "bool" expressions_semantics nil)
    (FtoR formal-const-decl "[FloatingPointNumber -> RealNumber]"
     semantics nil)
    (FloatingPointNumber formal-nonempty-type-decl nil semantics nil)
    (RealNumber formal-nonempty-type-decl nil semantics nil)
    (Operator formal-nonempty-type-decl nil semantics nil)
    (FPBExpr_induction formula-decl nil expressions nil)
    (evaluable_in_not formula-decl nil expressions_semantics nil)
    (replace_local_var_in_fpexpr_val formula-decl nil semantics nil)
    (replace_local_var_in_fpform_evaluable_in formula-decl nil
     semantics nil))
   shostak))
 (replace_local_var_in_rform_val_TCC1 0
  (replace_local_var_in_rform_val_TCC1-1 nil 3754217098
   ("" (skeep)
    (("" (use "replace_local_var_in_rform_evaluable_in")
      (("" (assert) nil nil)) nil))
    nil)
   ((replace_local_var_in_rform_evaluable_in formula-decl nil semantics
     nil)
    (cons const-decl "LocalEnvironment" u_local_environment nil)
    (bounded_by? def-decl "bool" expressions_semantics nil)
    (RBExpr type-decl nil expressions nil)
    (FtoR def-decl "RAExpr" expressions nil)
    (bounded_by? const-decl "bool" u_local_environment nil)
    (FPAExpr type-decl nil expressions nil)
    (RLocalEnvironment type-eq-decl nil expressions_semantics nil)
    (LocalEnvironment nonempty-type-decl nil u_local_environment nil)
    (<< adt-def-decl "(strict_well_founded?[RAExpr])" expressions nil)
    (strict_well_founded? const-decl "bool" orders nil)
    (rVarIndex const-decl "nat" expressions_semantics nil)
    (applyFun_fp formal-const-decl
     "[[Operator, FloatingPointNumber, FloatingPointNumber] ->
   FloatingPointNumber]" semantics nil)
    (lt_fp formal-const-decl
     "(strict_total_order?[FloatingPointNumber])" semantics nil)
    (applyFun_r formal-const-decl
     "[[Operator, RealNumber, RealNumber] -> RealNumber]" semantics
     nil)
    (lt_r formal-const-decl "(strict_total_order?[RealNumber])"
     semantics nil)
    (strict_total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (RVariable? adt-recognizer-decl "[RAExpr -> boolean]" expressions
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (RAExpr type-decl nil expressions nil)
    (FtoR formal-const-decl "[FloatingPointNumber -> RealNumber]"
     semantics nil)
    (FloatingPointNumber formal-nonempty-type-decl nil semantics nil)
    (RealNumber formal-nonempty-type-decl nil semantics nil)
    (Operator formal-nonempty-type-decl nil semantics nil))
   nil))
 (replace_local_var_in_rform_val 0
  (replace_local_var_in_rform_val-1 nil 3754225089
   ("" (skeep :but "form")
    (("" (induct "form")
      (("1" (grind) nil nil) ("2" (grind) nil nil)
       ("3" (flatten) (("3" (grind) nil nil)) nil)
       ("4" (skolem 1 "form")
        (("4" (flatten)
          (("4" (use "evaluable_in_r_not")
            (("4" (replace -1 :hide? t)
              (("4" (assert)
                (("4" (expand "replace_local_var" 1)
                  (("4" (grind) nil nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("5" (skolem 1 ("form1" "form2"))
        (("5" (flatten) (("5" (grind) nil nil)) nil)) nil)
       ("6" (skolem 1 ("expr1" "expr2"))
        (("6" (flatten)
          (("6" (expand "replace_local_var")
            (("6" (expand "val" 1)
              (("6" (use "replace_local_var_in_rexpr_val")
                (("6" (replace -1 :hide? t)
                  (("6" (use "replace_local_var_in_rexpr_val")
                    (("6" (replace -1 :hide? t)
                      (("6" (propax) nil nil)) nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("7" (skeep)
        (("7" (use "replace_local_var_in_rform_evaluable_in")
          (("7" (assert) nil nil)) nil))
        nil))
      nil))
    nil)
   ((replace_local_var def-decl "RBExpr" semantics nil)
    (aexpr skolem-const-decl
     "{aexpr: FPAExpr | bounded_by?(rLocalEnv)(FtoR(aexpr))}" semantics
     nil)
    (rLocalEnv skolem-const-decl "RLocalEnvironment
    [Operator, RealNumber, lt_r, applyFun_r, FloatingPointNumber, lt_fp,
     applyFun_fp, FtoR]" semantics nil)
    (FtoR def-decl "RAExpr" expressions nil)
    (FPAExpr type-decl nil expressions nil)
    (cons const-decl "LocalEnvironment" u_local_environment nil)
    (bounded_by? const-decl "bool" u_local_environment nil)
    (bounded_by? def-decl "bool" expressions_semantics nil)
    (RLocalEnvironment type-eq-decl nil expressions_semantics nil)
    (LocalEnvironment nonempty-type-decl nil u_local_environment nil)
    (<< adt-def-decl "(strict_well_founded?[RAExpr])" expressions nil)
    (strict_well_founded? const-decl "bool" orders nil)
    (rVarIndex const-decl "nat" expressions_semantics nil)
    (applyFun_fp formal-const-decl
     "[[Operator, FloatingPointNumber, FloatingPointNumber] ->
   FloatingPointNumber]" semantics nil)
    (lt_fp formal-const-decl
     "(strict_total_order?[FloatingPointNumber])" semantics nil)
    (applyFun_r formal-const-decl
     "[[Operator, RealNumber, RealNumber] -> RealNumber]" semantics
     nil)
    (lt_r formal-const-decl "(strict_total_order?[RealNumber])"
     semantics nil)
    (strict_total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (RVariable? adt-recognizer-decl "[RAExpr -> boolean]" expressions
     nil)
    (RAExpr type-decl nil expressions nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (RBExpr type-decl nil expressions nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (ParameterIndex nonempty-type-eq-decl nil expressions nil)
    (RNumber nonempty-type-eq-decl nil expressions nil)
    (REnvironment nonempty-type-eq-decl nil expressions_semantics nil)
    (REvaluableBExpr type-eq-decl nil expressions_semantics nil)
    (val def-decl "bool" expressions_semantics nil)
    (FtoR formal-const-decl "[FloatingPointNumber -> RealNumber]"
     semantics nil)
    (FloatingPointNumber formal-nonempty-type-decl nil semantics nil)
    (RealNumber formal-nonempty-type-decl nil semantics nil)
    (Operator formal-nonempty-type-decl nil semantics nil)
    (RBExpr_induction formula-decl nil expressions nil)
    (evaluable_in_r_not formula-decl nil expressions_semantics nil)
    (replace_local_var_in_rexpr_val formula-decl nil semantics nil)
    (replace_local_var_in_rform_evaluable_in formula-decl nil semantics
     nil))
   nil))
 (var_appears_in_replaced_form_dec_var_appears_in_orig_form 0
  (var_appears_in_replaced_form_dec_var_appears_in_orig_form-1 nil
   3754838529
   ("" (skeep :but "form")
    (("" (induct "form")
      (("1" (grind) nil nil) ("2" (grind) nil nil)
       ("3" (grind) nil nil) ("4" (grind) nil nil)
       ("5" (skolem 1 ("expr1_" "expr2_"))
        (("5" (flatten)
          (("5" (rewrite "appears?_form_int_def_lt")
            (("5" (expand "replace_local_var")
              (("5" (rewrite "appears?_form_int_def_lt")
                (("5" (flatten)
                  (("5" (split -1)
                    (("1"
                      (use "var_appears_in_replaced_expr_dec_var_appears_in_orig_expr")
                      (("1" (assert) nil nil)) nil)
                     ("2"
                      (use "var_appears_in_replaced_expr_dec_var_appears_in_orig_expr")
                      (("2" (assert) nil nil)) nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (FPBExpr type-decl nil expressions nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (FPAExpr type-decl nil expressions nil)
    (FPVariable? adt-recognizer-decl "[FPAExpr -> boolean]" expressions
     nil)
    (appears? const-decl "bool" expressions nil)
    (replace_local_var def-decl "FPBExpr" semantics nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (DeBruijnIndex nonempty-type-eq-decl nil expressions nil)
    (FPVariable adt-constructor-decl "[DeBruijnIndex -> (FPVariable?)]"
     expressions nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (appears? const-decl "bool" expressions nil)
    (FtoR formal-const-decl "[FloatingPointNumber -> RealNumber]"
     semantics nil)
    (FloatingPointNumber formal-nonempty-type-decl nil semantics nil)
    (RealNumber formal-nonempty-type-decl nil semantics nil)
    (Operator formal-nonempty-type-decl nil semantics nil)
    (FPBExpr_induction formula-decl nil expressions nil)
    (appearsFree? def-decl "bool" expressions nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (var_appears_in_replaced_expr_dec_var_appears_in_orig_expr
     formula-decl nil semantics nil)
    (replace_local_var def-decl "FPAExpr" semantics nil)
    (appears?_form_int_def_lt formula-decl nil expressions nil))
   shostak))
 (var_appears_in_replaced_rform_dec_var_appears_in_orig_rform 0
  (var_appears_in_replaced_rform_dec_var_appears_in_orig_rform-2 nil
   3755349594
   ("" (skeep :but "rform")
    (("" (induct "rform")
      (("1" (grind) nil nil) ("2" (grind) nil nil)
       ("3" (grind) nil nil) ("4" (grind) nil nil)
       ("5" (skolem 1 ("expr1_" "expr2_"))
        (("5" (flatten)
          (("5" (rewrite "appears?_rform_int_def_lt")
            (("5" (expand "replace_local_var")
              (("5" (rewrite "appears?_rform_int_def_lt")
                (("5" (flatten)
                  (("5" (split -1)
                    (("1"
                      (use "var_appears_in_replaced_rexpr_dec_var_appears_in_orig_rexpr")
                      (("1" (assert) nil nil)) nil)
                     ("2"
                      (use "var_appears_in_replaced_rexpr_dec_var_appears_in_orig_rexpr")
                      (("2" (assert) nil nil)) nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (RBExpr type-decl nil expressions nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (RAExpr type-decl nil expressions nil)
    (RVariable? adt-recognizer-decl "[RAExpr -> boolean]" expressions
     nil)
    (appears? const-decl "bool" expressions nil)
    (replace_local_var def-decl "RBExpr" semantics nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (DeBruijnIndex nonempty-type-eq-decl nil expressions nil)
    (RVariable adt-constructor-decl "[DeBruijnIndex -> (RVariable?)]"
     expressions nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (appears? const-decl "bool" expressions nil)
    (FtoR formal-const-decl "[FloatingPointNumber -> RealNumber]"
     semantics nil)
    (FloatingPointNumber formal-nonempty-type-decl nil semantics nil)
    (RealNumber formal-nonempty-type-decl nil semantics nil)
    (Operator formal-nonempty-type-decl nil semantics nil)
    (RBExpr_induction formula-decl nil expressions nil)
    (appearsFree? def-decl "bool" expressions nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (var_appears_in_replaced_rexpr_dec_var_appears_in_orig_rexpr
     formula-decl nil semantics nil)
    (replace_local_var def-decl "RAExpr" semantics nil)
    (appears?_rform_int_def_lt formula-decl nil expressions nil))
   nil)
  (var_appears_in_replaced_rform_dec_var_appears_in_orig_rform-1 nil
   3755349324
   ("" (skeep :but "rform")
    (("" (induct "rform")
      (("1" (grind) nil) ("2" (grind) nil) ("3" (grind) nil)
       ("4" (grind) nil)
       ("5" (skolem 1 ("expr1_" "expr2_"))
        (("5" (flatten)
          (("5" (rewrite "appears?_form_int_def_lt")
            (("5" (expand "replace_local_var")
              (("5" (rewrite "appears?_form_int_def_lt")
                (("5" (flatten)
                  (("5" (split -1)
                    (("1"
                      (use "var_appears_in_replaced_rexpr_dec_var_appears_in_orig_rexpr")
                      (("1" (assert) nil)))
                     ("2"
                      (use "var_appears_in_replaced_rexpr_dec_var_appears_in_orig_rexpr")
                      (("2" (assert) nil))))))))))))))))))))
    nil)
   nil nil))
 (var_appears_in_replaced_fpconds_dec_var_appears_in_orig_fpconds 0
  (var_appears_in_replaced_fpconds_dec_var_appears_in_orig_fpconds-1
   nil 3755345621
   ("" (skeep)
    (("" (expand "replace_local_var_in_ceb")
      ((""
        (use "var_appears_in_replaced_form_dec_var_appears_in_orig_form")
        (("" (assert) nil nil)) nil))
      nil))
    nil)
   ((replace_local_var_in_ceb const-decl "CEB" semantics nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (Operator formal-nonempty-type-decl nil semantics nil)
    (RealNumber formal-nonempty-type-decl nil semantics nil)
    (FloatingPointNumber formal-nonempty-type-decl nil semantics nil)
    (FtoR formal-const-decl "[FloatingPointNumber -> RealNumber]"
     semantics nil)
    (FPAExpr type-decl nil expressions nil)
    (FPBExpr type-decl nil expressions nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (pred type-eq-decl nil defined_types nil)
    (strict_total_order? const-decl "bool" orders nil)
    (lt_r formal-const-decl "(strict_total_order?[RealNumber])"
     semantics nil)
    (applyFun_r formal-const-decl
     "[[Operator, RealNumber, RealNumber] -> RealNumber]" semantics
     nil)
    (lt_fp formal-const-decl
     "(strict_total_order?[FloatingPointNumber])" semantics nil)
    (applyFun_fp formal-const-decl
     "[[Operator, FloatingPointNumber, FloatingPointNumber] ->
   FloatingPointNumber]" semantics nil)
    (FPAExprDomain type-decl nil domain nil)
    (RBExpr type-decl nil expressions nil)
    (RAExprDomain type-decl nil domain nil)
    (CEB type-eq-decl nil domain nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (DeBruijnIndex nonempty-type-eq-decl nil expressions nil)
    (var_appears_in_replaced_form_dec_var_appears_in_orig_form
     formula-decl nil semantics nil))
   shostak))
 (var_appears_in_replaced_rconds_dec_var_appears_in_orig_rconds 0
  (var_appears_in_replaced_rconds_dec_var_appears_in_orig_rconds-2 nil
   3755346926
   ("" (skeep)
    (("" (expand "replace_local_var_in_ceb")
      (("" (expand "FtoR" 1)
        (("" (expand "FtoR" -1 2)
          ((""
            (use "var_appears_in_replaced_rform_dec_var_appears_in_orig_rform")
            (("" (assert)
              (("" (use "appears?_expr_rexpr")
                (("" (assert)
                  (("" (expand "FtoR") (("" (propax) nil nil)) nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((replace_local_var_in_ceb const-decl "CEB" semantics nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (ftor_fpvar_rvar_j application-judgement "(RVariable?)" semantics
     nil)
    (FPVariable adt-constructor-decl "[DeBruijnIndex -> (FPVariable?)]"
     expressions nil)
    (FPVariable? adt-recognizer-decl "[FPAExpr -> boolean]" expressions
     nil)
    (appears?_expr_rexpr formula-decl nil expressions nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (Operator formal-nonempty-type-decl nil semantics nil)
    (RealNumber formal-nonempty-type-decl nil semantics nil)
    (FloatingPointNumber formal-nonempty-type-decl nil semantics nil)
    (FtoR formal-const-decl "[FloatingPointNumber -> RealNumber]"
     semantics nil)
    (DeBruijnIndex nonempty-type-eq-decl nil expressions nil)
    (RAExpr type-decl nil expressions nil)
    (FPAExpr type-decl nil expressions nil)
    (RBExpr type-decl nil expressions nil)
    (FPBExpr type-decl nil expressions nil)
    (pred type-eq-decl nil defined_types nil)
    (strict_total_order? const-decl "bool" orders nil)
    (lt_r formal-const-decl "(strict_total_order?[RealNumber])"
     semantics nil)
    (applyFun_r formal-const-decl
     "[[Operator, RealNumber, RealNumber] -> RealNumber]" semantics
     nil)
    (lt_fp formal-const-decl
     "(strict_total_order?[FloatingPointNumber])" semantics nil)
    (applyFun_fp formal-const-decl
     "[[Operator, FloatingPointNumber, FloatingPointNumber] ->
   FloatingPointNumber]" semantics nil)
    (FPAExprDomain type-decl nil domain nil)
    (RAExprDomain type-decl nil domain nil)
    (CEB type-eq-decl nil domain nil)
    (var_appears_in_replaced_rform_dec_var_appears_in_orig_rform
     formula-decl nil semantics nil)
    (FtoR def-decl "RAExpr" expressions nil))
   nil)
  (var_appears_in_replaced_rconds_dec_var_appears_in_orig_rconds-1 nil
   3755345756
   ("" (skeep)
    (("" (expand "replace_local_var_in_ceb")
      ((""
        (use "var_appears_in_replaced_form_dec_var_appears_in_orig_form")
        (("" (assert) nil))))))
    nil)
   nil nil))
 (max_local_index_form_replaced_var 0
  (max_local_index_form_replaced_var-1 nil 3753549740
   ("" (skeep :but "form")
    (("" (induct "form")
      (("1" (grind) nil nil) ("2" (grind) nil nil)
       ("3" (grind) nil nil) ("4" (grind) nil nil)
       ("5" (skolem 1 ("a1" "a2"))
        (("5" (expand "replace_local_var")
          (("5" (rewrite "max_local_index_stmt_lt_def")
            (("5" (use "max_local_index_expr_replaced_var")
              (("5" (lemma "max_local_index_expr_replaced_var")
                (("5" (inst -1 "a2" "expr") (("5" (grind) nil nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((FPBExpr type-decl nil expressions nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (<= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (upfrom nonempty-type-eq-decl nil integers nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (FPAExpr type-decl nil expressions nil)
    (FPVariable? adt-recognizer-decl "[FPAExpr -> boolean]" expressions
     nil)
    (appears? const-decl "bool" expressions nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (FPParameter? adt-recognizer-decl "[FPAExpr -> boolean]"
     expressions nil)
    (DeBruijnIndex nonempty-type-eq-decl nil expressions nil)
    (index shared-adt-accessor-decl
           "[{x: FPAExpr | FPVariable?(x) OR FPParameter?(x)} -> DeBruijnIndex]"
           expressions nil)
    (maxFreeLocalIndex def-decl "{max: upfrom(-1) |
         IF EXISTS (local: (FPVariable?)): appears?(form)(local)
           THEN (EXISTS (local: (FPVariable?) | appears?(form)(local)):
                   index(local) = max)
                 AND
                 (FORALL (local: (FPVariable?) | appears?(form)(local)):
                    index(local) <= max)
         ELSE max = -1
         ENDIF}" expressions nil)
    (replace_local_var def-decl "FPBExpr" semantics nil)
    (max const-decl "{p: real | p >= m AND p >= n}" real_defs nil)
    (subterm adt-def-decl "boolean" expressions nil)
    (maxFreeLocalIndex def-decl "{maxInd: upfrom(-1) |
         IF EXISTS (local: (FPVariable?)): subterm(local, expr)
           THEN (EXISTS (local: (FPVariable?) | subterm(local, expr)):
                   index(local) = maxInd)
                 AND
                 (FORALL (local: (FPVariable?) | subterm(local, expr)):
                    index(local) <= maxInd)
         ELSE maxInd = -1
         ENDIF}" expressions nil)
    (FtoR formal-const-decl "[FloatingPointNumber -> RealNumber]"
     semantics nil)
    (FloatingPointNumber formal-nonempty-type-decl nil semantics nil)
    (RealNumber formal-nonempty-type-decl nil semantics nil)
    (Operator formal-nonempty-type-decl nil semantics nil)
    (FPBExpr_induction formula-decl nil expressions nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (minus_odd_is_odd application-judgement "odd_int" integers nil)
    (int_max application-judgement "{k: int | i <= k AND j <= k}"
     real_defs nil)
    (rat_max application-judgement "{s: rat | s >= q AND s >= r}"
     real_defs nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (max_local_index_expr_replaced_var formula-decl nil semantics nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (max_local_index_stmt_lt_def formula-decl nil expressions nil)
    (replace_local_var def-decl "FPAExpr" semantics nil))
   shostak))
 (max_local_index_fpconds_replaced_var_ceb 0
  (max_local_index_fpconds_replaced_var_ceb-1 nil 3753548253
   ("" (expand "replace_local_var_in_ceb")
    (("" (skeep)
      (("" (rewrite "max_local_index_form_replaced_var") nil nil))
      nil))
    nil)
   ((CEB type-eq-decl nil domain nil)
    (RAExprDomain type-decl nil domain nil)
    (RBExpr type-decl nil expressions nil)
    (FPAExprDomain type-decl nil domain nil)
    (applyFun_fp formal-const-decl
     "[[Operator, FloatingPointNumber, FloatingPointNumber] ->
   FloatingPointNumber]" semantics nil)
    (lt_fp formal-const-decl
     "(strict_total_order?[FloatingPointNumber])" semantics nil)
    (applyFun_r formal-const-decl
     "[[Operator, RealNumber, RealNumber] -> RealNumber]" semantics
     nil)
    (lt_r formal-const-decl "(strict_total_order?[RealNumber])"
     semantics nil)
    (strict_total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (FPBExpr type-decl nil expressions nil)
    (FPAExpr type-decl nil expressions nil)
    (FtoR formal-const-decl "[FloatingPointNumber -> RealNumber]"
     semantics nil)
    (FloatingPointNumber formal-nonempty-type-decl nil semantics nil)
    (RealNumber formal-nonempty-type-decl nil semantics nil)
    (Operator formal-nonempty-type-decl nil semantics nil)
    (max_local_index_form_replaced_var formula-decl nil semantics nil)
    (replace_local_var_in_ceb const-decl "CEB" semantics nil))
   shostak))
 (unreplaced_var_ceb_in_dom 0
  (unreplaced_var_ceb_in_dom-1 nil 3753526988 ("" (grind) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (Operator formal-nonempty-type-decl nil semantics nil)
    (RealNumber formal-nonempty-type-decl nil semantics nil)
    (FloatingPointNumber formal-nonempty-type-decl nil semantics nil)
    (FtoR formal-const-decl "[FloatingPointNumber -> RealNumber]"
     semantics nil)
    (FPBExpr type-decl nil expressions nil)
    (pred type-eq-decl nil defined_types nil)
    (strict_total_order? const-decl "bool" orders nil)
    (lt_r formal-const-decl "(strict_total_order?[RealNumber])"
     semantics nil)
    (applyFun_r formal-const-decl
     "[[Operator, RealNumber, RealNumber] -> RealNumber]" semantics
     nil)
    (lt_fp formal-const-decl
     "(strict_total_order?[FloatingPointNumber])" semantics nil)
    (applyFun_fp formal-const-decl
     "[[Operator, FloatingPointNumber, FloatingPointNumber] ->
   FloatingPointNumber]" semantics nil)
    (FPAExprDomain type-decl nil domain nil)
    (RBExpr type-decl nil expressions nil)
    (RAExprDomain type-decl nil domain nil)
    (CEB type-eq-decl nil domain nil) (set type-eq-decl nil sets nil)
    (finite_nonempty? const-decl "bool" more_set_defs "sets_aux/")
    (Domain type-eq-decl nil domain nil)
    (nonempty? const-decl "bool" sets nil)
    (empty? const-decl "bool" sets nil)
    (member const-decl "bool" sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (injective? const-decl "bool" functions nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (replace_local_var_in_ceb const-decl "CEB" semantics nil)
    (replace_local_var_in_domain const-decl "Domain" semantics nil)
    (map const-decl "setof[T2]" more_set_props "sets_aux/"))
   shostak))
 (replace_local_var_dom_ceb 0
  (replace_local_var_dom_ceb-1 nil 3753548217 ("" (grind) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (Operator formal-nonempty-type-decl nil semantics nil)
    (RealNumber formal-nonempty-type-decl nil semantics nil)
    (FloatingPointNumber formal-nonempty-type-decl nil semantics nil)
    (FtoR formal-const-decl "[FloatingPointNumber -> RealNumber]"
     semantics nil)
    (FPBExpr type-decl nil expressions nil)
    (pred type-eq-decl nil defined_types nil)
    (strict_total_order? const-decl "bool" orders nil)
    (lt_r formal-const-decl "(strict_total_order?[RealNumber])"
     semantics nil)
    (applyFun_r formal-const-decl
     "[[Operator, RealNumber, RealNumber] -> RealNumber]" semantics
     nil)
    (lt_fp formal-const-decl
     "(strict_total_order?[FloatingPointNumber])" semantics nil)
    (applyFun_fp formal-const-decl
     "[[Operator, FloatingPointNumber, FloatingPointNumber] ->
   FloatingPointNumber]" semantics nil)
    (FPAExprDomain type-decl nil domain nil)
    (RBExpr type-decl nil expressions nil)
    (RAExprDomain type-decl nil domain nil)
    (CEB type-eq-decl nil domain nil) (set type-eq-decl nil sets nil)
    (finite_nonempty? const-decl "bool" more_set_defs "sets_aux/")
    (Domain type-eq-decl nil domain nil)
    (nonempty? const-decl "bool" sets nil)
    (empty? const-decl "bool" sets nil)
    (member const-decl "bool" sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (injective? const-decl "bool" functions nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (replace_local_var_in_ceb const-decl "CEB" semantics nil)
    (replace_local_var_in_domain const-decl "Domain" semantics nil)
    (map const-decl "setof[T2]" more_set_props "sets_aux/"))
   shostak))
 (replace_local_var_in_fpconds_ceb_evaluable_in 0
  (replace_local_var_in_fpconds_ceb_evaluable_in-1 nil 3753967001
   ("" (skeep)
    (("" (expand "replace_local_var_in_ceb")
      (("" (use "replace_local_var_in_fpform_evaluable_in") nil nil))
      nil))
    nil)
   ((replace_local_var_in_ceb const-decl "CEB" semantics nil)
    (replace_local_var_in_fpform_evaluable_in formula-decl nil
     semantics nil)
    (Operator formal-nonempty-type-decl nil semantics nil)
    (RealNumber formal-nonempty-type-decl nil semantics nil)
    (FloatingPointNumber formal-nonempty-type-decl nil semantics nil)
    (FtoR formal-const-decl "[FloatingPointNumber -> RealNumber]"
     semantics nil)
    (FPBExpr type-decl nil expressions nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (pred type-eq-decl nil defined_types nil)
    (strict_total_order? const-decl "bool" orders nil)
    (lt_r formal-const-decl "(strict_total_order?[RealNumber])"
     semantics nil)
    (applyFun_r formal-const-decl
     "[[Operator, RealNumber, RealNumber] -> RealNumber]" semantics
     nil)
    (lt_fp formal-const-decl
     "(strict_total_order?[FloatingPointNumber])" semantics nil)
    (applyFun_fp formal-const-decl
     "[[Operator, FloatingPointNumber, FloatingPointNumber] ->
   FloatingPointNumber]" semantics nil)
    (FPAExprDomain type-decl nil domain nil)
    (RBExpr type-decl nil expressions nil)
    (RAExprDomain type-decl nil domain nil)
    (CEB type-eq-decl nil domain nil)
    (FPAExpr type-decl nil expressions nil)
    (FPVariable? adt-recognizer-decl "[FPAExpr -> boolean]" expressions
     nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (fpVarIndex const-decl "nat" expressions_semantics nil)
    (strict_well_founded? const-decl "bool" orders nil)
    (<< adt-def-decl "(strict_well_founded?[FPAExpr])" expressions nil)
    (LocalEnvironment nonempty-type-decl nil u_local_environment nil)
    (FPLocalEnvironment type-eq-decl nil expressions_semantics nil)
    (bounded_by? const-decl "bool" u_local_environment nil))
   shostak))
 (replace_local_var_in_rconds_ceb_evaluable_in 0
  (replace_local_var_in_rconds_ceb_evaluable_in-1 nil 3754223064
   ("" (skeep)
    (("" (expand "replace_local_var_in_ceb")
      (("" (use "replace_local_var_in_rform_evaluable_in") nil nil))
      nil))
    nil)
   ((replace_local_var_in_ceb const-decl "CEB" semantics nil)
    (replace_local_var_in_rform_evaluable_in formula-decl nil semantics
     nil)
    (Operator formal-nonempty-type-decl nil semantics nil)
    (RealNumber formal-nonempty-type-decl nil semantics nil)
    (FloatingPointNumber formal-nonempty-type-decl nil semantics nil)
    (FtoR formal-const-decl "[FloatingPointNumber -> RealNumber]"
     semantics nil)
    (RAExpr type-decl nil expressions nil)
    (boolean nonempty-type-decl nil booleans nil)
    (RVariable? adt-recognizer-decl "[RAExpr -> boolean]" expressions
     nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (pred type-eq-decl nil defined_types nil)
    (strict_total_order? const-decl "bool" orders nil)
    (lt_r formal-const-decl "(strict_total_order?[RealNumber])"
     semantics nil)
    (applyFun_r formal-const-decl
     "[[Operator, RealNumber, RealNumber] -> RealNumber]" semantics
     nil)
    (lt_fp formal-const-decl
     "(strict_total_order?[FloatingPointNumber])" semantics nil)
    (applyFun_fp formal-const-decl
     "[[Operator, FloatingPointNumber, FloatingPointNumber] ->
   FloatingPointNumber]" semantics nil)
    (rVarIndex const-decl "nat" expressions_semantics nil)
    (strict_well_founded? const-decl "bool" orders nil)
    (<< adt-def-decl "(strict_well_founded?[RAExpr])" expressions nil)
    (LocalEnvironment nonempty-type-decl nil u_local_environment nil)
    (RLocalEnvironment type-eq-decl nil expressions_semantics nil)
    (FPAExpr type-decl nil expressions nil)
    (bounded_by? const-decl "bool" u_local_environment nil)
    (FtoR def-decl "RAExpr" expressions nil)
    (RBExpr type-decl nil expressions nil)
    (FPBExpr type-decl nil expressions nil)
    (FPAExprDomain type-decl nil domain nil)
    (RAExprDomain type-decl nil domain nil)
    (CEB type-eq-decl nil domain nil))
   nil))
 (replace_local_var_in_fpconds_ceb_val_TCC1 0
  (replace_local_var_in_fpconds_ceb_val_TCC1-1 nil 3753101977
   ("" (subtype-tcc) nil nil) nil nil))
 (replace_local_var_in_fpconds_ceb_val_TCC2 0
  (replace_local_var_in_fpconds_ceb_val_TCC2-1 nil 3753101977
   ("" (skeep)
    (("" (use "replace_local_var_in_fpconds_ceb_evaluable_in")
      (("" (assert) nil nil)) nil))
    nil)
   ((replace_local_var_in_fpconds_ceb_evaluable_in formula-decl nil
     semantics nil)
    (FPLocalEnvironment type-eq-decl nil expressions_semantics nil)
    (LocalEnvironment nonempty-type-decl nil u_local_environment nil)
    (<< adt-def-decl "(strict_well_founded?[FPAExpr])" expressions nil)
    (strict_well_founded? const-decl "bool" orders nil)
    (fpVarIndex const-decl "nat" expressions_semantics nil)
    (applyFun_fp formal-const-decl
     "[[Operator, FloatingPointNumber, FloatingPointNumber] ->
   FloatingPointNumber]" semantics nil)
    (lt_fp formal-const-decl
     "(strict_total_order?[FloatingPointNumber])" semantics nil)
    (applyFun_r formal-const-decl
     "[[Operator, RealNumber, RealNumber] -> RealNumber]" semantics
     nil)
    (lt_r formal-const-decl "(strict_total_order?[RealNumber])"
     semantics nil)
    (strict_total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (FPVariable? adt-recognizer-decl "[FPAExpr -> boolean]" expressions
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (FPAExpr type-decl nil expressions nil)
    (FtoR formal-const-decl "[FloatingPointNumber -> RealNumber]"
     semantics nil)
    (FloatingPointNumber formal-nonempty-type-decl nil semantics nil)
    (RealNumber formal-nonempty-type-decl nil semantics nil)
    (Operator formal-nonempty-type-decl nil semantics nil)
    (FPBExpr type-decl nil expressions nil)
    (FPAExprDomain type-decl nil domain nil)
    (RBExpr type-decl nil expressions nil)
    (RAExprDomain type-decl nil domain nil)
    (CEB type-eq-decl nil domain nil)
    (cons const-decl "LocalEnvironment" u_local_environment nil)
    (bounded_by? def-decl "bool" expressions_semantics nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (bounded_by? const-decl "bool" u_local_environment nil))
   nil))
 (replace_local_var_in_fpconds_ceb_val_TCC3 0
  (replace_local_var_in_fpconds_ceb_val_TCC3-2 nil 3755868935
   ("" (skeep)
    (("" (use "replace_local_var_in_fpconds_ceb_evaluable_in")
      (("" (assert) nil nil)) nil))
    nil)
   ((replace_local_var_in_fpconds_ceb_evaluable_in formula-decl nil
     semantics nil)
    (cons const-decl "LocalEnvironment" u_local_environment nil)
    (bounded_by? def-decl "bool" expressions_semantics nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (bounded_by? const-decl "bool" u_local_environment nil)
    (CEB type-eq-decl nil domain nil)
    (RAExprDomain type-decl nil domain nil)
    (RBExpr type-decl nil expressions nil)
    (FPAExprDomain type-decl nil domain nil)
    (FPBExpr type-decl nil expressions nil)
    (FPLocalEnvironment type-eq-decl nil expressions_semantics nil)
    (LocalEnvironment nonempty-type-decl nil u_local_environment nil)
    (<< adt-def-decl "(strict_well_founded?[FPAExpr])" expressions nil)
    (strict_well_founded? const-decl "bool" orders nil)
    (fpVarIndex const-decl "nat" expressions_semantics nil)
    (applyFun_fp formal-const-decl
     "[[Operator, FloatingPointNumber, FloatingPointNumber] ->
   FloatingPointNumber]" semantics nil)
    (lt_fp formal-const-decl
     "(strict_total_order?[FloatingPointNumber])" semantics nil)
    (applyFun_r formal-const-decl
     "[[Operator, RealNumber, RealNumber] -> RealNumber]" semantics
     nil)
    (lt_r formal-const-decl "(strict_total_order?[RealNumber])"
     semantics nil)
    (strict_total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (FPVariable? adt-recognizer-decl "[FPAExpr -> boolean]" expressions
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (FPAExpr type-decl nil expressions nil)
    (FtoR formal-const-decl "[FloatingPointNumber -> RealNumber]"
     semantics nil)
    (FloatingPointNumber formal-nonempty-type-decl nil semantics nil)
    (RealNumber formal-nonempty-type-decl nil semantics nil)
    (Operator formal-nonempty-type-decl nil semantics nil))
   nil)
  (replace_local_var_in_fpconds_ceb_val_TCC3-1 nil 3755693132
   ("" (subtype-tcc) nil nil) nil nil))
 (replace_local_var_in_fpconds_ceb_val 0
  (replace_local_var_in_fpconds_ceb_val-1 nil 3753983550
   ("" (skeep)
    (("" (expand "replace_local_var_in_ceb")
      (("" (use "replace_local_var_in_fpform_val") nil nil)) nil))
    nil)
   ((replace_local_var_in_ceb const-decl "CEB" semantics nil)
    (replace_local_var_in_fpform_val formula-decl nil semantics nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (Operator formal-nonempty-type-decl nil semantics nil)
    (RealNumber formal-nonempty-type-decl nil semantics nil)
    (FloatingPointNumber formal-nonempty-type-decl nil semantics nil)
    (FtoR formal-const-decl "[FloatingPointNumber -> RealNumber]"
     semantics nil)
    (ParameterIndex nonempty-type-eq-decl nil expressions nil)
    (FPNumber nonempty-type-eq-decl nil expressions nil)
    (pred type-eq-decl nil defined_types nil)
    (strict_total_order? const-decl "bool" orders nil)
    (lt_r formal-const-decl "(strict_total_order?[RealNumber])"
     semantics nil)
    (applyFun_r formal-const-decl
     "[[Operator, RealNumber, RealNumber] -> RealNumber]" semantics
     nil)
    (lt_fp formal-const-decl
     "(strict_total_order?[FloatingPointNumber])" semantics nil)
    (applyFun_fp formal-const-decl
     "[[Operator, FloatingPointNumber, FloatingPointNumber] ->
   FloatingPointNumber]" semantics nil)
    (FPEnvironment nonempty-type-eq-decl nil expressions_semantics nil)
    (FPAExpr type-decl nil expressions nil)
    (FPVariable? adt-recognizer-decl "[FPAExpr -> boolean]" expressions
     nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (fpVarIndex const-decl "nat" expressions_semantics nil)
    (strict_well_founded? const-decl "bool" orders nil)
    (<< adt-def-decl "(strict_well_founded?[FPAExpr])" expressions nil)
    (LocalEnvironment nonempty-type-decl nil u_local_environment nil)
    (FPLocalEnvironment type-eq-decl nil expressions_semantics nil)
    (bounded_by? const-decl "bool" u_local_environment nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (FPBExpr type-decl nil expressions nil)
    (bounded_by? def-decl "bool" expressions_semantics nil)
    (cons const-decl "LocalEnvironment" u_local_environment nil)
    (FPAExprDomain type-decl nil domain nil)
    (RBExpr type-decl nil expressions nil)
    (RAExprDomain type-decl nil domain nil)
    (CEB type-eq-decl nil domain nil))
   shostak))
 (replace_local_var_in_rconds_ceb_val_TCC1 0
  (replace_local_var_in_rconds_ceb_val_TCC1-1 nil 3753101977
   ("" (subtype-tcc) nil nil) nil nil))
 (replace_local_var_in_rconds_ceb_val_TCC2 0
  (replace_local_var_in_rconds_ceb_val_TCC2-2 nil 3754227087
   ("" (skeep)
    (("" (use "replace_local_var_in_rconds_ceb_evaluable_in")
      (("" (assert) nil nil)) nil))
    nil)
   ((replace_local_var_in_rconds_ceb_evaluable_in formula-decl nil
     semantics nil)
    (RLocalEnvironment type-eq-decl nil expressions_semantics nil)
    (LocalEnvironment nonempty-type-decl nil u_local_environment nil)
    (<< adt-def-decl "(strict_well_founded?[RAExpr])" expressions nil)
    (strict_well_founded? const-decl "bool" orders nil)
    (rVarIndex const-decl "nat" expressions_semantics nil)
    (applyFun_fp formal-const-decl
     "[[Operator, FloatingPointNumber, FloatingPointNumber] ->
   FloatingPointNumber]" semantics nil)
    (lt_fp formal-const-decl
     "(strict_total_order?[FloatingPointNumber])" semantics nil)
    (applyFun_r formal-const-decl
     "[[Operator, RealNumber, RealNumber] -> RealNumber]" semantics
     nil)
    (lt_r formal-const-decl "(strict_total_order?[RealNumber])"
     semantics nil)
    (strict_total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (RVariable? adt-recognizer-decl "[RAExpr -> boolean]" expressions
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (RAExpr type-decl nil expressions nil)
    (FtoR formal-const-decl "[FloatingPointNumber -> RealNumber]"
     semantics nil)
    (FloatingPointNumber formal-nonempty-type-decl nil semantics nil)
    (RealNumber formal-nonempty-type-decl nil semantics nil)
    (Operator formal-nonempty-type-decl nil semantics nil)
    (CEB type-eq-decl nil domain nil)
    (RAExprDomain type-decl nil domain nil)
    (FPAExprDomain type-decl nil domain nil)
    (FPBExpr type-decl nil expressions nil)
    (cons const-decl "LocalEnvironment" u_local_environment nil)
    (bounded_by? def-decl "bool" expressions_semantics nil)
    (RBExpr type-decl nil expressions nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (FtoR def-decl "RAExpr" expressions nil)
    (bounded_by? const-decl "bool" u_local_environment nil)
    (FPAExpr type-decl nil expressions nil))
   nil)
  (replace_local_var_in_rconds_ceb_val_TCC2-1 nil 3753101977
   ("" (subtype-tcc) nil nil) nil nil))
 (replace_local_var_in_rconds_ceb_val_TCC3 0
  (replace_local_var_in_rconds_ceb_val_TCC3-2 nil 3755868958
   ("" (skeep)
    (("" (use "replace_local_var_in_rconds_ceb_evaluable_in")
      (("" (assert) nil nil)) nil))
    nil)
   ((replace_local_var_in_rconds_ceb_evaluable_in formula-decl nil
     semantics nil)
    (cons const-decl "LocalEnvironment" u_local_environment nil)
    (bounded_by? def-decl "bool" expressions_semantics nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (FtoR def-decl "RAExpr" expressions nil)
    (bounded_by? const-decl "bool" u_local_environment nil)
    (FPAExpr type-decl nil expressions nil)
    (CEB type-eq-decl nil domain nil)
    (RAExprDomain type-decl nil domain nil)
    (RBExpr type-decl nil expressions nil)
    (FPAExprDomain type-decl nil domain nil)
    (FPBExpr type-decl nil expressions nil)
    (RLocalEnvironment type-eq-decl nil expressions_semantics nil)
    (LocalEnvironment nonempty-type-decl nil u_local_environment nil)
    (<< adt-def-decl "(strict_well_founded?[RAExpr])" expressions nil)
    (strict_well_founded? const-decl "bool" orders nil)
    (rVarIndex const-decl "nat" expressions_semantics nil)
    (applyFun_fp formal-const-decl
     "[[Operator, FloatingPointNumber, FloatingPointNumber] ->
   FloatingPointNumber]" semantics nil)
    (lt_fp formal-const-decl
     "(strict_total_order?[FloatingPointNumber])" semantics nil)
    (applyFun_r formal-const-decl
     "[[Operator, RealNumber, RealNumber] -> RealNumber]" semantics
     nil)
    (lt_r formal-const-decl "(strict_total_order?[RealNumber])"
     semantics nil)
    (strict_total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (RVariable? adt-recognizer-decl "[RAExpr -> boolean]" expressions
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (RAExpr type-decl nil expressions nil)
    (FtoR formal-const-decl "[FloatingPointNumber -> RealNumber]"
     semantics nil)
    (FloatingPointNumber formal-nonempty-type-decl nil semantics nil)
    (RealNumber formal-nonempty-type-decl nil semantics nil)
    (Operator formal-nonempty-type-decl nil semantics nil))
   nil)
  (replace_local_var_in_rconds_ceb_val_TCC3-1 nil 3755693132
   ("" (subtype-tcc) nil nil) nil nil))
 (replace_local_var_in_rconds_ceb_val 0
  (replace_local_var_in_rconds_ceb_val-2 nil 3754217125
   ("" (skeep)
    (("" (expand "replace_local_var_in_ceb")
      (("" (use "replace_local_var_in_rform_val") nil nil)) nil))
    nil)
   ((replace_local_var_in_ceb const-decl "CEB" semantics nil)
    (replace_local_var_in_rform_val formula-decl nil semantics nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (Operator formal-nonempty-type-decl nil semantics nil)
    (RealNumber formal-nonempty-type-decl nil semantics nil)
    (FloatingPointNumber formal-nonempty-type-decl nil semantics nil)
    (FtoR formal-const-decl "[FloatingPointNumber -> RealNumber]"
     semantics nil)
    (ParameterIndex nonempty-type-eq-decl nil expressions nil)
    (RNumber nonempty-type-eq-decl nil expressions nil)
    (pred type-eq-decl nil defined_types nil)
    (strict_total_order? const-decl "bool" orders nil)
    (lt_r formal-const-decl "(strict_total_order?[RealNumber])"
     semantics nil)
    (applyFun_r formal-const-decl
     "[[Operator, RealNumber, RealNumber] -> RealNumber]" semantics
     nil)
    (lt_fp formal-const-decl
     "(strict_total_order?[FloatingPointNumber])" semantics nil)
    (applyFun_fp formal-const-decl
     "[[Operator, FloatingPointNumber, FloatingPointNumber] ->
   FloatingPointNumber]" semantics nil)
    (REnvironment nonempty-type-eq-decl nil expressions_semantics nil)
    (RAExpr type-decl nil expressions nil)
    (RVariable? adt-recognizer-decl "[RAExpr -> boolean]" expressions
     nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (rVarIndex const-decl "nat" expressions_semantics nil)
    (strict_well_founded? const-decl "bool" orders nil)
    (<< adt-def-decl "(strict_well_founded?[RAExpr])" expressions nil)
    (LocalEnvironment nonempty-type-decl nil u_local_environment nil)
    (RLocalEnvironment type-eq-decl nil expressions_semantics nil)
    (FPAExpr type-decl nil expressions nil)
    (bounded_by? const-decl "bool" u_local_environment nil)
    (FtoR def-decl "RAExpr" expressions nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (RBExpr type-decl nil expressions nil)
    (bounded_by? def-decl "bool" expressions_semantics nil)
    (cons const-decl "LocalEnvironment" u_local_environment nil)
    (FPBExpr type-decl nil expressions nil)
    (FPAExprDomain type-decl nil domain nil)
    (RAExprDomain type-decl nil domain nil)
    (CEB type-eq-decl nil domain nil))
   nil)
  (replace_local_var_in_rconds_ceb_val-1 nil 3753983481
   ("" (postpone) nil nil) nil shostak))
 (replace_local_var_in_ceb_result_id 0
  (replace_local_var_in_ceb_result_id-1 nil 3755250157
   ("" (skeep) (("" (grind) nil nil)) nil)
   ((replace_local_var_in_ceb const-decl "CEB" semantics nil)) nil))
 (replace_local_var_in_ceb_stable_id 0
  (replace_local_var_in_ceb_stable_id-1 nil 3753548066
   ("" (skeep) (("" (grind) nil nil)) nil)
   ((replace_local_var_in_ceb const-decl "CEB" semantics nil))
   shostak))
 (else_then_unstable_ceb_TCC1 0
  (else_then_unstable_ceb_TCC1-1 nil 3753871784
   ("" (subtype-tcc) nil nil)
   ((NOT const-decl "[bool -> bool]" booleans nil)
    (FPBExpr type-decl nil expressions nil)
    (FPAExprDomain type-decl nil domain nil)
    (RBExpr type-decl nil expressions nil)
    (RAExprDomain type-decl nil domain nil)
    (CEB type-eq-decl nil domain nil) (set type-eq-decl nil sets nil)
    (finite_nonempty? const-decl "bool" more_set_defs "sets_aux/")
    (Domain type-eq-decl nil domain nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (stable_ceb_filter const-decl
     "{result: Domain | FORALL (ceb: (result)): stable?(ceb)}" domain
     nil)
    (nonempty? const-decl "bool" sets nil)
    (empty? const-decl "bool" sets nil)
    (member const-decl "bool" sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (injective? const-decl "bool" functions nil)
    (FtoR formal-const-decl "[FloatingPointNumber -> RealNumber]"
     semantics nil)
    (applyFun_fp formal-const-decl
     "[[Operator, FloatingPointNumber, FloatingPointNumber] ->
   FloatingPointNumber]" semantics nil)
    (lt_fp formal-const-decl
     "(strict_total_order?[FloatingPointNumber])" semantics nil)
    (FloatingPointNumber formal-nonempty-type-decl nil semantics nil)
    (applyFun_r formal-const-decl
     "[[Operator, RealNumber, RealNumber] -> RealNumber]" semantics
     nil)
    (lt_r formal-const-decl "(strict_total_order?[RealNumber])"
     semantics nil)
    (strict_total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (RealNumber formal-nonempty-type-decl nil semantics nil)
    (Operator formal-nonempty-type-decl nil semantics nil)
    (stable_domain? const-decl "boolean" domain nil))
   nil))
 (else_then_unstable_ceb_TCC2 0
  (else_then_unstable_ceb_TCC2-1 nil 3753871784
   ("" (subtype-tcc) nil nil)
   ((NOT const-decl "[bool -> bool]" booleans nil)
    (FPBExpr type-decl nil expressions nil)
    (FPAExprDomain type-decl nil domain nil)
    (RBExpr type-decl nil expressions nil)
    (RAExprDomain type-decl nil domain nil)
    (CEB type-eq-decl nil domain nil) (set type-eq-decl nil sets nil)
    (finite_nonempty? const-decl "bool" more_set_defs "sets_aux/")
    (Domain type-eq-decl nil domain nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (stable_ceb_filter const-decl
     "{result: Domain | FORALL (ceb: (result)): stable?(ceb)}" domain
     nil)
    (nonempty? const-decl "bool" sets nil)
    (empty? const-decl "bool" sets nil)
    (member const-decl "bool" sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (injective? const-decl "bool" functions nil)
    (FtoR formal-const-decl "[FloatingPointNumber -> RealNumber]"
     semantics nil)
    (applyFun_fp formal-const-decl
     "[[Operator, FloatingPointNumber, FloatingPointNumber] ->
   FloatingPointNumber]" semantics nil)
    (lt_fp formal-const-decl
     "(strict_total_order?[FloatingPointNumber])" semantics nil)
    (FloatingPointNumber formal-nonempty-type-decl nil semantics nil)
    (applyFun_r formal-const-decl
     "[[Operator, RealNumber, RealNumber] -> RealNumber]" semantics
     nil)
    (lt_r formal-const-decl "(strict_total_order?[RealNumber])"
     semantics nil)
    (strict_total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (RealNumber formal-nonempty-type-decl nil semantics nil)
    (Operator formal-nonempty-type-decl nil semantics nil)
    (stable_domain? const-decl "boolean" domain nil))
   nil))
 (else_then_unstable_ceb_def 0
  (else_then_unstable_ceb_def-1 nil 3753824774
   ("" (skeep)
    (("" (expand "else_then_unstable_ceb")
      (("" (invoke (typepred "%1") (! 1 1))
        (("" (replace -2 :hide? t)
          (("" (expand "is_unstable_from?")
            (("" (apply-extensionality)
              (("" (hide 2)
                (("" (iff)
                  (("" (split 1)
                    (("1" (flatten)
                      (("1" (skeep)
                        (("1" (inst 2 "cebr" "cebl")
                          (("1" (assert) nil nil)) nil))
                        nil))
                      nil)
                     ("2" (flatten)
                      (("2" (skeep -1 :preds? t)
                        (("2" (inst 2 "elseceb" "thenceb")
                          (("2" (assert) nil nil)) nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((else_then_unstable_ceb const-decl "Domain" semantics nil)
    (stable_ceb_filter const-decl
     "{result: Domain | FORALL (ceb: (result)): stable?(ceb)}" domain
     nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (make_unstable_domain def-decl "{dom: Domain |
         dom =
          ({ceb: CEB |
              EXISTS (cebl: (doml), cebr: (domr)):
                is_unstable_from?(cebl, cebr)(ceb)})}" domain nil)
    (is_unstable_from? const-decl "bool" domain nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (stable_domain? const-decl "boolean" domain nil)
    (Domain type-eq-decl nil domain nil)
    (finite_nonempty? const-decl "bool" more_set_defs "sets_aux/")
    (set type-eq-decl nil sets nil) (CEB type-eq-decl nil domain nil)
    (RAExprDomain type-decl nil domain nil)
    (RBExpr type-decl nil expressions nil)
    (FPAExprDomain type-decl nil domain nil)
    (applyFun_fp formal-const-decl
     "[[Operator, FloatingPointNumber, FloatingPointNumber] ->
   FloatingPointNumber]" semantics nil)
    (lt_fp formal-const-decl
     "(strict_total_order?[FloatingPointNumber])" semantics nil)
    (applyFun_r formal-const-decl
     "[[Operator, RealNumber, RealNumber] -> RealNumber]" semantics
     nil)
    (lt_r formal-const-decl "(strict_total_order?[RealNumber])"
     semantics nil)
    (strict_total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (FPBExpr type-decl nil expressions nil)
    (FtoR formal-const-decl "[FloatingPointNumber -> RealNumber]"
     semantics nil)
    (FloatingPointNumber formal-nonempty-type-decl nil semantics nil)
    (RealNumber formal-nonempty-type-decl nil semantics nil)
    (Operator formal-nonempty-type-decl nil semantics nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil))
   shostak))
 (then_else_unstable_ceb_def 0
  (then_else_unstable_ceb_def-1 nil 3753868956
   ("" (skeep)
    (("" (expand "then_else_unstable_ceb")
      (("" (invoke (typepred "%1") (! 1 1))
        (("" (replace -2 :hide? t)
          (("" (expand "is_unstable_from?") (("" (propax) nil nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((then_else_unstable_ceb const-decl "Domain" semantics nil)
    (stable_ceb_filter const-decl
     "{result: Domain | FORALL (ceb: (result)): stable?(ceb)}" domain
     nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (make_unstable_domain def-decl "{dom: Domain |
         dom =
          ({ceb: CEB |
              EXISTS (cebl: (doml), cebr: (domr)):
                is_unstable_from?(cebl, cebr)(ceb)})}" domain nil)
    (is_unstable_from? const-decl "bool" domain nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (stable_domain? const-decl "boolean" domain nil)
    (Domain type-eq-decl nil domain nil)
    (finite_nonempty? const-decl "bool" more_set_defs "sets_aux/")
    (set type-eq-decl nil sets nil) (CEB type-eq-decl nil domain nil)
    (RAExprDomain type-decl nil domain nil)
    (RBExpr type-decl nil expressions nil)
    (FPAExprDomain type-decl nil domain nil)
    (applyFun_fp formal-const-decl
     "[[Operator, FloatingPointNumber, FloatingPointNumber] ->
   FloatingPointNumber]" semantics nil)
    (lt_fp formal-const-decl
     "(strict_total_order?[FloatingPointNumber])" semantics nil)
    (applyFun_r formal-const-decl
     "[[Operator, RealNumber, RealNumber] -> RealNumber]" semantics
     nil)
    (lt_r formal-const-decl "(strict_total_order?[RealNumber])"
     semantics nil)
    (strict_total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (FPBExpr type-decl nil expressions nil)
    (FtoR formal-const-decl "[FloatingPointNumber -> RealNumber]"
     semantics nil)
    (FloatingPointNumber formal-nonempty-type-decl nil semantics nil)
    (RealNumber formal-nonempty-type-decl nil semantics nil)
    (Operator formal-nonempty-type-decl nil semantics nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil))
   shostak))
 (sem_TCC11 0
  (sem_TCC11-3 nil 3753703397
   ("" (skeep* :preds? t)
    (("" (expand "singleton")
      (("" (inst 1 "make_ceb(RTrue,FPTrue,RBottom,FPBottom,TRUE)")
        (("" (expand "make_ceb") (("" (assert) nil nil)) nil)) nil))
      nil))
    nil)
   ((singleton const-decl "(singleton?)" sets nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (FPBottom adt-constructor-decl "(FPBottom?)" domain nil)
    (FPBottom? adt-recognizer-decl "[FPAExprDomain -> boolean]" domain
     nil)
    (RBottom adt-constructor-decl "(RBottom?)" domain nil)
    (RBottom? adt-recognizer-decl "[RAExprDomain -> boolean]" domain
     nil)
    (FPTrue adt-constructor-decl "(FPTrue?)" expressions nil)
    (FPTrue? adt-recognizer-decl "[FPBExpr -> boolean]" expressions
     nil)
    (RTrue adt-constructor-decl "(RTrue?)" expressions nil)
    (RTrue? adt-recognizer-decl "[RBExpr -> boolean]" expressions nil)
    (make_ceb const-decl "CEB" domain nil)
    (CEB type-eq-decl nil domain nil)
    (RAExprDomain type-decl nil domain nil)
    (RBExpr type-decl nil expressions nil)
    (FPAExprDomain type-decl nil domain nil)
    (applyFun_fp formal-const-decl
     "[[Operator, FloatingPointNumber, FloatingPointNumber] ->
   FloatingPointNumber]" semantics nil)
    (lt_fp formal-const-decl
     "(strict_total_order?[FloatingPointNumber])" semantics nil)
    (applyFun_r formal-const-decl
     "[[Operator, RealNumber, RealNumber] -> RealNumber]" semantics
     nil)
    (lt_r formal-const-decl "(strict_total_order?[RealNumber])"
     semantics nil)
    (strict_total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (FPBExpr type-decl nil expressions nil)
    (FtoR formal-const-decl "[FloatingPointNumber -> RealNumber]"
     semantics nil)
    (FloatingPointNumber formal-nonempty-type-decl nil semantics nil)
    (RealNumber formal-nonempty-type-decl nil semantics nil)
    (Operator formal-nonempty-type-decl nil semantics nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil)
  (sem_TCC11-2 nil 3732643570 ("" (termination-tcc) nil nil)
   ((FPBExpr type-decl nil expressions nil)
    (FPAExprDomain type-decl nil domain nil)
    (RBExpr type-decl nil expressions nil)
    (RAExprDomain type-decl nil domain nil)
    (CEB type-eq-decl nil domain nil)
    (finite_nonempty? const-decl "bool" more_set_defs "sets_aux/")
    (FPStmt type-decl nil program nil)
    (wellFormed? inductive-decl "bool" program nil)
    (Domain type-eq-decl nil domain nil)
    (FPBottom adt-constructor-decl "(FPBottom?)" domain nil)
    (FPBottom? adt-recognizer-decl "[FPAExprDomain -> boolean]" domain
     nil)
    (RBottom adt-constructor-decl "(RBottom?)" domain nil)
    (RBottom? adt-recognizer-decl "[RAExprDomain -> boolean]" domain
     nil)
    (FPTrue adt-constructor-decl "(FPTrue?)" expressions nil)
    (FPTrue? adt-recognizer-decl "[FPBExpr -> boolean]" expressions
     nil)
    (RTrue adt-constructor-decl "(RTrue?)" expressions nil)
    (RTrue? adt-recognizer-decl "[RBExpr -> boolean]" expressions nil)
    (make_ceb const-decl "CEB" domain nil))
   nil)
  (sem_TCC11-1 nil 3731411566 ("" (termination-tcc) nil nil)
   ((FPBExpr type-decl nil expressions nil)
    (FPAExprDomain type-decl nil domain nil)
    (RBExpr type-decl nil expressions nil)
    (RAExprDomain type-decl nil domain nil)
    (CEB type-eq-decl nil domain nil)
    (FPAExpr type-decl nil expressions nil)
    (wellFormed? inductive-decl "bool" expressions nil)
    (Domain type-eq-decl nil domain nil)
    (<< adt-def-decl "(strict_well_founded?[FPAExpr])" expressions
     nil))
   nil))
 (sem_TCC12 0
  (sem_TCC12-3 nil 3753703417
   ("" (skeep* :preds? t)
    (("" (assert)
      (("" (expand "wellFormed?" -) (("" (grind) nil nil)) nil)) nil))
    nil)
   ((real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (injective? const-decl "bool" functions nil)
    (is_finite const-decl "bool" finite_sets nil)
    (member const-decl "bool" sets nil)
    (empty? const-decl "bool" sets nil)
    (nonempty? const-decl "bool" sets nil)
    (finite_nonempty? const-decl "bool" more_set_defs "sets_aux/")
    (/= const-decl "boolean" notequal nil)
    (bottomLess? const-decl "bool" semantics nil)
    (bottomLess? const-decl "bool" semantics nil)
    (bottomLess? const-decl "bool" semantics nil)
    (stable? const-decl "bool" semantics nil)
    (stable? const-decl "bool" semantics nil)
    (conditionsHold? const-decl "bool" semantics nil)
    (conditionsHold? const-decl "bool" semantics nil)
    (conditionsHold? const-decl "bool" semantics nil)
    (FtoR formal-const-decl "[FloatingPointNumber -> RealNumber]"
     semantics nil)
    (FloatingPointNumber formal-nonempty-type-decl nil semantics nil)
    (RealNumber formal-nonempty-type-decl nil semantics nil)
    (Operator formal-nonempty-type-decl nil semantics nil)
    (appears? const-decl "bool" expressions nil)
    (FtoR def-decl "RAExpr" expressions nil)
    (appears? const-decl "bool" expressions nil)
    (applyFun_fp formal-const-decl
     "[[Operator, FloatingPointNumber, FloatingPointNumber] ->
   FloatingPointNumber]" semantics nil)
    (lt_fp formal-const-decl
     "(strict_total_order?[FloatingPointNumber])" semantics nil)
    (applyFun_r formal-const-decl
     "[[Operator, RealNumber, RealNumber] -> RealNumber]" semantics
     nil)
    (lt_r formal-const-decl "(strict_total_order?[RealNumber])"
     semantics nil)
    (strict_total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (appears? const-decl "bool" domain nil)
    (appears? const-decl "bool" domain nil)
    (appears? const-decl "bool" semantics nil)
    (validEnvironmentForStmt const-decl "bool" semantics nil)
    (wellFormed? inductive-decl "bool" program nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil)
  (sem_TCC12-2 nil 3732701583
   ("" (skeep* :preds? t)
    (("" (expand "singleton")
      (("" (split 1)
        (("1" (inst 1 "make_ceb(RTrue,FPTrue,RBottom,FPBottom,TRUE)")
          (("1" (expand "make_ceb") (("1" (assert) nil nil)) nil)) nil)
         ("2" (expand "make_ceb")
          (("2" (expand "finite_nonempty?")
            (("2" (split 1)
              (("1" (expand "is_finite")
                (("1"
                  (inst 1 "1" "LAMBDA(x: ({y:
                     CEB
                         [Operator, RealNumber, lt_r, applyFun_r,
                          FloatingPointNumber, lt_fp, applyFun_fp, FtoR]
                     |
                     y =
                      (# rconds
                           := RTrue
                                  [Operator, RealNumber,
                                   FloatingPointNumber, FtoR],
                         fpconds
                           := FPTrue
                                  [Operator, RealNumber,
                                   FloatingPointNumber, FtoR],
                         rresult
                           := RBottom
                                  [Operator, RealNumber, lt_r, applyFun_r,
                                   FloatingPointNumber, lt_fp, applyFun_fp,
                                   FtoR],
                         fpresult
                           := FPBottom
                                  [Operator, RealNumber, lt_r, applyFun_r,
                                   FloatingPointNumber, lt_fp, applyFun_fp,
                                   FtoR],
                         stable? := TRUE #)})): 0")
                  (("1" (grind) nil nil)) nil))
                nil)
               ("2" (expand "nonempty?")
                (("2" (expand "empty?")
                  (("2" (expand "member")
                    (("2"
                      (inst -1
                       "make_ceb(RTrue,FPTrue,RBottom,FPBottom,TRUE)")
                      (("2" (expand "make_ceb")
                        (("2" (propax) nil nil)) nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((finite_nonempty? const-decl "bool" more_set_defs "sets_aux/")
    (FPBExpr type-decl nil expressions nil)
    (FPAExprDomain type-decl nil domain nil)
    (RBExpr type-decl nil expressions nil)
    (RAExprDomain type-decl nil domain nil)
    (CEB type-eq-decl nil domain nil)
    (make_ceb const-decl "CEB" domain nil)
    (RTrue? adt-recognizer-decl "[RBExpr -> boolean]" expressions nil)
    (RTrue adt-constructor-decl "(RTrue?)" expressions nil)
    (FPTrue? adt-recognizer-decl "[FPBExpr -> boolean]" expressions
     nil)
    (FPTrue adt-constructor-decl "(FPTrue?)" expressions nil)
    (RBottom? adt-recognizer-decl "[RAExprDomain -> boolean]" domain
     nil)
    (RBottom adt-constructor-decl "(RBottom?)" domain nil)
    (FPBottom? adt-recognizer-decl "[FPAExprDomain -> boolean]" domain
     nil)
    (FPBottom adt-constructor-decl "(FPBottom?)" domain nil))
   nil)
  (sem_TCC12-1 nil 3732272982 ("" (tcc) nil nil)
   ((FPBExpr type-decl nil expressions nil)
    (FPAExprDomain type-decl nil domain nil)
    (RBExpr type-decl nil expressions nil)
    (RAExprDomain type-decl nil domain nil)
    (CEB type-eq-decl nil domain nil)
    (FPStmt type-decl nil program nil)
    (wellFormed? inductive-decl "bool" program nil)
    (Domain type-eq-decl nil domain nil)
    (<< adt-def-decl "(strict_well_founded?[FPStmt])" program nil))
   nil))
 (sem_TCC13 0
  (sem_TCC13-3 nil 3753703431 ("" (termination-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (Operator formal-nonempty-type-decl nil semantics nil)
    (RealNumber formal-nonempty-type-decl nil semantics nil)
    (FloatingPointNumber formal-nonempty-type-decl nil semantics nil)
    (FtoR formal-const-decl "[FloatingPointNumber -> RealNumber]"
     semantics nil)
    (FPBExpr type-decl nil expressions nil)
    (pred type-eq-decl nil defined_types nil)
    (strict_total_order? const-decl "bool" orders nil)
    (lt_r formal-const-decl "(strict_total_order?[RealNumber])"
     semantics nil)
    (applyFun_r formal-const-decl
     "[[Operator, RealNumber, RealNumber] -> RealNumber]" semantics
     nil)
    (lt_fp formal-const-decl
     "(strict_total_order?[FloatingPointNumber])" semantics nil)
    (applyFun_fp formal-const-decl
     "[[Operator, FloatingPointNumber, FloatingPointNumber] ->
   FloatingPointNumber]" semantics nil)
    (FPAExprDomain type-decl nil domain nil)
    (RBExpr type-decl nil expressions nil)
    (RAExprDomain type-decl nil domain nil)
    (CEB type-eq-decl nil domain nil) (set type-eq-decl nil sets nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (every adt-def-decl "boolean" list_adt nil)
    (finite_nonempty? const-decl "bool" more_set_defs "sets_aux/")
    (Environment nonempty-type-eq-decl nil semantics nil)
    (validEnvironmentForStmt const-decl "bool" semantics nil)
    (FPStmt type-decl nil program nil)
    (wellFormed? inductive-decl "bool" program nil)
    (Domain type-eq-decl nil domain nil)
    (length def-decl "nat" list_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (<< adt-def-decl "(strict_well_founded?[FPStmt])" program nil)
    (appears? const-decl "bool" semantics nil)
    (appears? const-decl "bool" domain nil)
    (appears? const-decl "bool" domain nil)
    (appears? const-decl "bool" expressions nil)
    (FtoR def-decl "RAExpr" expressions nil)
    (appears? const-decl "bool" expressions nil)
    (conditionsHold? const-decl "bool" semantics nil)
    (conditionsHold? const-decl "bool" semantics nil)
    (conditionsHold? const-decl "bool" semantics nil)
    (stable? const-decl "bool" semantics nil)
    (stable? const-decl "bool" semantics nil)
    (bottomLess? const-decl "bool" semantics nil)
    (bottomLess? const-decl "bool" semantics nil)
    (bottomLess? const-decl "bool" semantics nil)
    (/= const-decl "boolean" notequal nil)
    (nonempty? const-decl "bool" sets nil)
    (empty? const-decl "bool" sets nil)
    (member const-decl "bool" sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (injective? const-decl "bool" functions nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil))
   nil)
  (sem_TCC13-2 nil 3742318733
   ("" (skeep* :preds? t)
    (("" (assert)
      (("" (expand "wellFormed?" -) (("" (grind) nil nil)) nil)) nil))
    nil)
   ((finite_nonempty? const-decl "bool" more_set_defs "sets_aux/")
    (<< adt-def-decl "(strict_well_founded?[FPStmt])" program nil)
    (wellFormed? inductive-decl "bool" program nil))
   nil)
  (sem_TCC13-1 nil 3732272982 ("" (termination-tcc) nil nil)
   ((FPBExpr type-decl nil expressions nil)
    (FPAExprDomain type-decl nil domain nil)
    (RBExpr type-decl nil expressions nil)
    (RAExprDomain type-decl nil domain nil)
    (CEB type-eq-decl nil domain nil)
    (FPStmt type-decl nil program nil)
    (wellFormed? inductive-decl "bool" program nil)
    (Domain type-eq-decl nil domain nil)
    (<< adt-def-decl "(strict_well_founded?[FPStmt])" program nil))
   shostak))
 (sem_TCC14 0
  (sem_TCC14-3 nil 3753703454
   ("" (skeep*)
    (("" (expand "union")
      (("" (expand "member")
        (("" (typepred "semthen")
          (("" (skolem -2 "ceb_then")
            ((""
              (inst 1 "make_ceb(RAnd(FtoR(guard), rconds(ceb_then)),
                               FPAnd(guard, fpconds(ceb_then)), rresult(ceb_then),
                               fpresult(ceb_then), stable?(ceb_then))")
              (("" (grind) nil nil)) nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((union const-decl "set" sets nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (Domain type-eq-decl nil domain nil)
    (finite_nonempty? const-decl "bool" more_set_defs "sets_aux/")
    (set type-eq-decl nil sets nil) (CEB type-eq-decl nil domain nil)
    (RAExprDomain type-decl nil domain nil)
    (RBExpr type-decl nil expressions nil)
    (FPAExprDomain type-decl nil domain nil)
    (applyFun_fp formal-const-decl
     "[[Operator, FloatingPointNumber, FloatingPointNumber] ->
   FloatingPointNumber]" semantics nil)
    (lt_fp formal-const-decl
     "(strict_total_order?[FloatingPointNumber])" semantics nil)
    (applyFun_r formal-const-decl
     "[[Operator, RealNumber, RealNumber] -> RealNumber]" semantics
     nil)
    (lt_r formal-const-decl "(strict_total_order?[RealNumber])"
     semantics nil)
    (strict_total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (FPBExpr type-decl nil expressions nil)
    (FtoR formal-const-decl "[FloatingPointNumber -> RealNumber]"
     semantics nil)
    (FloatingPointNumber formal-nonempty-type-decl nil semantics nil)
    (RealNumber formal-nonempty-type-decl nil semantics nil)
    (Operator formal-nonempty-type-decl nil semantics nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (FPAnd adt-constructor-decl "[[FPBExpr, FPBExpr] -> (FPAnd?)]"
     expressions nil)
    (FPAnd? adt-recognizer-decl "[FPBExpr -> boolean]" expressions nil)
    (FtoR def-decl "RBExpr" expressions nil)
    (RAnd adt-constructor-decl "[[RBExpr, RBExpr] -> (RAnd?)]"
     expressions nil)
    (RAnd? adt-recognizer-decl "[RBExpr -> boolean]" expressions nil)
    (make_ceb const-decl "CEB" domain nil)
    (finite_rest application-judgement "finite_set" finite_sets nil)
    (nil application-judgement "(finite_nonempty?
     [CEB
          [Operator, RealNumber, lt_r, applyFun_r, FloatingPointNumber,
           lt_fp, applyFun_fp, FtoR]])" semantics nil)
    (propag const-decl "{result: Domain |
         (FORALL (ceb2: (result)):
            EXISTS (ceb: (sceb)):
              ceb2 =
               make_ceb(RAnd(rexpr, rconds(ceb)),
                        FPAnd(fpexpr, fpconds(ceb)), rresult(ceb),
                        fpresult(ceb), stable?(ceb)))
          AND
          (FORALL (ceb: (sceb)):
             EXISTS (ceb2: (result)):
               ceb2 =
                make_ceb(RAnd(rexpr, rconds(ceb)),
                         FPAnd(fpexpr, fpconds(ceb)), rresult(ceb),
                         fpresult(ceb), stable?(ceb)))}" domain nil)
    (map const-decl "setof[T2]" more_set_props "sets_aux/")
    (stable_ceb_filter const-decl
     "{result: Domain | FORALL (ceb: (result)): stable?(ceb)}" domain
     nil)
    (rest const-decl "set" sets nil)
    (/= const-decl "boolean" notequal nil)
    (remove const-decl "set" sets nil)
    (else_then_unstable_ceb const-decl "Domain" semantics nil)
    (then_else_unstable_ceb const-decl "Domain" semantics nil)
    (injective? const-decl "bool" functions nil)
    (is_finite const-decl "bool" finite_sets nil)
    (empty? const-decl "bool" sets nil)
    (nonempty? const-decl "bool" sets nil)
    (member const-decl "bool" sets nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil)
  (sem_TCC14-2 nil 3732701557 ("" (termination-tcc) nil nil)
   ((FPBExpr type-decl nil expressions nil)
    (FPAExprDomain type-decl nil domain nil)
    (RBExpr type-decl nil expressions nil)
    (RAExprDomain type-decl nil domain nil)
    (CEB type-eq-decl nil domain nil)
    (finite_nonempty? const-decl "bool" more_set_defs "sets_aux/")
    (FPStmt type-decl nil program nil)
    (wellFormed? inductive-decl "bool" program nil)
    (Domain type-eq-decl nil domain nil)
    (<< adt-def-decl "(strict_well_founded?[FPStmt])" program nil))
   nil)
  (sem_TCC14-1 nil 3732272982
   (""
    (with-labels (skeep* :preds? t)
     (("semelse is nonempty" "semthen is nonempty" nil nil nil nil nil
       nil nil "new ceb must be nonempty")))
    ((""
      (hide-all-but
       ("semthen is nonempty" "semelse is nonempty"
        "new ceb must be nonempty"))
      (("" (expand "nonempty?")
        (("" (expand "empty?")
          (("" (skolem "semelse is nonempty" "cebelse")
            (("" (skolem "semthen is nonempty" "cebthen")
              (("" (expand "member")
                ((""
                  (inst "new ceb must be nonempty"
                   "make_ceb(rconds(cebthen), fpconds(cebelse),rresult(cebthen),fpresult(cebelse), FALSE)")
                  ((""
                    (inst "new ceb must be nonempty" "cebthen"
                     "cebelse")
                    (("" (expand "make_ceb") (("" (propax) nil nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((FPBExpr type-decl nil expressions nil)
    (FPAExprDomain type-decl nil domain nil)
    (RBExpr type-decl nil expressions nil)
    (RAExprDomain type-decl nil domain nil)
    (CEB type-eq-decl nil domain nil)
    (make_ceb const-decl "CEB" domain nil)
    (Domain type-eq-decl nil domain nil))
   nil))
 (sem_TCC15 3
  (sem_TCC15-4 nil 3753703469
   ("" (skeep :preds? t)
    (("" (lemma "well_formed_ITE_propagation")
      (("" (inst -1 "guard" "thenb" "elseb" "nargs" "length(env)")
        (("" (assert) nil))))))
    nil)
   ((FPBExpr type-decl nil expressions nil)
    (FPStmt type-decl nil program nil)
    (FPAExprDomain type-decl nil domain nil)
    (RBExpr type-decl nil expressions nil)
    (RAExprDomain type-decl nil domain nil)
    (CEB type-eq-decl nil domain nil)
    (finite_nonempty? const-decl "bool" more_set_defs "sets_aux/")
    (Domain type-eq-decl nil domain nil)
    (well_formed_ITE_propagation formula-decl nil expressions_props
     nil))
   nil)
  (sem_TCC15-3 nil 3742319415
   ("" (skeep*)
    (("" (expand "union")
      (("" (expand "member")
        (("" (typepred "semthen")
          (("" (skolem -2 "ceb_then")
            ((""
              (inst 1 "make_ceb(RAnd(FtoR(guard), rconds(ceb_then)),
                             FPAnd(guard, fpconds(ceb_then)), rresult(ceb_then),
                             fpresult(ceb_then), stable?(ceb_then))")
              (("" (grind) nil nil)) nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((Domain type-eq-decl nil domain nil)
    (finite_nonempty? const-decl "bool" more_set_defs "sets_aux/")
    (CEB type-eq-decl nil domain nil)
    (RAExprDomain type-decl nil domain nil)
    (RBExpr type-decl nil expressions nil)
    (FPAExprDomain type-decl nil domain nil)
    (FPBExpr type-decl nil expressions nil)
    (FPAnd adt-constructor-decl "[[FPBExpr, FPBExpr] -> (FPAnd?)]"
     expressions nil)
    (FPAnd? adt-recognizer-decl "[FPBExpr -> boolean]" expressions nil)
    (FtoR def-decl "RBExpr" expressions nil)
    (RAnd adt-constructor-decl "[[RBExpr, RBExpr] -> (RAnd?)]"
     expressions nil)
    (RAnd? adt-recognizer-decl "[RBExpr -> boolean]" expressions nil)
    (make_ceb const-decl "CEB" domain nil)
    (propag const-decl "{result: Domain |
         (FORALL (ceb2: (result)):
            EXISTS (ceb: (sceb)):
              ceb2 =
               make_ceb(RAnd(rexpr, rconds(ceb)),
                        FPAnd(fpexpr, fpconds(ceb)), rresult(ceb),
                        fpresult(ceb), stable?(ceb)))
          AND
          (FORALL (ceb: (sceb)):
             EXISTS (ceb2: (result)):
               ceb2 =
                make_ceb(RAnd(rexpr, rconds(ceb)),
                         FPAnd(fpexpr, fpconds(ceb)), rresult(ceb),
                         fpresult(ceb), stable?(ceb)))}" domain nil)
    (map const-decl "setof[T2]" more_set_props "sets_aux/"))
   nil)
  (sem_TCC15-2 nil 3732701535
   (""
    (with-labels (skeep* :preds? t)
     (("semelse is nonempty" "semthen is nonempty" nil nil nil nil nil
       nil nil "new ceb must be nonempty")))
    ((""
      (hide-all-but
       ("semthen is nonempty" "semelse is nonempty"
        "new ceb must be nonempty"))
      (("" (expand "nonempty?")
        (("" (expand "empty?")
          (("" (skolem "semelse is nonempty" "cebelse")
            (("" (skolem "semthen is nonempty" "cebthen")
              (("" (expand "member")
                ((""
                  (inst "new ceb must be nonempty"
                   "make_ceb(rconds(cebthen), fpconds(cebelse),rresult(cebthen),fpresult(cebelse), FALSE)")
                  ((""
                    (inst "new ceb must be nonempty" "cebthen"
                     "cebelse")
                    (("" (expand "make_ceb") (("" (propax) nil nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((Domain type-eq-decl nil domain nil)
    (make_ceb const-decl "CEB" domain nil)
    (CEB type-eq-decl nil domain nil)
    (RAExprDomain type-decl nil domain nil)
    (RBExpr type-decl nil expressions nil)
    (FPAExprDomain type-decl nil domain nil)
    (FPBExpr type-decl nil expressions nil))
   nil)
  (sem_TCC15-1 nil 3732272982
   ("" (skeep :preds? t)
    (("" (lemma "well_formed_ITE_propagation")
      (("" (inst -1 "guard" "thenb" "elseb" "nargs" "length(env)")
        (("" (assert) nil nil)) nil))
      nil))
    nil)
   ((FtoR formal-const-decl "[FloatingPointNumber -> RealNumber]"
     semantics nil)
    (FloatingPointNumber formal-nonempty-type-decl nil semantics nil)
    (RealNumber formal-nonempty-type-decl nil semantics nil)
    (Operator formal-nonempty-type-decl nil semantics nil)
    (well_formed_ITE_propagation formula-decl nil expressions_props
     nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (validEnvironmentForStmt const-decl "bool" semantics nil)
    (Environment nonempty-type-eq-decl nil semantics nil)
    (length def-decl "nat" list_props nil)
    (Domain type-eq-decl nil domain nil)
    (finite_nonempty? const-decl "bool" more_set_defs "sets_aux/")
    (every adt-def-decl "boolean" list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil) (set type-eq-decl nil sets nil)
    (CEB type-eq-decl nil domain nil)
    (RAExprDomain type-decl nil domain nil)
    (RBExpr type-decl nil expressions nil)
    (FPAExprDomain type-decl nil domain nil)
    (applyFun_fp formal-const-decl
     "[[Operator, FloatingPointNumber, FloatingPointNumber] ->
   FloatingPointNumber]" semantics nil)
    (lt_fp formal-const-decl
     "(strict_total_order?[FloatingPointNumber])" semantics nil)
    (applyFun_r formal-const-decl
     "[[Operator, RealNumber, RealNumber] -> RealNumber]" semantics
     nil)
    (lt_r formal-const-decl "(strict_total_order?[RealNumber])"
     semantics nil)
    (strict_total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (FPStmt type-decl nil program nil)
    (FPBExpr type-decl nil expressions nil))
   shostak))
 (sem_TCC16 0
  (sem_TCC16-5 nil 3753703578 ("" (termination-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (Operator formal-nonempty-type-decl nil semantics nil)
    (RealNumber formal-nonempty-type-decl nil semantics nil)
    (FloatingPointNumber formal-nonempty-type-decl nil semantics nil)
    (FtoR formal-const-decl "[FloatingPointNumber -> RealNumber]"
     semantics nil)
    (FPBExpr type-decl nil expressions nil)
    (pred type-eq-decl nil defined_types nil)
    (strict_total_order? const-decl "bool" orders nil)
    (lt_r formal-const-decl "(strict_total_order?[RealNumber])"
     semantics nil)
    (applyFun_r formal-const-decl
     "[[Operator, RealNumber, RealNumber] -> RealNumber]" semantics
     nil)
    (lt_fp formal-const-decl
     "(strict_total_order?[FloatingPointNumber])" semantics nil)
    (applyFun_fp formal-const-decl
     "[[Operator, FloatingPointNumber, FloatingPointNumber] ->
   FloatingPointNumber]" semantics nil)
    (FPAExprDomain type-decl nil domain nil)
    (RBExpr type-decl nil expressions nil)
    (RAExprDomain type-decl nil domain nil)
    (CEB type-eq-decl nil domain nil) (set type-eq-decl nil sets nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (every adt-def-decl "boolean" list_adt nil)
    (finite_nonempty? const-decl "bool" more_set_defs "sets_aux/")
    (Environment nonempty-type-eq-decl nil semantics nil)
    (validEnvironmentForStmt const-decl "bool" semantics nil)
    (FPStmt type-decl nil program nil)
    (wellFormed? inductive-decl "bool" program nil)
    (Domain type-eq-decl nil domain nil)
    (length def-decl "nat" list_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (<< adt-def-decl "(strict_well_founded?[FPStmt])" program nil)
    (appears? const-decl "bool" semantics nil)
    (appears? const-decl "bool" domain nil)
    (appears? const-decl "bool" domain nil)
    (appears? const-decl "bool" expressions nil)
    (FtoR def-decl "RAExpr" expressions nil)
    (appears? const-decl "bool" expressions nil)
    (conditionsHold? const-decl "bool" semantics nil)
    (conditionsHold? const-decl "bool" semantics nil)
    (conditionsHold? const-decl "bool" semantics nil)
    (stable? const-decl "bool" semantics nil)
    (stable? const-decl "bool" semantics nil)
    (bottomLess? const-decl "bool" semantics nil)
    (bottomLess? const-decl "bool" semantics nil)
    (bottomLess? const-decl "bool" semantics nil)
    (/= const-decl "boolean" notequal nil))
   nil)
  (sem_TCC16-4 nil 3753529106
   ("" (skeep :preds? t)
    (("" (lemma "well_formed_ITE_propagation")
      (("" (inst -1 "guard" "thenb" "elseb" "nargs" "length(env)")
        (("" (assert) nil nil)) nil))
      nil))
    nil)
   ((well_formed_ITE_propagation formula-decl nil expressions_props
     nil)
    (Domain type-eq-decl nil domain nil)
    (finite_nonempty? const-decl "bool" more_set_defs "sets_aux/")
    (CEB type-eq-decl nil domain nil)
    (RAExprDomain type-decl nil domain nil)
    (RBExpr type-decl nil expressions nil)
    (FPAExprDomain type-decl nil domain nil)
    (FPStmt type-decl nil program nil)
    (FPBExpr type-decl nil expressions nil))
   nil)
  (sem_TCC16-3 nil 3742319133
   (""
    (with-labels (skeep* :preds? t)
     ((nil "exists stable ceb in semelse" nil
       "exists stable ceb in semthen" nil nil nil nil nil nil nil
       "new ceb must be nonempty")))
    ((""
      (hide-all-but
       ("exists stable ceb in semthen" "exists stable ceb in semelse"
        "new ceb must be nonempty"))
      (("" (expand "nonempty?")
        (("" (expand "empty?")
          (("" (skolem "exists stable ceb in semelse" "cebelse")
            (("" (skolem "exists stable ceb in semthen" "cebthen")
              (("" (flatten)
                ((""
                  (inst "new ceb must be nonempty"
                   "make_ceb(rconds(cebthen), fpconds(cebelse),rresult(cebthen),fpresult(cebelse), FALSE)")
                  (("" (expand "member")
                    ((""
                      (inst "new ceb must be nonempty" "cebthen"
                       "cebelse")
                      (("1" (expand "make_ceb")
                        (("1" (propax) nil nil)) nil)
                       ("2" (assert) nil nil) ("3" (assert) nil nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((FPBExpr type-decl nil expressions nil)
    (FPAExprDomain type-decl nil domain nil)
    (RBExpr type-decl nil expressions nil)
    (RAExprDomain type-decl nil domain nil)
    (CEB type-eq-decl nil domain nil)
    (make_ceb const-decl "CEB" domain nil)
    (Domain type-eq-decl nil domain nil))
   nil)
  (sem_TCC16-2 nil 3732701521
   ("" (skeep :preds? t)
    (("" (lemma "well_formed_ITE_propagation")
      (("" (inst -1 "guard" "thenb" "elseb" "nargs" "length(env)")
        (("" (assert) nil nil)) nil))
      nil))
    nil)
   ((FPBExpr type-decl nil expressions nil)
    (FPStmt type-decl nil program nil)
    (FPAExprDomain type-decl nil domain nil)
    (RBExpr type-decl nil expressions nil)
    (RAExprDomain type-decl nil domain nil)
    (CEB type-eq-decl nil domain nil)
    (Domain type-eq-decl nil domain nil)
    (well_formed_ITE_propagation formula-decl nil expressions_props
     nil))
   nil)
  (sem_TCC16-1 nil 3732272982 ("" (termination-tcc) nil nil)
   ((FPBExpr type-decl nil expressions nil)
    (FPAExprDomain type-decl nil domain nil)
    (RBExpr type-decl nil expressions nil)
    (RAExprDomain type-decl nil domain nil)
    (CEB type-eq-decl nil domain nil)
    (FPStmt type-decl nil program nil)
    (wellFormed? inductive-decl "bool" program nil)
    (Domain type-eq-decl nil domain nil)
    (<< adt-def-decl "(strict_well_founded?[FPStmt])" program nil))
   shostak))
 (sem_TCC17 0
  (sem_TCC17-3 nil 3753703590
   ("" (skeep* :preds? t)
    (("" (lemma "well_formed_LETIN_propagation")
      (("" (inst -1 "aexpr" "body" "nargs" "length(env)")
        (("" (grind) nil nil)) nil))
      nil))
    nil)
   ((FtoR formal-const-decl "[FloatingPointNumber -> RealNumber]"
     semantics nil)
    (FloatingPointNumber formal-nonempty-type-decl nil semantics nil)
    (RealNumber formal-nonempty-type-decl nil semantics nil)
    (Operator formal-nonempty-type-decl nil semantics nil)
    (well_formed_LETIN_propagation formula-decl nil expressions_props
     nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (appears? const-decl "bool" semantics nil)
    (conditionsHold? const-decl "bool" semantics nil)
    (stable? const-decl "bool" semantics nil)
    (bottomLess? const-decl "bool" semantics nil)
    (validDomain const-decl "bool" semantics nil)
    (appears? const-decl "bool" domain nil)
    (appears? const-decl "bool" domain nil)
    (appears? const-decl "bool" expressions nil)
    (FtoR def-decl "RAExpr" expressions nil)
    (appears? const-decl "bool" expressions nil)
    (conditionsHold? const-decl "bool" semantics nil)
    (conditionsHold? const-decl "bool" semantics nil)
    (stable? const-decl "bool" semantics nil)
    (bottomLess? const-decl "bool" semantics nil)
    (bottomLess? const-decl "bool" semantics nil)
    (/= const-decl "boolean" notequal nil)
    (nonempty? const-decl "bool" sets nil)
    (empty? const-decl "bool" sets nil)
    (member const-decl "bool" sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (injective? const-decl "bool" functions nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (validEnvironmentForStmt const-decl "bool" semantics nil)
    (Environment nonempty-type-eq-decl nil semantics nil)
    (length def-decl "nat" list_props nil)
    (Domain type-eq-decl nil domain nil)
    (finite_nonempty? const-decl "bool" more_set_defs "sets_aux/")
    (every adt-def-decl "boolean" list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil) (set type-eq-decl nil sets nil)
    (CEB type-eq-decl nil domain nil)
    (RAExprDomain type-decl nil domain nil)
    (RBExpr type-decl nil expressions nil)
    (FPAExprDomain type-decl nil domain nil)
    (applyFun_fp formal-const-decl
     "[[Operator, FloatingPointNumber, FloatingPointNumber] ->
   FloatingPointNumber]" semantics nil)
    (lt_fp formal-const-decl
     "(strict_total_order?[FloatingPointNumber])" semantics nil)
    (applyFun_r formal-const-decl
     "[[Operator, RealNumber, RealNumber] -> RealNumber]" semantics
     nil)
    (lt_r formal-const-decl "(strict_total_order?[RealNumber])"
     semantics nil)
    (strict_total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (FPBExpr type-decl nil expressions nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (FPStmt type-decl nil program nil)
    (FPAExpr type-decl nil expressions nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil)
  (sem_TCC17-2 nil 3753530170 ("" (termination-tcc) nil nil)
   ((FPBExpr type-decl nil expressions nil)
    (FPAExprDomain type-decl nil domain nil)
    (RBExpr type-decl nil expressions nil)
    (RAExprDomain type-decl nil domain nil)
    (CEB type-eq-decl nil domain nil)
    (finite_nonempty? const-decl "bool" more_set_defs "sets_aux/")
    (FPStmt type-decl nil program nil)
    (wellFormed? inductive-decl "bool" program nil)
    (Domain type-eq-decl nil domain nil)
    (<< adt-def-decl "(strict_well_founded?[FPStmt])" program nil))
   nil)
  (sem_TCC17-1 nil 3732272982
   ("" (skeep*)
    (("" (expand "union")
      (("" (expand "member")
        (("" (typepred "semthen")
          (("" (skolem -2 "ceb_then")
            ((""
              (inst 1 "make_ceb(RAnd(FtoR(guard), rconds(ceb_then)),
                         FPAnd(guard, fpconds(ceb_then)), rresult(ceb_then),
                         fpresult(ceb_then), stable?(ceb_then))")
              (("" (grind) nil nil)) nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((Domain type-eq-decl nil domain nil)
    (CEB type-eq-decl nil domain nil)
    (RAExprDomain type-decl nil domain nil)
    (RBExpr type-decl nil expressions nil)
    (FPAExprDomain type-decl nil domain nil)
    (FPBExpr type-decl nil expressions nil)
    (FPAnd adt-constructor-decl "[[FPBExpr, FPBExpr] -> (FPAnd?)]"
     expressions nil)
    (FPAnd? adt-recognizer-decl "[FPBExpr -> boolean]" expressions nil)
    (FtoR def-decl "RBExpr" expressions nil)
    (RAnd adt-constructor-decl "[[RBExpr, RBExpr] -> (RAnd?)]"
     expressions nil)
    (RAnd? adt-recognizer-decl "[RBExpr -> boolean]" expressions nil)
    (make_ceb const-decl "CEB" domain nil)
    (nil application-judgement "(nonempty?[T2])" more_set_props
     "sets_aux/")
    (propag const-decl "{result: Domain |
         (FORALL (ceb2: (result)):
            EXISTS (ceb: (sceb)):
              ceb2 =
               make_ceb(RAnd(rexpr, rconds(ceb)),
                        FPAnd(fpexpr, fpconds(ceb)), rresult(ceb),
                        fpresult(ceb), stable?(ceb)))
          AND
          (FORALL (ceb: (sceb)):
             EXISTS (ceb2: (result)):
               ceb2 =
                make_ceb(RAnd(rexpr, rconds(ceb)),
                         FPAnd(fpexpr, fpconds(ceb)), rresult(ceb),
                         fpresult(ceb), stable?(ceb)))}" domain nil)
    (map const-decl "setof[T2]" more_set_props "sets_aux/"))
   shostak))
 (sem_TCC18 0
  (sem_TCC18-4 nil 3753703603
   ("" (skeep* :preds? t)
    (("" (lemma "valid_environment_extension")
      (("" (inst -1 "nargs" "env" "sem_expr") (("" (assert) nil nil))
        nil))
      nil))
    nil)
   ((valid_environment_extension formula-decl nil semantics nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (validDomain const-decl "bool" semantics nil)
    (Domain type-eq-decl nil domain nil)
    (validEnvironmentForStmt const-decl "bool" semantics nil)
    (Environment nonempty-type-eq-decl nil semantics nil)
    (finite_nonempty? const-decl "bool" more_set_defs "sets_aux/")
    (every adt-def-decl "boolean" list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil) (set type-eq-decl nil sets nil)
    (CEB type-eq-decl nil domain nil)
    (RAExprDomain type-decl nil domain nil)
    (RBExpr type-decl nil expressions nil)
    (FPAExprDomain type-decl nil domain nil)
    (applyFun_fp formal-const-decl
     "[[Operator, FloatingPointNumber, FloatingPointNumber] ->
   FloatingPointNumber]" semantics nil)
    (lt_fp formal-const-decl
     "(strict_total_order?[FloatingPointNumber])" semantics nil)
    (applyFun_r formal-const-decl
     "[[Operator, RealNumber, RealNumber] -> RealNumber]" semantics
     nil)
    (lt_r formal-const-decl "(strict_total_order?[RealNumber])"
     semantics nil)
    (strict_total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (FPBExpr type-decl nil expressions nil)
    (FtoR formal-const-decl "[FloatingPointNumber -> RealNumber]"
     semantics nil)
    (FloatingPointNumber formal-nonempty-type-decl nil semantics nil)
    (RealNumber formal-nonempty-type-decl nil semantics nil)
    (Operator formal-nonempty-type-decl nil semantics nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil)
  (sem_TCC18-3 nil 3742319114
   ("" (skeep* :preds? t)
    (("" (lemma "well_formed_LETIN_propagation")
      (("" (inst -1 "aexpr" "body" "nargs" "length(env)")
        (("" (grind) nil nil)) nil))
      nil))
    nil)
   ((well_formed_LETIN_propagation formula-decl nil expressions_props
     nil)
    (Domain type-eq-decl nil domain nil)
    (finite_nonempty? const-decl "bool" more_set_defs "sets_aux/")
    (CEB type-eq-decl nil domain nil)
    (RAExprDomain type-decl nil domain nil)
    (RBExpr type-decl nil expressions nil)
    (FPAExprDomain type-decl nil domain nil)
    (FPBExpr type-decl nil expressions nil)
    (FPStmt type-decl nil program nil)
    (FPAExpr type-decl nil expressions nil))
   nil)
  (sem_TCC18-2 nil 3732701490
   ("" (skeep* :preds? t)
    (("" (lemma "well_formed_LETIN_propagation")
      (("" (inst -1 "aexpr" "body" "nargs" "length(env)")
        (("" (grind) nil nil)) nil))
      nil))
    nil)
   ((FPAExpr type-decl nil expressions nil)
    (FPStmt type-decl nil program nil)
    (FPBExpr type-decl nil expressions nil)
    (FPAExprDomain type-decl nil domain nil)
    (RBExpr type-decl nil expressions nil)
    (RAExprDomain type-decl nil domain nil)
    (CEB type-eq-decl nil domain nil)
    (Domain type-eq-decl nil domain nil)
    (well_formed_LETIN_propagation formula-decl nil expressions_props
     nil))
   nil)
  (sem_TCC18-1 nil 3732272982
   ("" (skeep* :preds? t)
    (("" (lemma "valid_environment_extension")
      (("" (inst -1 "nargs" "env" "sem_expr")
        (("" (assert)
          (("" (expand "validDomain" 1) (("" (postpone) nil nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((Domain type-eq-decl nil domain nil)
    (CEB type-eq-decl nil domain nil)
    (RAExprDomain type-decl nil domain nil)
    (RBExpr type-decl nil expressions nil)
    (FPAExprDomain type-decl nil domain nil)
    (FPBExpr type-decl nil expressions nil))
   shostak))
 (sem_TCC19 1
  (sem_TCC19-2 nil 3732701471
   ("" (skeep* :preds? t)
    (("" (lemma "valid_environment_extension")
      (("" (inst -1 "nargs" "env" "sem_expr") (("" (assert) nil nil))
        nil))
      nil))
    nil)
   ((FPBExpr type-decl nil expressions nil)
    (FPAExprDomain type-decl nil domain nil)
    (RBExpr type-decl nil expressions nil)
    (RAExprDomain type-decl nil domain nil)
    (CEB type-eq-decl nil domain nil)
    (Domain type-eq-decl nil domain nil))
   nil)
  (sem_TCC19-1 nil 3732272982 ("" (termination-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (Operator formal-nonempty-type-decl nil semantics nil)
    (RealNumber formal-nonempty-type-decl nil semantics nil)
    (FloatingPointNumber formal-nonempty-type-decl nil semantics nil)
    (FtoR formal-const-decl "[FloatingPointNumber -> RealNumber]"
     semantics nil)
    (FPBExpr type-decl nil expressions nil)
    (pred type-eq-decl nil defined_types nil)
    (strict_total_order? const-decl "bool" orders nil)
    (lt_r formal-const-decl "(strict_total_order?[RealNumber])"
     semantics nil)
    (applyFun_r formal-const-decl
     "[[Operator, RealNumber, RealNumber] -> RealNumber]" semantics
     nil)
    (lt_fp formal-const-decl
     "(strict_total_order?[FloatingPointNumber])" semantics nil)
    (applyFun_fp formal-const-decl
     "[[Operator, FloatingPointNumber, FloatingPointNumber] ->
   FloatingPointNumber]" semantics nil)
    (FPAExprDomain type-decl nil domain nil)
    (RBExpr type-decl nil expressions nil)
    (RAExprDomain type-decl nil domain nil)
    (CEB type-eq-decl nil domain nil) (set type-eq-decl nil sets nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (every adt-def-decl "boolean" list_adt nil)
    (finite_nonempty? const-decl "bool" more_set_defs "sets_aux/")
    (Environment nonempty-type-eq-decl nil semantics nil)
    (validEnvironmentForStmt const-decl "bool" semantics nil)
    (FPStmt type-decl nil program nil)
    (wellFormed? inductive-decl "bool" program nil)
    (Domain type-eq-decl nil domain nil)
    (length def-decl "nat" list_props nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (<< adt-def-decl "(strict_well_founded?[FPStmt])" program nil)
    (appears? const-decl "bool" semantics nil)
    (conditionsHold? const-decl "bool" semantics nil)
    (stable? const-decl "bool" semantics nil)
    (bottomLess? const-decl "bool" semantics nil)
    (appears? const-decl "bool" domain nil)
    (appears? const-decl "bool" domain nil)
    (appears? const-decl "bool" expressions nil)
    (FtoR def-decl "RAExpr" expressions nil)
    (appears? const-decl "bool" expressions nil)
    (conditionsHold? const-decl "bool" semantics nil)
    (conditionsHold? const-decl "bool" semantics nil)
    (stable? const-decl "bool" semantics nil)
    (bottomLess? const-decl "bool" semantics nil)
    (bottomLess? const-decl "bool" semantics nil)
    (/= const-decl "boolean" notequal nil)
    (nonempty? const-decl "bool" sets nil)
    (empty? const-decl "bool" sets nil)
    (member const-decl "bool" sets nil)
    (is_finite const-decl "bool" finite_sets nil)
    (injective? const-decl "bool" functions nil)
    (validDomain const-decl "bool" semantics nil))
   nil))
 (sem_TCC20 0
  (sem_TCC20-4 "" 3753703805
   ("" (skeep* :preds? t)
    (("" (typepred "v(nargs, new_env)(body)")
      (("1" (skeep -2)
        (("1" (inst + "replace_local_var_in_ceb(ceb)(aexpr)")
          (("1" (split +)
            (("1" (rewrite "replace_local_var_dom_ceb") nil nil)
             ("2" (rewrite "replace_local_var_in_ceb_stable_id") nil
              nil))
            nil))
          nil))
        nil)
       ("2" (replace -10 :hide? t)
        (("2" (replace -10 :hide? t)
          (("2" (rewrite "valid_environment_ext")
            (("2" (replace -9 :hide? t)
              (("2" (use "well_formed_letin_expr")
                (("2" (assert) nil nil)) nil))
              nil))
            nil))
          nil))
        nil)
       ("3" (replace -11 :hide? t)
        (("3" (replace -9 :hide? t)
          (("3" (use "well_formed_letin_body")
            (("3" (assert)
              (("3" (expand "length" +)
                (("3" (expand "<<") (("3" (propax) nil nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (<< adt-def-decl "(strict_well_founded?[FPStmt])" program nil)
    (strict_well_founded? const-decl "bool" orders nil)
    (length def-decl "nat" list_props nil)
    (Domain type-eq-decl nil domain nil)
    (wellFormed? inductive-decl "bool" program nil)
    (FPStmt type-decl nil program nil)
    (validEnvironmentForStmt const-decl "bool" semantics nil)
    (Environment nonempty-type-eq-decl nil semantics nil)
    (every adt-def-decl "boolean" list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (finite_nonempty? const-decl "bool" more_set_defs "sets_aux/")
    (set type-eq-decl nil sets nil) (CEB type-eq-decl nil domain nil)
    (RAExprDomain type-decl nil domain nil)
    (RBExpr type-decl nil expressions nil)
    (FPAExprDomain type-decl nil domain nil)
    (applyFun_fp formal-const-decl
     "[[Operator, FloatingPointNumber, FloatingPointNumber] ->
   FloatingPointNumber]" semantics nil)
    (lt_fp formal-const-decl
     "(strict_total_order?[FloatingPointNumber])" semantics nil)
    (applyFun_r formal-const-decl
     "[[Operator, RealNumber, RealNumber] -> RealNumber]" semantics
     nil)
    (lt_r formal-const-decl "(strict_total_order?[RealNumber])"
     semantics nil)
    (strict_total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (FPBExpr type-decl nil expressions nil)
    (FtoR formal-const-decl "[FloatingPointNumber -> RealNumber]"
     semantics nil)
    (FloatingPointNumber formal-nonempty-type-decl nil semantics nil)
    (RealNumber formal-nonempty-type-decl nil semantics nil)
    (Operator formal-nonempty-type-decl nil semantics nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (replace_local_var_in_ceb const-decl "CEB" semantics nil)
    (FPAExpr type-decl nil expressions nil)
    (replace_local_var_in_ceb_stable_id formula-decl nil semantics nil)
    (replace_local_var_dom_ceb formula-decl nil semantics nil)
    (well_formed_letin_expr formula-decl nil program nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (valid_environment_ext formula-decl nil semantics nil)
    (wellFormed? inductive-decl "bool" expressions nil)
    (well_formed_letin_body formula-decl nil program nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil)
  (sem_TCC20-3 "" 3742319084
   ("" (skeep* :preds? t)
    (("" (lemma "well_formed_LETIN_propagation")
      (("" (inst -1 "aexpr" "body" "nargs" "length(env)")
        (("" (grind) nil nil)) nil))
      nil))
    nil)
   ((well_formed_LETIN_propagation formula-decl nil expressions_props
     nil)
    (<< adt-def-decl "(strict_well_founded?[FPStmt])" program nil)
    (Domain type-eq-decl nil domain nil)
    (finite_nonempty? const-decl "bool" more_set_defs "sets_aux/")
    (CEB type-eq-decl nil domain nil)
    (RAExprDomain type-decl nil domain nil)
    (RBExpr type-decl nil expressions nil)
    (FPAExprDomain type-decl nil domain nil)
    (FPBExpr type-decl nil expressions nil)
    (FPStmt type-decl nil program nil)
    (FPAExpr type-decl nil expressions nil))
   nil)
  (sem_TCC20-2 "" 3732647581 ("" (termination-tcc) nil nil)
   ((FPBExpr type-decl nil expressions nil)
    (FPAExprDomain type-decl nil domain nil)
    (RBExpr type-decl nil expressions nil)
    (RAExprDomain type-decl nil domain nil)
    (CEB type-eq-decl nil domain nil)
    (FPStmt type-decl nil program nil)
    (wellFormed? inductive-decl "bool" program nil)
    (Domain type-eq-decl nil domain nil)
    (<< adt-def-decl "(strict_well_founded?[FPStmt])" program nil))
   shostak)
  (sem_TCC20-1 nil 3732272982
   (""
    (with-labels (skeep* :preds? t)
     ((nil nil nil
       "sem of the arithmetic expr is stableConsistent, bottomless, and stable"
       nil nil "env is stableConsistent"
       "LETIN statement is wellformed" "env is bottomless"
       "env is stable" "LETIN structure"
       "semantic of the arithmetic expression" "new environment def"
       "target")))
    ((""
      (hide-all-but
       ("sem of the arithmetic expr is stableConsistent, bottomless, and stable"
        "env is stableConsistent" "LETIN statement is wellformed"
        "env is bottomless" "env is stable" "LETIN structure"
        "semantic of the arithmetic expression" "new environment def"
        "target"))
      (("" (replace "new environment def" :hide? T)
        (("" (split "target")
          (("1" (expand "stableConsistent?" "target")
            (("1"
              (with-labels (skeep "target" :preds? t)
               (("dom is not empty" "dom in new_env")))
              (("1" (expand "member" "dom in new_env")
                (("1" (split "dom in new_env")
                  (("1" (replace "dom in new_env" :hide? t)
                    (("1" (expand "stableConsistent?" "dom in new_env")
                      (("1" (skeep "dom in new_env")
                        (("1"
                          (inst
                           "sem of the arithmetic expr is stableConsistent, bottomless, and stable"
                           "ceb")
                          (("1" (assert) nil nil)) nil))
                        nil))
                      nil))
                    nil)
                   ("2"
                    (expand "stableConsistent?"
                            "env is stableConsistent")
                    (("2" (inst "env is stableConsistent" "dom") nil
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil)
           ("2" (replace "LETIN structure" :hide? T)
            (("2"
              (hide-all-but ("target" "LETIN statement is wellformed"))
              (("2"
                (expand "wellFormed?" "LETIN statement is wellformed")
                (("2" (flatten)
                  (("2" (expand "length" "target")
                    (("2" (propax) nil nil)) nil))
                  nil))
                nil))
              nil))
            nil)
           ("3" (expand "bottomLess?" "target")
            (("3"
              (with-labels (skeep "target" :preds? t)
               (("dom is not empty" "dom in new_env")))
              (("3" (expand "member" "dom in new_env")
                (("3" (split "dom in new_env")
                  (("1" (replace "dom in new_env" :hide? t)
                    (("1" (expand "bottomLess?" "dom in new_env")
                      (("1" (skeep "dom in new_env")
                        (("1"
                          (inst
                           "sem of the arithmetic expr is stableConsistent, bottomless, and stable"
                           "ceb")
                          (("1" (assert) nil nil)) nil))
                        nil))
                      nil))
                    nil)
                   ("2" (expand "bottomLess?" "env is bottomless")
                    (("2" (inst "env is bottomless" "dom") nil nil))
                    nil))
                  nil))
                nil))
              nil))
            nil)
           ("4" (expand "stable?" "target")
            (("4"
              (with-labels (skeep "target" :preds? t)
               (("dom is not empty" "dom in new_env")))
              (("4" (expand "member" "dom in new_env")
                (("4" (split "dom in new_env")
                  (("1" (replace "dom in new_env" :hide? t)
                    (("1" (expand "stable?" "dom in new_env")
                      (("1" (skeep "dom in new_env")
                        (("1"
                          (inst
                           "sem of the arithmetic expr is stableConsistent, bottomless, and stable"
                           "ceb")
                          (("1" (assert) nil nil)) nil))
                        nil))
                      nil))
                    nil)
                   ("2" (expand "stable?" "env is stable")
                    (("2" (inst "env is stable" "dom") nil nil)) nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((well_formed_LETIN_propagation formula-decl nil expressions_props
     nil)
    (Domain type-eq-decl nil domain nil)
    (CEB type-eq-decl nil domain nil)
    (RAExprDomain type-decl nil domain nil)
    (RBExpr type-decl nil expressions nil)
    (FPAExprDomain type-decl nil domain nil)
    (FPBExpr type-decl nil expressions nil)
    (FPStmt type-decl nil program nil)
    (FPAExpr type-decl nil expressions nil))
   shostak))
 (sem_TCC21 0
  (sem_TCC21-3 nil 3753703824
   ("" (skeep :preds? t)
    (("" (replace -5 :hide? t)
      (("" (use "well_formed_letin_expr") (("" (assert) nil nil)) nil))
      nil))
    nil)
   ((real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (FPBExpr type-decl nil expressions nil)
    (pred type-eq-decl nil defined_types nil)
    (strict_total_order? const-decl "bool" orders nil)
    (lt_r formal-const-decl "(strict_total_order?[RealNumber])"
     semantics nil)
    (applyFun_r formal-const-decl
     "[[Operator, RealNumber, RealNumber] -> RealNumber]" semantics
     nil)
    (lt_fp formal-const-decl
     "(strict_total_order?[FloatingPointNumber])" semantics nil)
    (applyFun_fp formal-const-decl
     "[[Operator, FloatingPointNumber, FloatingPointNumber] ->
   FloatingPointNumber]" semantics nil)
    (FPAExprDomain type-decl nil domain nil)
    (RBExpr type-decl nil expressions nil)
    (RAExprDomain type-decl nil domain nil)
    (CEB type-eq-decl nil domain nil) (set type-eq-decl nil sets nil)
    (list type-decl nil list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (every adt-def-decl "boolean" list_adt nil)
    (finite_nonempty? const-decl "bool" more_set_defs "sets_aux/")
    (Domain type-eq-decl nil domain nil)
    (length def-decl "nat" list_props nil)
    (Environment nonempty-type-eq-decl nil semantics nil)
    (validEnvironmentForStmt const-decl "bool" semantics nil)
    (FPAExpr type-decl nil expressions nil)
    (FPStmt type-decl nil program nil)
    (FtoR formal-const-decl "[FloatingPointNumber -> RealNumber]"
     semantics nil)
    (FloatingPointNumber formal-nonempty-type-decl nil semantics nil)
    (RealNumber formal-nonempty-type-decl nil semantics nil)
    (Operator formal-nonempty-type-decl nil semantics nil)
    (well_formed_letin_expr formula-decl nil program nil))
   nil)
  (sem_TCC21-2 nil 3742319063
   ("" (skeep* :preds? t)
    (("" (typepred "v(nargs, new_env)(body)")
      (("1" (skeep -2)
        (("1"
          (inst + "replace_local_var_in_ceb(ceb)(length(env),aexpr)")
          (("1" (split +)
            (("1" (rewrite "replace_local_var_dom_ceb") nil nil)
             ("2" (rewrite "replace_local_var_in_ceb_stable_id") nil
              nil))
            nil))
          nil))
        nil)
       ("2" (hide 3)
        (("2" (replace -10 :hide? t)
          (("2" (replace -10 :hide? t)
            (("2" (rewrite "valid_environment_ext")
              (("2" (replace -9 :hide? t)
                (("2" (use "well_formed_letin_expr")
                  (("2" (assert) nil nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("3" (replace -11 :hide? t)
        (("3" (replace -9 :hide? t)
          (("3" (use "well_formed_letin_body")
            (("3" (assert)
              (("3" (expand "length" +)
                (("3" (expand "<<") (("3" (propax) nil nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((<< adt-def-decl "(strict_well_founded?[FPStmt])" program nil)
    (Domain type-eq-decl nil domain nil)
    (wellFormed? inductive-decl "bool" program nil)
    (FPStmt type-decl nil program nil)
    (finite_nonempty? const-decl "bool" more_set_defs "sets_aux/")
    (CEB type-eq-decl nil domain nil)
    (RAExprDomain type-decl nil domain nil)
    (RBExpr type-decl nil expressions nil)
    (FPAExprDomain type-decl nil domain nil)
    (FPBExpr type-decl nil expressions nil)
    (FPAExpr type-decl nil expressions nil)
    (well_formed_letin_expr formula-decl nil program nil)
    (wellFormed? inductive-decl "bool" expressions nil)
    (well_formed_letin_body formula-decl nil program nil))
   nil)
  (sem_TCC21-1 nil 3732272982
   ("" (skeep :preds? t)
    (("" (expand "wellFormed?" -)
      (("" (assert)
        (("" (flatten) (("" (assert) (("" (grind) nil nil)) nil)) nil))
        nil))
      nil))
    nil)
   ((wellFormed? inductive-decl "bool" program nil)) nil))
 (sem_TCC22 0
  (sem_TCC22-4 nil 3753703836
   ("" (skeep :preds? t)
    (("" (replace -5 :hide? t)
      (("" (rewrite "well_formed_aexpr") nil nil)) nil))
    nil)
   ((FtoR formal-const-decl "[FloatingPointNumber -> RealNumber]"
     semantics nil)
    (FloatingPointNumber formal-nonempty-type-decl nil semantics nil)
    (RealNumber formal-nonempty-type-decl nil semantics nil)
    (Operator formal-nonempty-type-decl nil semantics nil)
    (FPAExpr type-decl nil expressions nil)
    (validEnvironmentForStmt const-decl "bool" semantics nil)
    (Environment nonempty-type-eq-decl nil semantics nil)
    (length def-decl "nat" list_props nil)
    (Domain type-eq-decl nil domain nil)
    (finite_nonempty? const-decl "bool" more_set_defs "sets_aux/")
    (every adt-def-decl "boolean" list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil) (set type-eq-decl nil sets nil)
    (CEB type-eq-decl nil domain nil)
    (RAExprDomain type-decl nil domain nil)
    (RBExpr type-decl nil expressions nil)
    (FPAExprDomain type-decl nil domain nil)
    (applyFun_fp formal-const-decl
     "[[Operator, FloatingPointNumber, FloatingPointNumber] ->
   FloatingPointNumber]" semantics nil)
    (lt_fp formal-const-decl
     "(strict_total_order?[FloatingPointNumber])" semantics nil)
    (applyFun_r formal-const-decl
     "[[Operator, RealNumber, RealNumber] -> RealNumber]" semantics
     nil)
    (lt_r formal-const-decl "(strict_total_order?[RealNumber])"
     semantics nil)
    (strict_total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (FPBExpr type-decl nil expressions nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (well_formed_aexpr formula-decl nil program nil))
   nil)
  (sem_TCC22-3 nil 3742318183
   ("" (skeep :preds? t)
    (("" (replace -5 :hide? t)
      (("" (use "well_formed_letin_expr") (("" (assert) nil nil)) nil))
      nil))
    nil)
   ((FPBExpr type-decl nil expressions nil)
    (FPAExprDomain type-decl nil domain nil)
    (RBExpr type-decl nil expressions nil)
    (RAExprDomain type-decl nil domain nil)
    (CEB type-eq-decl nil domain nil)
    (finite_nonempty? const-decl "bool" more_set_defs "sets_aux/")
    (Domain type-eq-decl nil domain nil)
    (FPAExpr type-decl nil expressions nil)
    (FPStmt type-decl nil program nil)
    (well_formed_letin_expr formula-decl nil program nil))
   nil)
  (sem_TCC22-2 nil 3732701401
   ("" (skeep :preds? t)
    (("" (expand "wellFormed?" -)
      (("" (assert) (("" (grind) nil nil)) nil)) nil))
    nil)
   ((wellFormed? inductive-decl "bool" program nil)
    (<< adt-def-decl "(strict_well_founded?[FPStmt])" program nil))
   nil)
  (sem_TCC22-1 nil 3732272982 ("" (grind) nil nil)
   ((FPStmt type-decl nil program nil)
    (FPProgram type-eq-decl nil program nil)
    (wellFormedProgram? const-decl "bool" program nil))
   shostak))
 (sem_TCC23 0
  (sem_TCC23-1 nil 3754571630
   ("" (skeep :preds? t)
    (("" (typepred "sem(aexpr, nargs, env)")
      (("1" (expand "finite_nonempty?")
        (("1" (flatten)
          (("1" (expand "nonempty?")
            (("1" (expand "empty?")
              (("1" (skolem 1 "ceb")
                (("1" (inst 1 "ceb")
                  (("1" (expand "member")
                    (("1" (assert)
                      (("1" (use "valid_domain__ceb_stable") nil nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (use "well_formed_aexpr") (("2" (assert) nil nil)) nil))
      nil))
    nil)
   ((sem def-decl "(validDomain)" semantics nil)
    (validDomain const-decl "bool" semantics nil)
    (length def-decl "nat" list_props nil)
    (Domain type-eq-decl nil domain nil)
    (wellFormed? inductive-decl "bool" expressions nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (validEnvironmentForStmt const-decl "bool" semantics nil)
    (Environment nonempty-type-eq-decl nil semantics nil)
    (every adt-def-decl "boolean" list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (FPAExpr type-decl nil expressions nil)
    (finite_nonempty? const-decl "bool" more_set_defs "sets_aux/")
    (set type-eq-decl nil sets nil) (CEB type-eq-decl nil domain nil)
    (RAExprDomain type-decl nil domain nil)
    (RBExpr type-decl nil expressions nil)
    (FPAExprDomain type-decl nil domain nil)
    (applyFun_fp formal-const-decl
     "[[Operator, FloatingPointNumber, FloatingPointNumber] ->
   FloatingPointNumber]" semantics nil)
    (lt_fp formal-const-decl
     "(strict_total_order?[FloatingPointNumber])" semantics nil)
    (applyFun_r formal-const-decl
     "[[Operator, RealNumber, RealNumber] -> RealNumber]" semantics
     nil)
    (lt_r formal-const-decl "(strict_total_order?[RealNumber])"
     semantics nil)
    (strict_total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (FPBExpr type-decl nil expressions nil)
    (FtoR formal-const-decl "[FloatingPointNumber -> RealNumber]"
     semantics nil)
    (FloatingPointNumber formal-nonempty-type-decl nil semantics nil)
    (RealNumber formal-nonempty-type-decl nil semantics nil)
    (Operator formal-nonempty-type-decl nil semantics nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (empty? const-decl "bool" sets nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (valid_domain__ceb_stable formula-decl nil semantics nil)
    (member const-decl "bool" sets nil)
    (nonempty? const-decl "bool" sets nil)
    (well_formed_aexpr formula-decl nil program nil))
   nil))
 (built_from_stmt?_TCC1 0
  (built_from_stmt?_TCC1-1 nil 3752581556
   ("" (termination-tcc) nil nil)
   ((<< adt-def-decl "(strict_well_founded?[FPBExpr])" expressions nil)
    (Operator formal-nonempty-type-decl nil semantics nil)
    (RealNumber formal-nonempty-type-decl nil semantics nil)
    (FloatingPointNumber formal-nonempty-type-decl nil semantics nil)
    (FtoR formal-const-decl "[FloatingPointNumber -> RealNumber]"
     semantics nil))
   nil))
 (built_from_stmt?_TCC2 0
  (built_from_stmt?_TCC2-1 nil 3752581556
   ("" (termination-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (Operator formal-nonempty-type-decl nil semantics nil)
    (RealNumber formal-nonempty-type-decl nil semantics nil)
    (FloatingPointNumber formal-nonempty-type-decl nil semantics nil)
    (FtoR formal-const-decl "[FloatingPointNumber -> RealNumber]"
     semantics nil)
    (FPBExpr type-decl nil expressions nil)
    (pred type-eq-decl nil defined_types nil)
    (strict_total_order? const-decl "bool" orders nil)
    (lt_r formal-const-decl "(strict_total_order?[RealNumber])"
     semantics nil)
    (applyFun_r formal-const-decl
     "[[Operator, RealNumber, RealNumber] -> RealNumber]" semantics
     nil)
    (lt_fp formal-const-decl
     "(strict_total_order?[FloatingPointNumber])" semantics nil)
    (applyFun_fp formal-const-decl
     "[[Operator, FloatingPointNumber, FloatingPointNumber] ->
   FloatingPointNumber]" semantics nil)
    (FPAExprDomain type-decl nil domain nil)
    (RBExpr type-decl nil expressions nil)
    (RAExprDomain type-decl nil domain nil)
    (CEB type-eq-decl nil domain nil) (set type-eq-decl nil sets nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (every adt-def-decl "boolean" list_adt nil)
    (finite_nonempty? const-decl "bool" more_set_defs "sets_aux/")
    (Environment nonempty-type-eq-decl nil semantics nil)
    (<< adt-def-decl "(strict_well_founded?[FPBExpr])" expressions
     nil))
   nil))
 (semanticallyConsistent?_TCC1 0
  (semanticallyConsistent?_TCC1-1 nil 3753101977
   ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (Operator formal-nonempty-type-decl nil semantics nil)
    (RealNumber formal-nonempty-type-decl nil semantics nil)
    (FloatingPointNumber formal-nonempty-type-decl nil semantics nil)
    (FtoR formal-const-decl "[FloatingPointNumber -> RealNumber]"
     semantics nil)
    (FPBExpr type-decl nil expressions nil)
    (pred type-eq-decl nil defined_types nil)
    (strict_total_order? const-decl "bool" orders nil)
    (lt_r formal-const-decl "(strict_total_order?[RealNumber])"
     semantics nil)
    (applyFun_r formal-const-decl
     "[[Operator, RealNumber, RealNumber] -> RealNumber]" semantics
     nil)
    (lt_fp formal-const-decl
     "(strict_total_order?[FloatingPointNumber])" semantics nil)
    (applyFun_fp formal-const-decl
     "[[Operator, FloatingPointNumber, FloatingPointNumber] ->
   FloatingPointNumber]" semantics nil)
    (FPAExprDomain type-decl nil domain nil)
    (RBExpr type-decl nil expressions nil)
    (RAExprDomain type-decl nil domain nil)
    (CEB type-eq-decl nil domain nil) (set type-eq-decl nil sets nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (every adt-def-decl "boolean" list_adt nil)
    (finite_nonempty? const-decl "bool" more_set_defs "sets_aux/")
    (Environment nonempty-type-eq-decl nil semantics nil)
    (validEnvironmentForStmt const-decl "bool" semantics nil)
    (minus_odd_is_odd application-judgement "odd_int" integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (ftor_fpvar_rvar_j application-judgement "(RVariable?)" semantics
     nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (appears? const-decl "bool" semantics nil)
    (appears? const-decl "bool" domain nil)
    (appears? const-decl "bool" domain nil)
    (appears? const-decl "bool" expressions nil)
    (appears? const-decl "bool" expressions nil)
    (conditionsHold? const-decl "bool" semantics nil)
    (conditionsHold? const-decl "bool" semantics nil)
    (conditionsHold? const-decl "bool" semantics nil)
    (stable? const-decl "bool" semantics nil)
    (stable? const-decl "bool" semantics nil)
    (bottomLess? const-decl "bool" semantics nil)
    (bottomLess? const-decl "bool" semantics nil)
    (bottomLess? const-decl "bool" semantics nil)
    (/= const-decl "boolean" notequal nil)
    (below type-eq-decl nil naturalnumbers nil)
    (FPLocalEnvironment type-eq-decl nil expressions_semantics nil)
    (size const-decl "nat" u_local_environment nil)
    (LocalEnvironment nonempty-type-decl nil u_local_environment nil)
    (<< adt-def-decl "(strict_well_founded?[FPAExpr])" expressions nil)
    (strict_well_founded? const-decl "bool" orders nil)
    (fpVarIndex const-decl "nat" expressions_semantics nil)
    (FPVariable? adt-recognizer-decl "[FPAExpr -> boolean]" expressions
     nil)
    (FPAExpr type-decl nil expressions nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (< const-decl "bool" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil))
 (semanticallyConsistent?_TCC2 0
  (semanticallyConsistent?_TCC2-1 nil 3754418714
   ("" (skeep* :preds? t)
    (("" (split 1)
      (("1" (rewrite "valid_environment_shortening") nil nil)
       ("2" (rewrite "takeFromRight_length") (("2" (assert) nil nil))
        nil))
      nil))
    nil)
   ((below type-eq-decl nil naturalnumbers nil)
    (FPLocalEnvironment type-eq-decl nil expressions_semantics nil)
    (size const-decl "nat" u_local_environment nil)
    (LocalEnvironment nonempty-type-decl nil u_local_environment nil)
    (<< adt-def-decl "(strict_well_founded?[FPAExpr])" expressions nil)
    (strict_well_founded? const-decl "bool" orders nil)
    (fpVarIndex const-decl "nat" expressions_semantics nil)
    (FPVariable? adt-recognizer-decl "[FPAExpr -> boolean]" expressions
     nil)
    (FPAExpr type-decl nil expressions nil)
    (< const-decl "bool" reals nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (length def-decl "nat" list_props nil)
    (Domain type-eq-decl nil domain nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (validEnvironmentForStmt const-decl "bool" semantics nil)
    (Environment nonempty-type-eq-decl nil semantics nil)
    (finite_nonempty? const-decl "bool" more_set_defs "sets_aux/")
    (every adt-def-decl "boolean" list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil) (set type-eq-decl nil sets nil)
    (CEB type-eq-decl nil domain nil)
    (RAExprDomain type-decl nil domain nil)
    (RBExpr type-decl nil expressions nil)
    (FPAExprDomain type-decl nil domain nil)
    (applyFun_fp formal-const-decl
     "[[Operator, FloatingPointNumber, FloatingPointNumber] ->
   FloatingPointNumber]" semantics nil)
    (lt_fp formal-const-decl
     "(strict_total_order?[FloatingPointNumber])" semantics nil)
    (applyFun_r formal-const-decl
     "[[Operator, RealNumber, RealNumber] -> RealNumber]" semantics
     nil)
    (lt_r formal-const-decl "(strict_total_order?[RealNumber])"
     semantics nil)
    (strict_total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (FPBExpr type-decl nil expressions nil)
    (FtoR formal-const-decl "[FloatingPointNumber -> RealNumber]"
     semantics nil)
    (FloatingPointNumber formal-nonempty-type-decl nil semantics nil)
    (RealNumber formal-nonempty-type-decl nil semantics nil)
    (Operator formal-nonempty-type-decl nil semantics nil)
    (valid_environment_shortening formula-decl nil semantics nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (<= const-decl "bool" reals nil)
    (takeFromRight_length formula-decl nil more_list_props
     "structures/")
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil))
 (semanticallyConsistent?_TCC3 0
  (semanticallyConsistent?_TCC3-1 nil 3754418714
   ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (Operator formal-nonempty-type-decl nil semantics nil)
    (RealNumber formal-nonempty-type-decl nil semantics nil)
    (FloatingPointNumber formal-nonempty-type-decl nil semantics nil)
    (FtoR formal-const-decl "[FloatingPointNumber -> RealNumber]"
     semantics nil)
    (FPBExpr type-decl nil expressions nil)
    (pred type-eq-decl nil defined_types nil)
    (strict_total_order? const-decl "bool" orders nil)
    (lt_r formal-const-decl "(strict_total_order?[RealNumber])"
     semantics nil)
    (applyFun_r formal-const-decl
     "[[Operator, RealNumber, RealNumber] -> RealNumber]" semantics
     nil)
    (lt_fp formal-const-decl
     "(strict_total_order?[FloatingPointNumber])" semantics nil)
    (applyFun_fp formal-const-decl
     "[[Operator, FloatingPointNumber, FloatingPointNumber] ->
   FloatingPointNumber]" semantics nil)
    (FPAExprDomain type-decl nil domain nil)
    (RBExpr type-decl nil expressions nil)
    (RAExprDomain type-decl nil domain nil)
    (CEB type-eq-decl nil domain nil) (set type-eq-decl nil sets nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (every adt-def-decl "boolean" list_adt nil)
    (finite_nonempty? const-decl "bool" more_set_defs "sets_aux/")
    (Environment nonempty-type-eq-decl nil semantics nil)
    (validEnvironmentForStmt const-decl "bool" semantics nil)
    (minus_odd_is_odd application-judgement "odd_int" integers nil)
    (below type-eq-decl nil naturalnumbers nil)
    (FPLocalEnvironment type-eq-decl nil expressions_semantics nil)
    (size const-decl "nat" u_local_environment nil)
    (LocalEnvironment nonempty-type-decl nil u_local_environment nil)
    (<< adt-def-decl "(strict_well_founded?[FPAExpr])" expressions nil)
    (strict_well_founded? const-decl "bool" orders nil)
    (fpVarIndex const-decl "nat" expressions_semantics nil)
    (FPVariable? adt-recognizer-decl "[FPAExpr -> boolean]" expressions
     nil)
    (FPAExpr type-decl nil expressions nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (< const-decl "bool" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil))
 (empty_env_are_semantically_consistent_TCC1 0
  (empty_env_are_semantically_consistent_TCC1-1 nil 3754148152
   ("" (grind) nil nil)
   ((injective? const-decl "bool" functions nil)
    (is_finite const-decl "bool" finite_sets nil)
    (member const-decl "bool" sets nil)
    (empty? const-decl "bool" sets nil)
    (nonempty? const-decl "bool" sets nil)
    (FPBExpr type-decl nil expressions nil)
    (FPAExprDomain type-decl nil domain nil)
    (RBExpr type-decl nil expressions nil)
    (RAExprDomain type-decl nil domain nil)
    (CEB type-eq-decl nil domain nil) (set type-eq-decl nil sets nil)
    (finite_nonempty? const-decl "bool" more_set_defs "sets_aux/")
    (Domain type-eq-decl nil domain nil)
    (list type-decl nil list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (every adt-def-decl "boolean" list_adt nil)
    (member def-decl "bool" list_props nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (FPAExpr type-decl nil expressions nil)
    (FPVariable? adt-recognizer-decl "[FPAExpr -> boolean]" expressions
     nil)
    (bounded_by? def-decl "bool" expressions_semantics nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (consistentLocalEnvironments? const-decl "bool"
     expressions_semantics nil)
    (RLocalEnvironment type-eq-decl nil expressions_semantics nil)
    (<< adt-def-decl "(strict_well_founded?[RAExpr])" expressions nil)
    (rVarIndex const-decl "nat" expressions_semantics nil)
    (RVariable? adt-recognizer-decl "[RAExpr -> boolean]" expressions
     nil)
    (RAExpr type-decl nil expressions nil)
    (bounded_by? def-decl "bool" expressions_semantics nil)
    (FPLocalEnvironment type-eq-decl nil expressions_semantics nil)
    (LocalEnvironment nonempty-type-decl nil u_local_environment nil)
    (<< adt-def-decl "(strict_well_founded?[FPAExpr])" expressions nil)
    (strict_well_founded? const-decl "bool" orders nil)
    (fpVarIndex const-decl "nat" expressions_semantics nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (emptyEnv const-decl "Environment" semantics nil)
    (/= const-decl "boolean" notequal nil)
    (bottomLess? const-decl "bool" semantics nil)
    (bottomLess? const-decl "bool" semantics nil)
    (bottomLess? const-decl "bool" semantics nil)
    (stable? const-decl "bool" semantics nil)
    (stable? const-decl "bool" semantics nil)
    (conditionsHold? const-decl "bool" semantics nil)
    (conditionsHold? const-decl "bool" semantics nil)
    (conditionsHold? const-decl "bool" semantics nil)
    (FtoR formal-const-decl "[FloatingPointNumber -> RealNumber]"
     semantics nil)
    (FloatingPointNumber formal-nonempty-type-decl nil semantics nil)
    (RealNumber formal-nonempty-type-decl nil semantics nil)
    (Operator formal-nonempty-type-decl nil semantics nil)
    (appears? const-decl "bool" expressions nil)
    (FtoR def-decl "RAExpr" expressions nil)
    (appears? const-decl "bool" expressions nil)
    (applyFun_fp formal-const-decl
     "[[Operator, FloatingPointNumber, FloatingPointNumber] ->
   FloatingPointNumber]" semantics nil)
    (lt_fp formal-const-decl
     "(strict_total_order?[FloatingPointNumber])" semantics nil)
    (applyFun_r formal-const-decl
     "[[Operator, RealNumber, RealNumber] -> RealNumber]" semantics
     nil)
    (lt_r formal-const-decl "(strict_total_order?[RealNumber])"
     semantics nil)
    (strict_total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (appears? const-decl "bool" domain nil)
    (appears? const-decl "bool" domain nil)
    (appears? const-decl "bool" semantics nil)
    (validEnvironmentForStmt const-decl "bool" semantics nil))
   nil))
 (empty_env_are_semantically_consistent 0
  (empty_env_are_semantically_consistent-1 nil 3755001605
   ("" (grind) nil nil)
   ((NOT const-decl "[bool -> bool]" booleans nil)
    (< const-decl "bool" reals nil)
    (LocalEnvironment nonempty-type-decl nil u_local_environment nil)
    (size const-decl "nat" u_local_environment nil)
    (empty_local_env const-decl "LocalEnvironment" u_local_environment
     nil)
    (below type-eq-decl nil naturalnumbers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (emptyEnv const-decl "Environment" semantics nil)
    (FtoR formal-const-decl "[FloatingPointNumber -> RealNumber]"
     semantics nil)
    (applyFun_fp formal-const-decl
     "[[Operator, FloatingPointNumber, FloatingPointNumber] ->
   FloatingPointNumber]" semantics nil)
    (lt_fp formal-const-decl
     "(strict_total_order?[FloatingPointNumber])" semantics nil)
    (FloatingPointNumber formal-nonempty-type-decl nil semantics nil)
    (applyFun_r formal-const-decl
     "[[Operator, RealNumber, RealNumber] -> RealNumber]" semantics
     nil)
    (lt_r formal-const-decl "(strict_total_order?[RealNumber])"
     semantics nil)
    (strict_total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (RealNumber formal-nonempty-type-decl nil semantics nil)
    (Operator formal-nonempty-type-decl nil semantics nil)
    (FPEmptyLocalEnv const-decl "FPLocalEnvironment"
     expressions_semantics nil)
    (length def-decl "nat" list_props nil)
    (<< adt-def-decl "(strict_well_founded?[FPAExpr])" expressions nil)
    (strict_well_founded? const-decl "bool" orders nil)
    (fpVarIndex const-decl "nat" expressions_semantics nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (FPVariable? adt-recognizer-decl "[FPAExpr -> boolean]" expressions
     nil)
    (FPAExpr type-decl nil expressions nil)
    (size_empty formula-decl nil u_local_environment nil)
    (takeFromRight def-decl "list[T]" more_list_props "structures/")
    (semanticallyConsistent? const-decl "bool" semantics nil))
   shostak))
 (semantically_consistent_ext_TCC1 0
  (semantically_consistent_ext_TCC1-1 nil 3753101977
   ("" (skeep)
    (("" (use "valid_environment_extension") (("" (assert) nil nil))
      nil))
    nil)
   ((valid_environment_extension formula-decl nil semantics nil)
    (sem def-decl "(validDomain)" semantics nil)
    (validDomain const-decl "bool" semantics nil)
    (length def-decl "nat" list_props nil)
    (wellFormed? inductive-decl "bool" expressions nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (FPAExpr type-decl nil expressions nil)
    (Domain type-eq-decl nil domain nil)
    (validEnvironmentForStmt const-decl "bool" semantics nil)
    (Environment nonempty-type-eq-decl nil semantics nil)
    (finite_nonempty? const-decl "bool" more_set_defs "sets_aux/")
    (every adt-def-decl "boolean" list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil) (set type-eq-decl nil sets nil)
    (CEB type-eq-decl nil domain nil)
    (RAExprDomain type-decl nil domain nil)
    (RBExpr type-decl nil expressions nil)
    (FPAExprDomain type-decl nil domain nil)
    (applyFun_fp formal-const-decl
     "[[Operator, FloatingPointNumber, FloatingPointNumber] ->
   FloatingPointNumber]" semantics nil)
    (lt_fp formal-const-decl
     "(strict_total_order?[FloatingPointNumber])" semantics nil)
    (applyFun_r formal-const-decl
     "[[Operator, RealNumber, RealNumber] -> RealNumber]" semantics
     nil)
    (lt_r formal-const-decl "(strict_total_order?[RealNumber])"
     semantics nil)
    (strict_total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (FPBExpr type-decl nil expressions nil)
    (FtoR formal-const-decl "[FloatingPointNumber -> RealNumber]"
     semantics nil)
    (FloatingPointNumber formal-nonempty-type-decl nil semantics nil)
    (RealNumber formal-nonempty-type-decl nil semantics nil)
    (Operator formal-nonempty-type-decl nil semantics nil))
   nil))
 (semantically_consistent_ext_TCC2 0
  (semantically_consistent_ext_TCC2-1 nil 3755693132
   ("" (skeep :preds? t)
    (("" (use "evaluable_in_fpaexpr_wellformed_eq")
      (("" (replace -1 :hide? t)
        (("" (expand "semanticallyConsistent?")
          (("" (flatten)
            (("" (replace -5 :hide? t) (("" (inst? 1) nil nil)) nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((evaluable_in_fpaexpr_wellformed_eq formula-decl nil
     expressions_semantics nil)
    (Operator formal-nonempty-type-decl nil semantics nil)
    (RealNumber formal-nonempty-type-decl nil semantics nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (pred type-eq-decl nil defined_types nil)
    (strict_total_order? const-decl "bool" orders nil)
    (lt_r formal-const-decl "(strict_total_order?[RealNumber])"
     semantics nil)
    (applyFun_r formal-const-decl
     "[[Operator, RealNumber, RealNumber] -> RealNumber]" semantics
     nil)
    (FloatingPointNumber formal-nonempty-type-decl nil semantics nil)
    (lt_fp formal-const-decl
     "(strict_total_order?[FloatingPointNumber])" semantics nil)
    (applyFun_fp formal-const-decl
     "[[Operator, FloatingPointNumber, FloatingPointNumber] ->
   FloatingPointNumber]" semantics nil)
    (FtoR formal-const-decl "[FloatingPointNumber -> RealNumber]"
     semantics nil)
    (validEnvironmentForStmt const-decl "bool" semantics nil)
    (Environment nonempty-type-eq-decl nil semantics nil)
    (length def-decl "nat" list_props nil)
    (Domain type-eq-decl nil domain nil)
    (finite_nonempty? const-decl "bool" more_set_defs "sets_aux/")
    (every adt-def-decl "boolean" list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil) (set type-eq-decl nil sets nil)
    (CEB type-eq-decl nil domain nil)
    (RAExprDomain type-decl nil domain nil)
    (RBExpr type-decl nil expressions nil)
    (FPAExprDomain type-decl nil domain nil)
    (FPBExpr type-decl nil expressions nil)
    (wellFormed? inductive-decl "bool" expressions nil)
    (FPLocalEnvironment type-eq-decl nil expressions_semantics nil)
    (LocalEnvironment nonempty-type-decl nil u_local_environment nil)
    (<< adt-def-decl "(strict_well_founded?[FPAExpr])" expressions nil)
    (strict_well_founded? const-decl "bool" orders nil)
    (fpVarIndex const-decl "nat" expressions_semantics nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (FPVariable? adt-recognizer-decl "[FPAExpr -> boolean]" expressions
     nil)
    (FPAExpr type-decl nil expressions nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (semanticallyConsistent? const-decl "bool" semantics nil)
    (minus_odd_is_odd application-judgement "odd_int" integers nil))
   nil))
 (semantically_consistent_ext 0
  (semantically_consistent_ext-2 "" 3754419242
   ("" (skeep :preds? t)
    (("" (expand "semanticallyConsistent?")
      (("" (flatten)
        (("" (case "bounded_by?(fpLocalEnv)(aexpr)")
          (("1" (assert)
            (("1" (hide -1)
              (("1" (split 1)
                (("1" (assert)
                  (("1" (expand "length" 1) (("1" (propax) nil nil))
                    nil))
                  nil)
                 ("2" (skeep 1 :preds? t)
                  (("2" (case "i=0")
                    (("1" (replace -1 :hide? t)
                      (("1" (inst 1 "nargs")
                        (("1" (rewrite "get_last_added")
                          (("1" (split 1)
                            (("1" (expand "length" 1)
                              (("1" (propax) nil nil)) nil)
                             ("2" (expand "nth" 1)
                              (("2"
                                (expand "length" 1)
                                (("2"
                                  (rewrite "takeFromRight_decreasing")
                                  (("2"
                                    (expand "takeFromRight")
                                    (("2" (propax) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil)
                     ("2" (inst -7 "i-1")
                      (("1" (skolem -7 "nargs2")
                        (("1" (flatten)
                          (("1" (inst 2 "nargs2")
                            (("1" (rewrite "get_env_monotonocity")
                              (("1"
                                (split 2)
                                (("1"
                                  (lemma
                                   "wellFormed?_fpaexpr_monotonocity")
                                  (("1"
                                    (inst
                                     -1
                                     "get(fpLocalEnv)(i-1)"
                                     "nargs2"
                                     "length(env)")
                                    (("1"
                                      (assert)
                                      (("1"
                                        (expand "length" 1 1)
                                        (("1" (propax) nil nil))
                                        nil))
                                      nil)
                                     ("2" (assert) nil nil))
                                    nil))
                                  nil)
                                 ("2"
                                  (expand "length" 1)
                                  (("2"
                                    (assert)
                                    (("2"
                                      (expand "nth" 1)
                                      (("2"
                                        (rewrite
                                         "takeFromRight_decreasing")
                                        nil
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil)
                       ("2" (assert) nil nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil)
           ("2" (hide 2)
            (("2" (use "evaluable_in_fpaexpr_wellformed_eq")
              (("2" (replace -1 :hide? t)
                (("2" (replace -5 :hide? t) (("2" (inst? 1) nil nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((int_minus_int_is_int application-judgement "int" integers nil)
    (semanticallyConsistent? const-decl "bool" semantics nil)
    (validEnvironmentForStmt const-decl "bool" semantics nil)
    (Environment nonempty-type-eq-decl nil semantics nil)
    (length def-decl "nat" list_props nil)
    (Domain type-eq-decl nil domain nil)
    (finite_nonempty? const-decl "bool" more_set_defs "sets_aux/")
    (every adt-def-decl "boolean" list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil) (set type-eq-decl nil sets nil)
    (CEB type-eq-decl nil domain nil)
    (RAExprDomain type-decl nil domain nil)
    (RBExpr type-decl nil expressions nil)
    (FPAExprDomain type-decl nil domain nil)
    (FPBExpr type-decl nil expressions nil)
    (wellFormed? inductive-decl "bool" expressions nil)
    (FPLocalEnvironment type-eq-decl nil expressions_semantics nil)
    (bounded_by? const-decl "bool" u_local_environment nil)
    (LocalEnvironment nonempty-type-decl nil u_local_environment nil)
    (<< adt-def-decl "(strict_well_founded?[FPAExpr])" expressions nil)
    (strict_well_founded? const-decl "bool" orders nil)
    (fpVarIndex const-decl "nat" expressions_semantics nil)
    (applyFun_fp formal-const-decl
     "[[Operator, FloatingPointNumber, FloatingPointNumber] ->
   FloatingPointNumber]" semantics nil)
    (lt_fp formal-const-decl
     "(strict_total_order?[FloatingPointNumber])" semantics nil)
    (applyFun_r formal-const-decl
     "[[Operator, RealNumber, RealNumber] -> RealNumber]" semantics
     nil)
    (lt_r formal-const-decl "(strict_total_order?[RealNumber])"
     semantics nil)
    (strict_total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (FPVariable? adt-recognizer-decl "[FPAExpr -> boolean]" expressions
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (FPAExpr type-decl nil expressions nil)
    (FtoR formal-const-decl "[FloatingPointNumber -> RealNumber]"
     semantics nil)
    (FloatingPointNumber formal-nonempty-type-decl nil semantics nil)
    (RealNumber formal-nonempty-type-decl nil semantics nil)
    (Operator formal-nonempty-type-decl nil semantics nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (i skolem-const-decl "below(size(cons(aexpr, fpLocalEnv)))"
     semantics nil)
    (fpLocalEnv skolem-const-decl "FPLocalEnvironment
    [Operator, RealNumber, lt_r, applyFun_r, FloatingPointNumber, lt_fp,
     applyFun_fp, FtoR]" semantics nil)
    (aexpr skolem-const-decl
     "{aexpr: FPAExpr | wellFormed?(aexpr, nargs, length(env))}"
     semantics nil)
    (env skolem-const-decl "(validEnvironmentForStmt)" semantics nil)
    (nargs skolem-const-decl "nat" semantics nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (get_env_monotonocity formula-decl nil u_local_environment nil)
    (wellFormed?_fpaexpr_monotonocity formula-decl nil expressions nil)
    (get const-decl "T" u_local_environment nil)
    (get_last_added formula-decl nil u_local_environment nil)
    (nth def-decl "T" list_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (<= const-decl "bool" reals nil)
    (sem def-decl "(validDomain)" semantics nil)
    (validDomain const-decl "bool" semantics nil)
    (takeFromRight_decreasing formula-decl nil more_list_props
     "structures/")
    (takeFromRight def-decl "list[T]" more_list_props "structures/")
    (= const-decl "[T, T -> boolean]" equalities nil)
    (< const-decl "bool" reals nil)
    (size const-decl "nat" u_local_environment nil)
    (cons const-decl "LocalEnvironment" u_local_environment nil)
    (below type-eq-decl nil naturalnumbers nil)
    (size_cons_def formula-decl nil u_local_environment nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (evaluable_in_fpaexpr_wellformed_eq formula-decl nil
     expressions_semantics nil)
    (minus_odd_is_odd application-judgement "odd_int" integers nil))
   shostak)
  (semantically_consistent_ext-1 nil 3754162108
   ("" (skeep :preds? t)
    (("" (expand "semanticallyConsistent?")
      (("" (flatten)
        (("" (split 1)
          (("1" (assert)
            (("1" (expand "length" 1) (("1" (propax) nil nil)) nil))
            nil)
           ("2" (skeep 1 :preds? t)
            (("2" (case "i < size(fpLocalEnv)")
              (("1" (hide -2)
                (("1" (inst -7 "i")
                  (("1" (skeep -7)
                    (("1" (inst 1 "nargs!1")
                      (("1" (split 1)
                        (("1"
                          (lemma "wellFormed?_fpaexpr_monotonocity")
                          (("1"
                            (inst -1 "get(fpLocalEnv)(i)" "nargs!1"
                             "length(env)")
                            (("1" (assert)
                              (("1"
                                (inst
                                 -1
                                 "nargs!1"
                                 "length(cons(sem(aexpr, nargs, env), env))")
                                (("1"
                                  (rewrite "get_env_monotonocity")
                                  nil
                                  nil)
                                 ("2"
                                  (expand "length" 1 1)
                                  (("2" (assert) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil)
                         ("2" (rewrite "get_env_monotonocity")
                          (("2"
                            (rewrite
                             "get_from_semantic_environment_monotonocity")
                            (("2" (replace -8 :hide? t :dir rl)
                              (("2"
                                (use "sem_expr_larger_env")
                                (("2" (assert) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("2" (case "i = size(fpLocalEnv)")
                (("1" (hide 1)
                  (("1" (hide -2)
                    (("1" (hide -7)
                      (("1" (replace -1 :hide? t)
                        (("1" (inst 1 "nargs")
                          (("1" (rewrite "fp_local_env.get_last_added")
                            (("1" (replace -5 :dir rl)
                              (("1"
                                (expand "length" 1 2)
                                (("1"
                                  (expand "nth" 1)
                                  (("1"
                                    (split 1)
                                    (("1"
                                      (lemma
                                       "wellFormed?_fpaexpr_monotonocity")
                                      (("1"
                                        (inst? -1 :where -5)
                                        (("1"
                                          (assert)
                                          (("1"
                                            (inst? -1)
                                            (("1"
                                              (expand "length" 1 1)
                                              (("1" (assert) nil nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil)
                                     ("2"
                                      (use "sem_expr_larger_env")
                                      (("2" (assert) nil nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (assert) nil nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((<< adt-def-decl "(strict_well_founded?[FPAExpr])" expressions nil)
    (index shared-adt-accessor-decl
           "[{x: FPAExpr | FPVariable?(x) OR FPParameter?(x)} -> DeBruijnIndex]"
           expressions nil)
    (DeBruijnIndex nonempty-type-eq-decl nil expressions nil)
    (FPParameter? adt-recognizer-decl "[FPAExpr -> boolean]"
     expressions nil)
    (fpVarIndex const-decl "nat" expressions_semantics nil)
    (FPVariable? adt-recognizer-decl "[FPAExpr -> boolean]" expressions
     nil)
    (FPAExpr type-decl nil expressions nil)
    (size_cons_def formula-decl nil u_local_environment nil)
    (FPLocalEnvironment type-eq-decl nil expressions_semantics nil)
    (Domain type-eq-decl nil domain nil)
    (finite_nonempty? const-decl "bool" more_set_defs "sets_aux/")
    (CEB type-eq-decl nil domain nil)
    (RAExprDomain type-decl nil domain nil)
    (RBExpr type-decl nil expressions nil)
    (FPAExprDomain type-decl nil domain nil)
    (FPBExpr type-decl nil expressions nil)
    (wellFormed? inductive-decl "bool" expressions nil)
    (cons const-decl "LocalEnvironment" u_local_environment nil)
    (size const-decl "nat" u_local_environment nil)
    (LocalEnvironment nonempty-type-decl nil u_local_environment nil)
    (wellFormed?_fpaexpr_monotonocity formula-decl nil expressions nil)
    (get const-decl "T" u_local_environment nil))
   shostak))
 (max_local_index_evaluable_in__form 0
  (max_local_index_evaluable_in__form-1 nil 3755001294
   ("" (skeep)
    (("" (use "evaluable_in_wellformed_eq")
      (("" (replace -1 :hide? t)
        (("" (lemma "wellFormed?_form_int_def")
          ((""
            (inst -1 "form" "maxParamIndex(form)+1" "size(fpLocalEnv)")
            (("1" (assert) (("1" (inst?) nil nil)) nil)
             ("2" (assert) nil nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((evaluable_in_wellformed_eq formula-decl nil expressions_semantics
     nil)
    (Operator formal-nonempty-type-decl nil semantics nil)
    (RealNumber formal-nonempty-type-decl nil semantics nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (pred type-eq-decl nil defined_types nil)
    (strict_total_order? const-decl "bool" orders nil)
    (lt_r formal-const-decl "(strict_total_order?[RealNumber])"
     semantics nil)
    (applyFun_r formal-const-decl
     "[[Operator, RealNumber, RealNumber] -> RealNumber]" semantics
     nil)
    (FloatingPointNumber formal-nonempty-type-decl nil semantics nil)
    (lt_fp formal-const-decl
     "(strict_total_order?[FloatingPointNumber])" semantics nil)
    (applyFun_fp formal-const-decl
     "[[Operator, FloatingPointNumber, FloatingPointNumber] ->
   FloatingPointNumber]" semantics nil)
    (FtoR formal-const-decl "[FloatingPointNumber -> RealNumber]"
     semantics nil)
    (FPBExpr type-decl nil expressions nil)
    (FPLocalEnvironment type-eq-decl nil expressions_semantics nil)
    (LocalEnvironment nonempty-type-decl nil u_local_environment nil)
    (<< adt-def-decl "(strict_well_founded?[FPAExpr])" expressions nil)
    (strict_well_founded? const-decl "bool" orders nil)
    (fpVarIndex const-decl "nat" expressions_semantics nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (FPVariable? adt-recognizer-decl "[FPAExpr -> boolean]" expressions
     nil)
    (FPAExpr type-decl nil expressions nil)
    (wellFormed?_form_int_def formula-decl nil expressions nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (size const-decl "nat" u_local_environment nil)
    (form skolem-const-decl
     "FPBExpr[Operator, RealNumber, FloatingPointNumber, FtoR]"
     semantics nil)
    (maxParamIndex def-decl "upfrom(-1)" expressions nil)
    (upfrom nonempty-type-eq-decl nil integers nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (minus_odd_is_odd application-judgement "odd_int" integers nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil))
   shostak))
 (max_local_index_evaluable_in__rform 0
  (max_local_index_evaluable_in__rform-1 nil 3755352541
   ("" (skeep)
    (("" (use "evaluable_in_r_wellformed_eq")
      (("" (replace -1 :hide? t)
        (("" (lemma "wellFormed?_rform_int_def")
          ((""
            (inst -1 "maxParamIndex(rform)+1" "size(rLocalEnv)"
             "rform")
            (("1" (assert) (("1" (inst?) nil nil)) nil)
             ("2" (assert) nil nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((evaluable_in_r_wellformed_eq formula-decl nil
     expressions_semantics nil)
    (Operator formal-nonempty-type-decl nil semantics nil)
    (RealNumber formal-nonempty-type-decl nil semantics nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (pred type-eq-decl nil defined_types nil)
    (strict_total_order? const-decl "bool" orders nil)
    (lt_r formal-const-decl "(strict_total_order?[RealNumber])"
     semantics nil)
    (applyFun_r formal-const-decl
     "[[Operator, RealNumber, RealNumber] -> RealNumber]" semantics
     nil)
    (FloatingPointNumber formal-nonempty-type-decl nil semantics nil)
    (lt_fp formal-const-decl
     "(strict_total_order?[FloatingPointNumber])" semantics nil)
    (applyFun_fp formal-const-decl
     "[[Operator, FloatingPointNumber, FloatingPointNumber] ->
   FloatingPointNumber]" semantics nil)
    (FtoR formal-const-decl "[FloatingPointNumber -> RealNumber]"
     semantics nil)
    (RBExpr type-decl nil expressions nil)
    (RLocalEnvironment type-eq-decl nil expressions_semantics nil)
    (LocalEnvironment nonempty-type-decl nil u_local_environment nil)
    (<< adt-def-decl "(strict_well_founded?[RAExpr])" expressions nil)
    (strict_well_founded? const-decl "bool" orders nil)
    (rVarIndex const-decl "nat" expressions_semantics nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (RVariable? adt-recognizer-decl "[RAExpr -> boolean]" expressions
     nil)
    (RAExpr type-decl nil expressions nil)
    (wellFormed?_rform_int_def formula-decl nil expressions nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (size const-decl "nat" u_local_environment nil)
    (rform skolem-const-decl
     "RBExpr[Operator, RealNumber, FloatingPointNumber, FtoR]"
     semantics nil)
    (maxParamIndex def-decl "upfrom(-1)" expressions nil)
    (upfrom nonempty-type-eq-decl nil integers nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (minus_odd_is_odd application-judgement "odd_int" integers nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil))
   nil))
 (evaluable_in_max_local_index__stmt 0
  (evaluable_in_max_local_index__stmt-1 nil 3754231768
   ("" (skeep* :preds? t)
    (("" (use "evaluable_in_stmt_wellformed_eq")
      (("" (replace -1 :hide? t)
        (("" (skeep)
          (("" (rewrite "well_formed_int_def") (("" (assert) nil nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((evaluable_in_stmt_wellformed_eq formula-decl nil semantics nil)
    (FPStmt type-decl nil program nil)
    (FPLocalEnvironment type-eq-decl nil expressions_semantics nil)
    (LocalEnvironment nonempty-type-decl nil u_local_environment nil)
    (<< adt-def-decl "(strict_well_founded?[FPAExpr])" expressions nil)
    (strict_well_founded? const-decl "bool" orders nil)
    (fpVarIndex const-decl "nat" expressions_semantics nil)
    (applyFun_fp formal-const-decl
     "[[Operator, FloatingPointNumber, FloatingPointNumber] ->
   FloatingPointNumber]" semantics nil)
    (lt_fp formal-const-decl
     "(strict_total_order?[FloatingPointNumber])" semantics nil)
    (applyFun_r formal-const-decl
     "[[Operator, RealNumber, RealNumber] -> RealNumber]" semantics
     nil)
    (lt_r formal-const-decl "(strict_total_order?[RealNumber])"
     semantics nil)
    (strict_total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (FPVariable? adt-recognizer-decl "[FPAExpr -> boolean]" expressions
     nil)
    (FPAExpr type-decl nil expressions nil)
    (FtoR formal-const-decl "[FloatingPointNumber -> RealNumber]"
     semantics nil)
    (FloatingPointNumber formal-nonempty-type-decl nil semantics nil)
    (RealNumber formal-nonempty-type-decl nil semantics nil)
    (Operator formal-nonempty-type-decl nil semantics nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (size const-decl "nat" u_local_environment nil)
    (well_formed_int_def formula-decl nil program nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   shostak))
 (appears_free_fpconds_expr 0
  (appears_free_fpconds_expr-1 nil 3754560500
   ("" (induct "expr")
    (("1" (skolem 1 "ct")
      (("1" (skeep* :preds? t)
        (("1" (expand "sem" -)
          (("1" (expand "singleton" -7)
            (("1" (expand "make_ceb")
              (("1" (replace -7 :hide? t)
                (("1" (assert)
                  (("1" (expand "appears?" -7)
                    (("1" (expand "appearsFree?" -7)
                      (("1" (propax) nil nil)) nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("2" (skolem 1 "vr")
      (("2" (skeep* :preds? t)
        (("2" (rewrite "sem_expr_var_fpconds")
          (("2" (expand "appears?" 2)
            (("2" (expand "appears?" 2)
              (("2" (expand "appears?" 2)
                (("2" (inst 2 "nth(env,vr)")
                  (("1" (inst 2 "ceb") (("1" (assert) nil nil)) nil)
                   ("2" (use "nth_member[Domain]") nil nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("3" (skolem 1 "idx")
      (("3" (skeep* :preds? t)
        (("3" (expand "sem" -)
          (("3" (expand "singleton" -7)
            (("3" (expand "make_ceb")
              (("3" (replace -7 :hide? t)
                (("3" (assert)
                  (("3" (expand "appears?" -7)
                    (("3" (expand "appearsFree?" -7)
                      (("3" (propax) nil nil)) nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("4" (skolem 1 ("op" "a1" "a2"))
      (("4" (flatten)
        (("4" (skeep* :preds? t)
          (("4" (use "sem_expr_opr_fpconds")
            (("4" (assert)
              (("4" (skeep -1 :preds? t)
                (("4" (replace -3 :hide? t)
                  (("4" (expand "appears?" 1)
                    (("4" (expand "appearsFree?" 1)
                      (("4" (flatten)
                        (("4" (inst -7 "nargs" "env" "ceb1")
                          (("4" (inst -8 "nargs" "env" "ceb2")
                            (("4" (assert)
                              (("4"
                                (use "wellFormed?_expr_op")
                                (("4"
                                  (assert)
                                  (("4"
                                    (flatten)
                                    (("4"
                                      (assert)
                                      (("4"
                                        (inst -9 "local")
                                        (("4"
                                          (inst -10 "local")
                                          (("4"
                                            (assert)
                                            (("4"
                                              (expand "appears?" -14)
                                              (("4"
                                                (expand
                                                 "appearsFree?"
                                                 -14)
                                                (("4"
                                                  (split -14)
                                                  (("1"
                                                    (assert)
                                                    (("1"
                                                      (expand
                                                       "appears?"
                                                       -10)
                                                      (("1"
                                                        (propax)
                                                        nil
                                                        nil))
                                                      nil))
                                                    nil)
                                                   ("2"
                                                    (expand
                                                     "appears?"
                                                     -11)
                                                    (("2"
                                                      (propax)
                                                      nil
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((appearsFree? def-decl "bool" expressions nil)
    (wellFormed?_expr_op formula-decl nil expressions nil)
    (FPOperator adt-constructor-decl
     "[[Operator, FPAExpr, FPAExpr] -> (FPOperator?)]" expressions nil)
    (FPOperator? adt-recognizer-decl "[FPAExpr -> boolean]" expressions
     nil)
    (sem_expr_opr_fpconds formula-decl nil semantics nil)
    (FPVariable adt-constructor-decl "[DeBruijnIndex -> (FPVariable?)]"
     expressions nil)
    (DeBruijnIndex nonempty-type-eq-decl nil expressions nil)
    (sem_expr_var_fpconds formula-decl nil semantics nil)
    (appears? const-decl "bool" domain nil)
    (member def-decl "bool" list_props nil)
    (< const-decl "bool" reals nil)
    (below type-eq-decl nil nat_types nil)
    (nth def-decl "T" list_props nil)
    (env skolem-const-decl "(validEnvironmentForStmt)" semantics nil)
    (vr skolem-const-decl
     "DeBruijnIndex[Operator, RealNumber, FloatingPointNumber, FtoR]"
     semantics nil)
    (ceb skolem-const-decl "CEB
    [Operator, RealNumber, lt_r, applyFun_r, FloatingPointNumber, lt_fp,
     applyFun_fp, FtoR]" semantics nil)
    (nth_member formula-decl nil more_list_props "structures/")
    (below type-eq-decl nil naturalnumbers nil)
    (appears? const-decl "bool" domain nil)
    (ftor_fpvar_rvar_j application-judgement "(RVariable?)" semantics
     nil)
    (make_ceb const-decl "CEB" domain nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (appearsFree? def-decl "bool" expressions nil)
    (singleton const-decl "(singleton?)" sets nil)
    (TRUE const-decl "bool" booleans nil)
    (FPAExpr_induction formula-decl nil expressions nil)
    (Operator formal-nonempty-type-decl nil semantics nil)
    (RealNumber formal-nonempty-type-decl nil semantics nil)
    (FloatingPointNumber formal-nonempty-type-decl nil semantics nil)
    (FtoR formal-const-decl "[FloatingPointNumber -> RealNumber]"
     semantics nil)
    (appears? const-decl "bool" semantics nil)
    (appears? const-decl "bool" expressions nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (appears? const-decl "bool" expressions nil)
    (FPVariable? adt-recognizer-decl "[FPAExpr -> boolean]" expressions
     nil)
    (sem def-decl "(validDomain)" semantics nil)
    (validDomain const-decl "bool" semantics nil)
    (wellFormed? def-decl "bool" semantics nil)
    (length def-decl "nat" list_props nil)
    (Domain type-eq-decl nil domain nil)
    (wellFormed? inductive-decl "bool" expressions nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (validEnvironmentForStmt const-decl "bool" semantics nil)
    (Environment nonempty-type-eq-decl nil semantics nil)
    (finite_nonempty? const-decl "bool" more_set_defs "sets_aux/")
    (every adt-def-decl "boolean" list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil) (set type-eq-decl nil sets nil)
    (CEB type-eq-decl nil domain nil)
    (RAExprDomain type-decl nil domain nil)
    (RBExpr type-decl nil expressions nil)
    (FPAExprDomain type-decl nil domain nil)
    (applyFun_fp formal-const-decl
     "[[Operator, FloatingPointNumber, FloatingPointNumber] ->
   FloatingPointNumber]" semantics nil)
    (lt_fp formal-const-decl
     "(strict_total_order?[FloatingPointNumber])" semantics nil)
    (applyFun_r formal-const-decl
     "[[Operator, RealNumber, RealNumber] -> RealNumber]" semantics
     nil)
    (lt_r formal-const-decl "(strict_total_order?[RealNumber])"
     semantics nil)
    (strict_total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (FPBExpr type-decl nil expressions nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (FPAExpr type-decl nil expressions nil))
   shostak))
 (appears_free_rconds_expr 0
  (appears_free_rconds_expr-1 nil 3755345324
   ("" (induct "expr")
    (("1" (skolem 1 "ct")
      (("1" (skeep* :preds? t)
        (("1" (expand "sem" -)
          (("1" (expand "singleton" -7)
            (("1" (expand "make_ceb")
              (("1" (replace -7 :hide? t)
                (("1" (assert)
                  (("1" (expand "appears?" -7)
                    (("1" (expand "appearsFree?" -7)
                      (("1" (propax) nil nil)) nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("2" (skolem 1 "vr")
      (("2" (skeep* :preds? t)
        (("2" (rewrite "sem_expr_var_fpconds")
          (("2" (expand "appears?" 2)
            (("2" (expand "appears?" 2)
              (("2" (expand "appears?" 2)
                (("2" (inst 2 "nth(env,vr)")
                  (("1" (inst 2 "ceb") (("1" (assert) nil nil)) nil)
                   ("2" (use "nth_member[Domain]") nil nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("3" (skolem 1 "idx")
      (("3" (skeep* :preds? t)
        (("3" (expand "sem" -)
          (("3" (expand "singleton" -7)
            (("3" (expand "make_ceb")
              (("3" (replace -7 :hide? t)
                (("3" (assert)
                  (("3" (expand "appears?" -7)
                    (("3" (expand "appearsFree?" -7)
                      (("3" (propax) nil nil)) nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("4" (skolem 1 ("op" "a1" "a2"))
      (("4" (flatten)
        (("4" (skeep* :preds? t)
          (("4" (use "sem_expr_opr_rconds")
            (("4" (assert)
              (("4" (skeep -1 :preds? t)
                (("4" (replace -3 :hide? t)
                  (("4" (expand "appears?" 1)
                    (("4" (expand "appearsFree?" 1)
                      (("4" (flatten)
                        (("4" (inst -7 "nargs" "env" "ceb1")
                          (("4" (inst -8 "nargs" "env" "ceb2")
                            (("4" (assert)
                              (("4"
                                (use "wellFormed?_expr_op")
                                (("4"
                                  (assert)
                                  (("4"
                                    (flatten)
                                    (("4"
                                      (assert)
                                      (("4"
                                        (inst -9 "local")
                                        (("4"
                                          (inst -10 "local")
                                          (("4"
                                            (assert)
                                            (("4"
                                              (expand "appears?" -14)
                                              (("4"
                                                (expand
                                                 "appearsFree?"
                                                 -14)
                                                (("4"
                                                  (split -14)
                                                  (("1"
                                                    (assert)
                                                    (("1"
                                                      (expand
                                                       "appears?"
                                                       -10)
                                                      (("1"
                                                        (propax)
                                                        nil
                                                        nil))
                                                      nil))
                                                    nil)
                                                   ("2"
                                                    (expand
                                                     "appears?"
                                                     -11)
                                                    (("2"
                                                      (propax)
                                                      nil
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("5" (hide 2)
      (("5" (skeep)
        (("5" (skeep)
          (("5" (expand "FtoR") (("5" (propax) nil nil)) nil)) nil))
        nil))
      nil))
    nil)
   ((appearsFree? def-decl "bool" expressions nil)
    (wellFormed?_expr_op formula-decl nil expressions nil)
    (FPOperator adt-constructor-decl
     "[[Operator, FPAExpr, FPAExpr] -> (FPOperator?)]" expressions nil)
    (FPOperator? adt-recognizer-decl "[FPAExpr -> boolean]" expressions
     nil)
    (sem_expr_opr_rconds formula-decl nil semantics nil)
    (FPVariable adt-constructor-decl "[DeBruijnIndex -> (FPVariable?)]"
     expressions nil)
    (DeBruijnIndex nonempty-type-eq-decl nil expressions nil)
    (sem_expr_var_fpconds formula-decl nil semantics nil)
    (appears? const-decl "bool" domain nil)
    (member def-decl "bool" list_props nil)
    (< const-decl "bool" reals nil)
    (below type-eq-decl nil nat_types nil)
    (nth def-decl "T" list_props nil)
    (env skolem-const-decl "(validEnvironmentForStmt)" semantics nil)
    (vr skolem-const-decl
     "DeBruijnIndex[Operator, RealNumber, FloatingPointNumber, FtoR]"
     semantics nil)
    (ceb skolem-const-decl "CEB
    [Operator, RealNumber, lt_r, applyFun_r, FloatingPointNumber, lt_fp,
     applyFun_fp, FtoR]" semantics nil)
    (nth_member formula-decl nil more_list_props "structures/")
    (below type-eq-decl nil naturalnumbers nil)
    (appears? const-decl "bool" domain nil)
    (make_ceb const-decl "CEB" domain nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (appearsFree? def-decl "bool" expressions nil)
    (singleton const-decl "(singleton?)" sets nil)
    (TRUE const-decl "bool" booleans nil)
    (FPAExpr_induction formula-decl nil expressions nil)
    (Operator formal-nonempty-type-decl nil semantics nil)
    (RealNumber formal-nonempty-type-decl nil semantics nil)
    (FloatingPointNumber formal-nonempty-type-decl nil semantics nil)
    (FtoR formal-const-decl "[FloatingPointNumber -> RealNumber]"
     semantics nil)
    (appears? const-decl "bool" semantics nil)
    (appears? const-decl "bool" expressions nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (FtoR def-decl "RAExpr" expressions nil)
    (appears? const-decl "bool" expressions nil)
    (RVariable? adt-recognizer-decl "[RAExpr -> boolean]" expressions
     nil)
    (RAExpr type-decl nil expressions nil)
    (FPVariable? adt-recognizer-decl "[FPAExpr -> boolean]" expressions
     nil)
    (sem def-decl "(validDomain)" semantics nil)
    (validDomain const-decl "bool" semantics nil)
    (wellFormed? def-decl "bool" semantics nil)
    (length def-decl "nat" list_props nil)
    (Domain type-eq-decl nil domain nil)
    (wellFormed? inductive-decl "bool" expressions nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (validEnvironmentForStmt const-decl "bool" semantics nil)
    (Environment nonempty-type-eq-decl nil semantics nil)
    (finite_nonempty? const-decl "bool" more_set_defs "sets_aux/")
    (every adt-def-decl "boolean" list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil) (set type-eq-decl nil sets nil)
    (CEB type-eq-decl nil domain nil)
    (RAExprDomain type-decl nil domain nil)
    (RBExpr type-decl nil expressions nil)
    (FPAExprDomain type-decl nil domain nil)
    (applyFun_fp formal-const-decl
     "[[Operator, FloatingPointNumber, FloatingPointNumber] ->
   FloatingPointNumber]" semantics nil)
    (lt_fp formal-const-decl
     "(strict_total_order?[FloatingPointNumber])" semantics nil)
    (applyFun_r formal-const-decl
     "[[Operator, RealNumber, RealNumber] -> RealNumber]" semantics
     nil)
    (lt_r formal-const-decl "(strict_total_order?[RealNumber])"
     semantics nil)
    (strict_total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (FPBExpr type-decl nil expressions nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (FPAExpr type-decl nil expressions nil)
    (ftor_fpvar_rvar_j application-judgement "(RVariable?)" semantics
     nil))
   nil))
 (appears_free_fpconds 0
  (appears_free_fpconds-2 nil 3755344595
   ("" (induct "stmt")
    (("1" (skeep :preds? t)
      (("1" (expand "sem" -6)
        (("1" (expand "singleton" -6)
          (("1" (replace -6 :hide? t)
            (("1" (expand "make_ceb")
              (("1" (expand "appears?" 1 1)
                (("1" (expand "appearsFree?") (("1" (propax) nil nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("2" (skolem 1 ("guard" "thenb" "elseb"))
      (("2" (flatten)
        (("2" (skeep)
          (("2" (expand "appearsFree?" 1)
            (("2" (expand "appearsFree?" 1)
              (("2" (expand "sem" -5)
                (("2" (expand "union")
                  (("2" (expand "member")
                    (("2" (split -5)
                      (("1" (use "propag_def")
                        (("1" (assert)
                          (("1" (skeep 1)
                            (("1"
                              (skolem -1 "ceb_then" :skolem-typepreds?
                               t)
                              (("1"
                                (replace -2 :hide? t)
                                (("1"
                                  (expand "appears?" -7)
                                  (("1"
                                    (expand "appearsFree?" -7)
                                    (("1"
                                      (assert)
                                      (("1"
                                        (inst
                                         -3
                                         "nargs"
                                         "env"
                                         "ceb_then")
                                        (("1"
                                          (split -3)
                                          (("1"
                                            (inst -1 "local")
                                            (("1"
                                              (rewrite
                                               "appearsFree?_stmt_locals_count_def")
                                              (("1"
                                                (rewrite
                                                 "appears?_form_int_def")
                                                nil
                                                nil))
                                              nil))
                                            nil)
                                           ("2"
                                            (use
                                             "well_formed_ite_then")
                                            (("2" (assert) nil nil))
                                            nil)
                                           ("3" (propax) nil nil)
                                           ("4" (propax) nil nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil)
                       ("2" (use "propag_def")
                        (("2" (assert)
                          (("2" (skeep 1)
                            (("2"
                              (skolem -1 "ceb_" :skolem-typepreds? t)
                              (("2"
                                (replace -2 :hide? t)
                                (("2"
                                  (rewrite "appears?_form_int_def_and")
                                  (("2"
                                    (split -7)
                                    (("1"
                                      (rewrite
                                       "appears?_form_int_def_not")
                                      (("1"
                                        (rewrite
                                         "appears?_form_int_def")
                                        nil
                                        nil))
                                      nil)
                                     ("2"
                                      (inst -5 "nargs" "env" "ceb_")
                                      (("2"
                                        (split -5)
                                        (("1"
                                          (inst -1 "local")
                                          (("1"
                                            (assert)
                                            (("1"
                                              (rewrite
                                               "appearsFree?_stmt_locals_count_def")
                                              nil
                                              nil))
                                            nil))
                                          nil)
                                         ("2"
                                          (use "well_formed_ite_else")
                                          (("2" (assert) nil nil))
                                          nil)
                                         ("3" (propax) nil nil)
                                         ("4" (propax) nil nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil)
                       ("3" (use "propag_def")
                        (("3" (assert)
                          (("3" (hide -2)
                            (("3" (skeep 1)
                              (("3"
                                (skeep -1 :preds? t)
                                (("3"
                                  (replace -2 :hide? t)
                                  (("3"
                                    (rewrite
                                     "appears?_form_int_def_and")
                                    (("3"
                                      (split -6)
                                      (("1"
                                        (rewrite
                                         "appears?_form_int_def")
                                        nil
                                        nil)
                                       ("2"
                                        (rewrite
                                         "else_then_unstable_ceb_def")
                                        (("2"
                                          (assert)
                                          (("2"
                                            (skeep -2 :preds? t)
                                            (("2"
                                              (inst
                                               -8
                                               "nargs"
                                               "env"
                                               "thenceb")
                                              (("2"
                                                (split -8)
                                                (("1"
                                                  (inst -1 "local")
                                                  (("1"
                                                    (split -1)
                                                    (("1"
                                                      (rewrite
                                                       "appearsFree?_stmt_locals_count_def")
                                                      nil
                                                      nil)
                                                     ("2"
                                                      (assert)
                                                      nil
                                                      nil))
                                                    nil))
                                                  nil)
                                                 ("2"
                                                  (use
                                                   "well_formed_ite_then")
                                                  (("2"
                                                    (assert)
                                                    nil
                                                    nil))
                                                  nil)
                                                 ("3" (propax) nil nil)
                                                 ("4"
                                                  (expand
                                                   "stable_ceb_filter")
                                                  (("4"
                                                    (assert)
                                                    nil
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil)
                       ("4" (use "propag_def")
                        (("4" (assert)
                          (("4" (hide -2)
                            (("4" (skeep -1 :preds? t)
                              (("4"
                                (skeep 1)
                                (("4"
                                  (replace -2 :hide? t)
                                  (("4"
                                    (rewrite
                                     "appears?_form_int_def_and")
                                    (("4"
                                      (split -6)
                                      (("1"
                                        (rewrite
                                         "appears?_form_int_def_not")
                                        (("1"
                                          (rewrite
                                           "appears?_form_int_def")
                                          nil
                                          nil))
                                        nil)
                                       ("2"
                                        (rewrite
                                         "then_else_unstable_ceb_def")
                                        (("2"
                                          (assert)
                                          (("2"
                                            (skeep -2 :preds? t)
                                            (("2"
                                              (inst
                                               -9
                                               "nargs"
                                               "env"
                                               "elseceb")
                                              (("2"
                                                (split -9)
                                                (("1"
                                                  (inst -1 "local")
                                                  (("1"
                                                    (split -1)
                                                    (("1"
                                                      (rewrite
                                                       "appearsFree?_stmt_locals_count_def")
                                                      nil
                                                      nil)
                                                     ("2"
                                                      (assert)
                                                      nil
                                                      nil))
                                                    nil))
                                                  nil)
                                                 ("2"
                                                  (use
                                                   "well_formed_ite_else")
                                                  (("2"
                                                    (assert)
                                                    nil
                                                    nil))
                                                  nil)
                                                 ("3" (propax) nil nil)
                                                 ("4"
                                                  (expand
                                                   "stable_ceb_filter")
                                                  (("4"
                                                    (assert)
                                                    nil
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("3" (skolem 1 "expr")
      (("3" (skeep :preds? t)
        (("3" (expand "sem" -6)
          (("3" (use "appears_free_fpconds_expr")
            (("3" (assert)
              (("3" (use "well_formed_aexpr")
                (("3" (assert)
                  (("3" (expand "appearsFree?" 1)
                    (("3" (expand "appearsFree?" 1)
                      (("3" (expand "appears?" -2 2)
                        (("3" (skolem 1 "local")
                          (("3" (inst -2 "local")
                            (("3" (flatten)
                              (("3"
                                (assert)
                                (("3"
                                  (use
                                   "validEnvironmentForStmt_no_free_var")
                                  nil
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("4" (skolem 1 ("expr" "body"))
      (("4" (flatten)
        (("4" (skeep :preds? t)
          (("4" (expand "sem" -7)
            (("4" (use "unreplaced_var_ceb_in_dom")
              (("4" (assert)
                (("4" (skolem -1 "ceb_body")
                  (("4" (flatten)
                    (("4" (skeep 1 :preds? t)
                      (("4" (case "appears?(expr)(local)")
                        (("1"
                          (rewrite
                           "appearsFree?_stmt_locals_count_def")
                          (("1"
                            (rewrite "appearsFree?_stmt_int_def_letin")
                            (("1" (flatten)
                              (("1"
                                (expand "appears?" -1)
                                (("1" (propax) nil nil))
                                nil))
                              nil))
                            nil))
                          nil)
                         ("2" (assert)
                          (("2" (hide 1)
                            (("2"
                              (lemma
                               "var_appears_in_replaced_fpconds_dec_var_appears_in_orig_fpconds")
                              (("2"
                                (inst
                                 -1
                                 "ceb_body"
                                 "expr"
                                 "index(local)")
                                (("2"
                                  (split -1)
                                  (("1"
                                    (use "well_formed_letin_body")
                                    (("1"
                                      (assert)
                                      (("1"
                                        (inst
                                         -9
                                         "nargs"
                                         "cons(sem(expr,nargs,env),env)"
                                         "ceb_body")
                                        (("1"
                                          (split -9)
                                          (("1"
                                            (expand "appearsFree?" 1)
                                            (("1"
                                              (expand "appearsFree?" 1)
                                              (("1"
                                                (inst
                                                 -1
                                                 "FPVariable(index(local)+1)")
                                                (("1"
                                                  (split -1)
                                                  (("1"
                                                    (lemma
                                                     "appearsFree?_inc_var")
                                                    (("1"
                                                      (inst?
                                                       -1
                                                       :where
                                                       1)
                                                      (("1"
                                                        (case
                                                         "FPVariable(index(local)) = local")
                                                        (("1"
                                                          (assert)
                                                          (("1"
                                                            (inst
                                                             -2
                                                             "0"
                                                             "index(local)")
                                                            (("1"
                                                              (assert)
                                                              (("1"
                                                                (split
                                                                 -2)
                                                                (("1"
                                                                  (assert)
                                                                  nil
                                                                  nil)
                                                                 ("2"
                                                                  (grind)
                                                                  nil
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil)
                                                         ("2"
                                                          (apply-extensionality)
                                                          nil
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil)
                                                   ("2"
                                                    (use
                                                     "var_appears_in_replaced_fpconds_dec_var_appears_in_orig_fpconds")
                                                    (("2"
                                                      (split -1)
                                                      (("1"
                                                        (propax)
                                                        nil
                                                        nil)
                                                       ("2"
                                                        (rewrite
                                                         "appears?_expr_int_def")
                                                        (("2"
                                                          (case
                                                           "local = FPVariable(index(local))")
                                                          (("1"
                                                            (assert)
                                                            nil
                                                            nil)
                                                           ("2"
                                                            (apply-extensionality)
                                                            nil
                                                            nil))
                                                          nil))
                                                        nil)
                                                       ("3"
                                                        (case
                                                         "local = FPVariable(index(local))")
                                                        (("1"
                                                          (assert)
                                                          nil
                                                          nil)
                                                         ("2"
                                                          (apply-extensionality)
                                                          nil
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil)
                                           ("2"
                                            (expand "length" 1)
                                            (("2" (propax) nil nil))
                                            nil)
                                           ("3"
                                            (expand "length" 1)
                                            (("3"
                                              (lemma
                                               "wellFormed?_env_monotonocity")
                                              (("3"
                                                (inst
                                                 -1
                                                 "cons(sem(expr,nargs,env),env)"
                                                 "nargs"
                                                 "length(env)")
                                                (("3"
                                                  (split -1)
                                                  (("1"
                                                    (inst? -1 :where 1)
                                                    nil
                                                    nil)
                                                   ("2"
                                                    (hide 2)
                                                    (("2"
                                                      (use
                                                       "wellFormed?_env_ext")
                                                      (("2"
                                                        (assert)
                                                        (("2"
                                                          (hide 2)
                                                          (("2"
                                                            (use
                                                             "well_formed_env_implies_well_formed_sem_aexpr")
                                                            (("2"
                                                              (assert)
                                                              (("2"
                                                                (use
                                                                 "well_formed_letin_expr")
                                                                (("2"
                                                                  (assert)
                                                                  nil
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil)
                                           ("4" (propax) nil nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil)
                                   ("2"
                                    (case
                                     "FPVariable(index(local)) = local")
                                    (("1" (assert) nil nil)
                                     ("2"
                                      (apply-extensionality)
                                      nil
                                      nil))
                                    nil)
                                   ("3"
                                    (case
                                     "local = FPVariable(index(local))")
                                    (("1" (assert) nil nil)
                                     ("2"
                                      (apply-extensionality)
                                      nil
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((unreplaced_var_ceb_in_dom formula-decl nil semantics nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (wellFormed? inductive-decl "bool" expressions nil)
    (validDomain const-decl "bool" semantics nil)
    (sem def-decl "(validDomain)" semantics nil)
    (var_appears_in_replaced_fpconds_dec_var_appears_in_orig_fpconds
     formula-decl nil semantics nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (odd_minus_odd_is_even application-judgement "even_int" integers
     nil)
    (FPAExpr_FPVariable_extensionality formula-decl nil expressions
     nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (appearsFree?_inc_var formula-decl nil program nil)
    (appears?_expr_int_def formula-decl nil expressions nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (FPVariable adt-constructor-decl "[DeBruijnIndex -> (FPVariable?)]"
     expressions nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (wellFormed?_env_monotonocity formula-decl nil semantics nil)
    (upfrom nonempty-type-eq-decl nil integers nil)
    (wellFormed?_env_ext formula-decl nil semantics nil)
    (well_formed_letin_expr formula-decl nil program nil)
    (well_formed_env_implies_well_formed_sem_aexpr formula-decl nil
     semantics nil)
    (well_formed_letin_body formula-decl nil program nil)
    (DeBruijnIndex nonempty-type-eq-decl nil expressions nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (FPParameter? adt-recognizer-decl "[FPAExpr -> boolean]"
     expressions nil)
    (index shared-adt-accessor-decl
           "[{x: FPAExpr | FPVariable?(x) OR FPParameter?(x)} -> DeBruijnIndex]"
           expressions nil)
    (LETIN adt-constructor-decl
     "[[FPAExpr[Operator, RealNumber, FloatingPointNumber, FtoR], FPStmt] ->
   (LetIn?)]" program nil)
    (LetIn? adt-recognizer-decl "[FPStmt -> boolean]" program nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (odd_plus_even_is_odd application-judgement "odd_int" integers nil)
    (appearsFree?_stmt_int_def_letin formula-decl nil program nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (validEnvironmentForStmt_no_free_var formula-decl nil semantics
     nil)
    (appears? const-decl "bool" expressions nil)
    (well_formed_aexpr formula-decl nil program nil)
    (appears_free_fpconds_expr formula-decl nil semantics nil)
    (appearsFree? def-decl "bool" program nil)
    (union const-decl "set" sets nil)
    (appearsFree?_stmt_locals_count_def formula-decl nil program nil)
    (appears?_form_int_def formula-decl nil expressions nil)
    (well_formed_ite_then formula-decl nil program nil)
    (FtoR def-decl "RBExpr" expressions nil)
    (propag_def formula-decl nil domain nil)
    (appears?_form_int_def_and formula-decl nil expressions nil)
    (well_formed_ite_else formula-decl nil program nil)
    (appears?_form_int_def_not formula-decl nil expressions nil)
    (RNot adt-constructor-decl "[RBExpr -> (RNot?)]" expressions nil)
    (RNot? adt-recognizer-decl "[RBExpr -> boolean]" expressions nil)
    (FPNot adt-constructor-decl "[FPBExpr -> (FPNot?)]" expressions
     nil)
    (FPNot? adt-recognizer-decl "[FPBExpr -> boolean]" expressions nil)
    (stable_ceb_filter const-decl
     "{result: Domain | FORALL (ceb: (result)): stable?(ceb)}" domain
     nil)
    (else_then_unstable_ceb_def formula-decl nil semantics nil)
    (else_then_unstable_ceb const-decl "Domain" semantics nil)
    (then_else_unstable_ceb_def formula-decl nil semantics nil)
    (then_else_unstable_ceb const-decl "Domain" semantics nil)
    (member const-decl "bool" sets nil)
    (singleton const-decl "(singleton?)" sets nil)
    (make_ceb const-decl "CEB" domain nil)
    (appearsFree? def-decl "bool" expressions nil)
    (FPStmt_induction formula-decl nil program nil)
    (Operator formal-nonempty-type-decl nil semantics nil)
    (RealNumber formal-nonempty-type-decl nil semantics nil)
    (FloatingPointNumber formal-nonempty-type-decl nil semantics nil)
    (FtoR formal-const-decl "[FloatingPointNumber -> RealNumber]"
     semantics nil)
    (appearsFree? const-decl "bool" program nil)
    (appears? const-decl "bool" expressions nil)
    (FPVariable? adt-recognizer-decl "[FPAExpr -> boolean]" expressions
     nil)
    (FPAExpr type-decl nil expressions nil)
    (sem def-decl
     "{d: Domain | EXISTS (ceb: CEB): d(ceb) AND stable?(ceb)}"
     semantics nil)
    (wellFormed? def-decl "bool" semantics nil)
    (length def-decl "nat" list_props nil)
    (Domain type-eq-decl nil domain nil)
    (wellFormed? inductive-decl "bool" program nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (validEnvironmentForStmt const-decl "bool" semantics nil)
    (Environment nonempty-type-eq-decl nil semantics nil)
    (finite_nonempty? const-decl "bool" more_set_defs "sets_aux/")
    (every adt-def-decl "boolean" list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil) (set type-eq-decl nil sets nil)
    (CEB type-eq-decl nil domain nil)
    (RAExprDomain type-decl nil domain nil)
    (RBExpr type-decl nil expressions nil)
    (FPAExprDomain type-decl nil domain nil)
    (applyFun_fp formal-const-decl
     "[[Operator, FloatingPointNumber, FloatingPointNumber] ->
   FloatingPointNumber]" semantics nil)
    (lt_fp formal-const-decl
     "(strict_total_order?[FloatingPointNumber])" semantics nil)
    (applyFun_r formal-const-decl
     "[[Operator, RealNumber, RealNumber] -> RealNumber]" semantics
     nil)
    (lt_r formal-const-decl "(strict_total_order?[RealNumber])"
     semantics nil)
    (strict_total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (FPBExpr type-decl nil expressions nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (FPStmt type-decl nil program nil))
   nil)
  (appears_free_fpconds-1 nil 3754481345
   ("" (induct "stmt")
    (("1" (skeep :preds? t)
      (("1" (expand "sem" -6)
        (("1" (expand "singleton" -6)
          (("1" (replace -6 :hide? t)
            (("1" (expand "make_ceb")
              (("1" (expand "appears?" 1 1)
                (("1" (expand "appearsFree?") (("1" (propax) nil nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("2" (skolem 1 ("guard" "thenb" "elseb"))
      (("2" (flatten)
        (("2" (skeep)
          (("2" (expand "appearsFree?" 1)
            (("2" (expand "appearsFree?" 1)
              (("2" (expand "sem" -5)
                (("2" (expand "union")
                  (("2" (expand "member")
                    (("2" (split -5)
                      (("1" (use "propag_def")
                        (("1" (assert)
                          (("1" (skeep 1)
                            (("1"
                              (skolem -1 "ceb_then" :skolem-typepreds?
                               t)
                              (("1"
                                (replace -2 :hide? t)
                                (("1"
                                  (expand "appears?" -7)
                                  (("1"
                                    (expand "appearsFree?" -7)
                                    (("1"
                                      (assert)
                                      (("1"
                                        (inst
                                         -3
                                         "nargs"
                                         "env"
                                         "ceb_then")
                                        (("1"
                                          (split -3)
                                          (("1"
                                            (inst -1 "local")
                                            (("1"
                                              (rewrite
                                               "appearsFree?_stmt_locals_count_def")
                                              (("1"
                                                (rewrite
                                                 "appears?_form_int_def")
                                                nil
                                                nil))
                                              nil))
                                            nil)
                                           ("2"
                                            (use
                                             "well_formed_ite_then")
                                            (("2" (assert) nil nil))
                                            nil)
                                           ("3" (propax) nil nil)
                                           ("4" (propax) nil nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil)
                       ("2" (use "propag_def")
                        (("2" (assert)
                          (("2" (skeep 1)
                            (("2"
                              (skolem -1 "ceb_" :skolem-typepreds? t)
                              (("2"
                                (replace -2 :hide? t)
                                (("2"
                                  (rewrite "appears?_form_int_def_and")
                                  (("2"
                                    (split -7)
                                    (("1"
                                      (rewrite
                                       "appears?_form_int_def_not")
                                      (("1"
                                        (rewrite
                                         "appears?_form_int_def")
                                        nil
                                        nil))
                                      nil)
                                     ("2"
                                      (inst -5 "nargs" "env" "ceb_")
                                      (("2"
                                        (split -5)
                                        (("1"
                                          (inst -1 "local")
                                          (("1"
                                            (assert)
                                            (("1"
                                              (rewrite
                                               "appearsFree?_stmt_locals_count_def")
                                              nil
                                              nil))
                                            nil))
                                          nil)
                                         ("2"
                                          (use "well_formed_ite_else")
                                          (("2" (assert) nil nil))
                                          nil)
                                         ("3" (propax) nil nil)
                                         ("4" (propax) nil nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil)
                       ("3" (use "propag_def")
                        (("3" (assert)
                          (("3" (hide -2)
                            (("3" (skeep 1)
                              (("3"
                                (skeep -1 :preds? t)
                                (("3"
                                  (replace -2 :hide? t)
                                  (("3"
                                    (rewrite
                                     "appears?_form_int_def_and")
                                    (("3"
                                      (split -6)
                                      (("1"
                                        (rewrite
                                         "appears?_form_int_def")
                                        nil
                                        nil)
                                       ("2"
                                        (rewrite
                                         "else_then_unstable_ceb_def")
                                        (("2"
                                          (assert)
                                          (("2"
                                            (skeep -2 :preds? t)
                                            (("2"
                                              (inst
                                               -8
                                               "nargs"
                                               "env"
                                               "thenceb")
                                              (("2"
                                                (split -8)
                                                (("1"
                                                  (inst -1 "local")
                                                  (("1"
                                                    (split -1)
                                                    (("1"
                                                      (rewrite
                                                       "appearsFree?_stmt_locals_count_def")
                                                      nil
                                                      nil)
                                                     ("2"
                                                      (assert)
                                                      nil
                                                      nil))
                                                    nil))
                                                  nil)
                                                 ("2"
                                                  (use
                                                   "well_formed_ite_then")
                                                  (("2"
                                                    (assert)
                                                    nil
                                                    nil))
                                                  nil)
                                                 ("3" (propax) nil nil)
                                                 ("4"
                                                  (expand
                                                   "stable_ceb_filter")
                                                  (("4"
                                                    (assert)
                                                    nil
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil)
                       ("4" (use "propag_def")
                        (("4" (assert)
                          (("4" (hide -2)
                            (("4" (skeep -1 :preds? t)
                              (("4"
                                (skeep 1)
                                (("4"
                                  (replace -2 :hide? t)
                                  (("4"
                                    (rewrite
                                     "appears?_form_int_def_and")
                                    (("4"
                                      (split -6)
                                      (("1"
                                        (rewrite
                                         "appears?_form_int_def_not")
                                        (("1"
                                          (rewrite
                                           "appears?_form_int_def")
                                          nil
                                          nil))
                                        nil)
                                       ("2"
                                        (rewrite
                                         "then_else_unstable_ceb_def")
                                        (("2"
                                          (assert)
                                          (("2"
                                            (skeep -2 :preds? t)
                                            (("2"
                                              (inst
                                               -9
                                               "nargs"
                                               "env"
                                               "elseceb")
                                              (("2"
                                                (split -9)
                                                (("1"
                                                  (inst -1 "local")
                                                  (("1"
                                                    (split -1)
                                                    (("1"
                                                      (rewrite
                                                       "appearsFree?_stmt_locals_count_def")
                                                      nil
                                                      nil)
                                                     ("2"
                                                      (assert)
                                                      nil
                                                      nil))
                                                    nil))
                                                  nil)
                                                 ("2"
                                                  (use
                                                   "well_formed_ite_else")
                                                  (("2"
                                                    (assert)
                                                    nil
                                                    nil))
                                                  nil)
                                                 ("3" (propax) nil nil)
                                                 ("4"
                                                  (expand
                                                   "stable_ceb_filter")
                                                  (("4"
                                                    (assert)
                                                    nil
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("3" (skolem 1 "expr")
      (("3" (skeep :preds? t)
        (("3" (expand "sem" -6)
          (("3" (use "appears_free_fpconds_expr")
            (("3" (assert)
              (("3" (use "well_formed_aexpr")
                (("3" (assert)
                  (("3" (expand "appearsFree?" 1)
                    (("3" (expand "appearsFree?" 1)
                      (("3" (expand "appears?" -2 2)
                        (("3" (skolem 1 "local")
                          (("3" (inst -2 "local")
                            (("3" (flatten)
                              (("3"
                                (assert)
                                (("3"
                                  (use
                                   "validEnvironmentForStmt_no_free_var")
                                  nil
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("4" (skolem 1 ("expr" "body"))
      (("4" (flatten)
        (("4" (skeep :preds? t)
          (("4" (expand "sem" -7)
            (("4" (use "unreplaced_var_ceb_in_dom")
              (("4" (assert)
                (("4" (skolem -1 "ceb_body")
                  (("4" (flatten)
                    (("4" (skeep 1 :preds? t)
                      (("4" (case "appears?(expr)(local)")
                        (("1"
                          (rewrite
                           "appearsFree?_stmt_locals_count_def")
                          (("1"
                            (rewrite "appearsFree?_stmt_int_def_letin")
                            (("1" (flatten)
                              (("1"
                                (expand "appears?" -1)
                                (("1" (propax) nil nil))
                                nil))
                              nil))
                            nil))
                          nil)
                         ("2" (assert)
                          (("2" (hide 1)
                            (("2"
                              (lemma
                               "var_appears_in_replaced_ceb_dec_var_appears_in_orig_ceb")
                              (("2"
                                (inst
                                 -1
                                 "ceb_body"
                                 "expr"
                                 "index(local)")
                                (("2"
                                  (split -1)
                                  (("1"
                                    (use "well_formed_letin_body")
                                    (("1"
                                      (assert)
                                      (("1"
                                        (inst
                                         -9
                                         "nargs"
                                         "cons(sem(expr,nargs,env),env)"
                                         "ceb_body")
                                        (("1"
                                          (split -9)
                                          (("1"
                                            (expand "appearsFree?" 1)
                                            (("1"
                                              (expand "appearsFree?" 1)
                                              (("1"
                                                (inst
                                                 -1
                                                 "FPVariable(index(local)+1)")
                                                (("1"
                                                  (split -1)
                                                  (("1"
                                                    (lemma
                                                     "appearsFree?_inc_var")
                                                    (("1"
                                                      (inst?
                                                       -1
                                                       :where
                                                       1)
                                                      (("1"
                                                        (case
                                                         "FPVariable(index(local)) = local")
                                                        (("1"
                                                          (assert)
                                                          (("1"
                                                            (inst
                                                             -2
                                                             "0"
                                                             "index(local)")
                                                            (("1"
                                                              (assert)
                                                              (("1"
                                                                (split
                                                                 -2)
                                                                (("1"
                                                                  (assert)
                                                                  nil
                                                                  nil)
                                                                 ("2"
                                                                  (grind)
                                                                  nil
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil)
                                                         ("2"
                                                          (apply-extensionality)
                                                          nil
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil)
                                                   ("2"
                                                    (use
                                                     "var_appears_in_replaced_fpconds_dec_var_appears_in_orig_fpconds")
                                                    (("2"
                                                      (split -1)
                                                      (("1"
                                                        (propax)
                                                        nil
                                                        nil)
                                                       ("2"
                                                        (rewrite
                                                         "appears?_expr_int_def")
                                                        (("2"
                                                          (case
                                                           "local = FPVariable(index(local))")
                                                          (("1"
                                                            (assert)
                                                            nil
                                                            nil)
                                                           ("2"
                                                            (apply-extensionality)
                                                            nil
                                                            nil))
                                                          nil))
                                                        nil)
                                                       ("3"
                                                        (case
                                                         "local = FPVariable(index(local))")
                                                        (("1"
                                                          (assert)
                                                          nil
                                                          nil)
                                                         ("2"
                                                          (apply-extensionality)
                                                          nil
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil)
                                           ("2"
                                            (expand "length" 1)
                                            (("2" (propax) nil nil))
                                            nil)
                                           ("3"
                                            (expand "length" 1)
                                            (("3"
                                              (lemma
                                               "wellFormed?_env_monotonocity")
                                              (("3"
                                                (inst
                                                 -1
                                                 "cons(sem(expr,nargs,env),env)"
                                                 "nargs"
                                                 "length(env)")
                                                (("3"
                                                  (split -1)
                                                  (("1"
                                                    (inst? -1 :where 1)
                                                    nil
                                                    nil)
                                                   ("2"
                                                    (hide 2)
                                                    (("2"
                                                      (use
                                                       "wellFormed?_env_ext")
                                                      (("2"
                                                        (assert)
                                                        (("2"
                                                          (hide 2)
                                                          (("2"
                                                            (use
                                                             "well_formed_env_implies_well_formed_sem_aexpr")
                                                            (("2"
                                                              (assert)
                                                              (("2"
                                                                (use
                                                                 "well_formed_letin_expr")
                                                                (("2"
                                                                  (assert)
                                                                  nil
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil)
                                           ("4" (propax) nil nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil)
                                   ("2"
                                    (case
                                     "FPVariable(index(local)) = local")
                                    (("1" (assert) nil nil)
                                     ("2"
                                      (apply-extensionality)
                                      nil
                                      nil))
                                    nil)
                                   ("3"
                                    (replace -3 1)
                                    (("3"
                                      (expand "appears?" 1)
                                      (("3"
                                        (case
                                         "FPVariable(index(local)) = local")
                                        (("1" (assert) nil nil)
                                         ("2"
                                          (apply-extensionality)
                                          nil
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((FPStmt type-decl nil program nil)
    (FPBExpr type-decl nil expressions nil)
    (FPAExprDomain type-decl nil domain nil)
    (RBExpr type-decl nil expressions nil)
    (RAExprDomain type-decl nil domain nil)
    (CEB type-eq-decl nil domain nil)
    (finite_nonempty? const-decl "bool" more_set_defs "sets_aux/")
    (wellFormed? inductive-decl "bool" program nil)
    (Domain type-eq-decl nil domain nil)
    (FPAExpr type-decl nil expressions nil)
    (FPVariable? adt-recognizer-decl "[FPAExpr -> boolean]" expressions
     nil)
    (appearsFree? const-decl "bool" program nil)
    (FPStmt_induction formula-decl nil program nil)
    (make_ceb const-decl "CEB" domain nil)
    (stable_ceb_filter const-decl
     "{result: Domain | FORALL (ceb: (result)): stable?(ceb)}" domain
     nil)
    (FPNot? adt-recognizer-decl "[FPBExpr -> boolean]" expressions nil)
    (FPNot adt-constructor-decl "[FPBExpr -> (FPNot?)]" expressions
     nil)
    (RNot? adt-recognizer-decl "[RBExpr -> boolean]" expressions nil)
    (RNot adt-constructor-decl "[RBExpr -> (RNot?)]" expressions nil)
    (appears?_form_int_def_not formula-decl nil expressions nil)
    (well_formed_ite_else formula-decl nil program nil)
    (appears?_form_int_def_and formula-decl nil expressions nil)
    (propag_def formula-decl nil domain nil)
    (FtoR def-decl "RBExpr" expressions nil)
    (well_formed_ite_then formula-decl nil program nil)
    (appears?_form_int_def formula-decl nil expressions nil)
    (appearsFree?_stmt_locals_count_def formula-decl nil program nil)
    (appearsFree? def-decl "bool" program nil)
    (well_formed_aexpr formula-decl nil program nil)
    (appearsFree?_stmt_int_def_letin formula-decl nil program nil)
    (LetIn? adt-recognizer-decl "[FPStmt -> boolean]" program nil)
    (LETIN adt-constructor-decl
     "[[FPAExpr[Operator, RealNumber, FloatingPointNumber, FtoR], FPStmt] ->
   (LetIn?)]" program nil)
    (index shared-adt-accessor-decl
           "[{x: FPAExpr | FPVariable?(x) OR FPParameter?(x)} -> DeBruijnIndex]"
           expressions nil)
    (FPParameter? adt-recognizer-decl "[FPAExpr -> boolean]"
     expressions nil)
    (DeBruijnIndex nonempty-type-eq-decl nil expressions nil)
    (well_formed_letin_body formula-decl nil program nil)
    (well_formed_letin_expr formula-decl nil program nil)
    (FPVariable adt-constructor-decl "[DeBruijnIndex -> (FPVariable?)]"
     expressions nil)
    (appears?_expr_int_def formula-decl nil expressions nil)
    (appearsFree?_inc_var formula-decl nil program nil)
    (FPAExpr_FPVariable_extensionality formula-decl nil expressions
     nil)
    (wellFormed? inductive-decl "bool" expressions nil))
   shostak))
 (appears_free_rconds 0
  (appears_free_rconds-1 nil 3755254920
   ("" (induct "stmt")
    (("1" (skeep :preds? t)
      (("1" (expand "sem" -6)
        (("1" (expand "singleton" -6)
          (("1" (replace -6 :hide? t)
            (("1" (expand "make_ceb")
              (("1" (expand "appears?" 1 1)
                (("1" (expand "appearsFree?") (("1" (propax) nil nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("2" (skolem 1 ("guard" "thenb" "elseb"))
      (("2" (flatten)
        (("2" (skeep)
          (("2" (expand "appearsFree?" 1)
            (("2" (expand "appearsFree?" 1)
              (("2" (expand "sem" -5)
                (("2" (expand "union")
                  (("2" (expand "member")
                    (("2" (split -5)
                      (("1" (use "propag_def_r")
                        (("1" (assert)
                          (("1" (skeep 1)
                            (("1"
                              (skolem -1 "ceb_then" :skolem-typepreds?
                               t)
                              (("1"
                                (replace -2 :hide? t)
                                (("1"
                                  (expand "appears?" -7)
                                  (("1"
                                    (expand "appearsFree?" -7)
                                    (("1"
                                      (split -7)
                                      (("1"
                                        (rewrite
                                         "appearsFree?_form_rform")
                                        nil
                                        nil)
                                       ("2"
                                        (inst
                                         -4
                                         "nargs"
                                         "env"
                                         "ceb_then")
                                        (("2"
                                          (split -4)
                                          (("1"
                                            (inst -1 "local")
                                            (("1"
                                              (rewrite
                                               "appearsFree?_stmt_locals_count_def")
                                              (("1"
                                                (rewrite
                                                 "appears?_rform_int_def")
                                                (("1"
                                                  (assert)
                                                  nil
                                                  nil))
                                                nil))
                                              nil))
                                            nil)
                                           ("2"
                                            (use
                                             "well_formed_ite_then")
                                            (("2" (assert) nil nil))
                                            nil)
                                           ("3" (propax) nil nil)
                                           ("4" (propax) nil nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil)
                       ("2" (use "propag_def_r")
                        (("2" (assert)
                          (("2" (skeep 1)
                            (("2"
                              (skolem -1 "ceb_" :skolem-typepreds? t)
                              (("2"
                                (replace -2 :hide? t)
                                (("2"
                                  (rewrite
                                   "appears?_rform_int_def_and")
                                  (("2"
                                    (split -7)
                                    (("1"
                                      (rewrite
                                       "appears?_rform_int_def_not")
                                      (("1"
                                        (rewrite
                                         "appears?_rform_int_def")
                                        (("1"
                                          (rewrite
                                           "appearsFree?_form_rform")
                                          nil
                                          nil))
                                        nil))
                                      nil)
                                     ("2"
                                      (inst -5 "nargs" "env" "ceb_")
                                      (("2"
                                        (split -5)
                                        (("1"
                                          (inst -1 "local")
                                          (("1"
                                            (assert)
                                            (("1"
                                              (rewrite
                                               "appearsFree?_stmt_locals_count_def")
                                              nil
                                              nil))
                                            nil))
                                          nil)
                                         ("2"
                                          (use "well_formed_ite_else")
                                          (("2" (assert) nil nil))
                                          nil)
                                         ("3" (propax) nil nil)
                                         ("4" (propax) nil nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil)
                       ("3" (use "propag_def_r")
                        (("3" (assert)
                          (("3" (hide -2)
                            (("3" (skeep 1)
                              (("3"
                                (skeep -1 :preds? t)
                                (("3"
                                  (replace -2 :hide? t)
                                  (("3"
                                    (rewrite
                                     "appears?_rform_int_def_and")
                                    (("3"
                                      (split -6)
                                      (("1"
                                        (rewrite
                                         "appears?_rform_int_def_not")
                                        (("1"
                                          (rewrite
                                           "appears?_rform_int_def")
                                          (("1"
                                            (rewrite
                                             "appearsFree?_form_rform")
                                            nil
                                            nil))
                                          nil))
                                        nil)
                                       ("2"
                                        (rewrite
                                         "else_then_unstable_ceb_def")
                                        (("2"
                                          (assert)
                                          (("2"
                                            (skeep -2 :preds? t)
                                            (("2"
                                              (inst
                                               -9
                                               "nargs"
                                               "env"
                                               "elseceb")
                                              (("2"
                                                (split -9)
                                                (("1"
                                                  (inst -1 "local")
                                                  (("1"
                                                    (split -1)
                                                    (("1"
                                                      (rewrite
                                                       "appearsFree?_stmt_locals_count_def")
                                                      nil
                                                      nil)
                                                     ("2"
                                                      (assert)
                                                      nil
                                                      nil))
                                                    nil))
                                                  nil)
                                                 ("2"
                                                  (use
                                                   "well_formed_ite_else")
                                                  (("2"
                                                    (assert)
                                                    nil
                                                    nil))
                                                  nil)
                                                 ("3" (propax) nil nil)
                                                 ("4"
                                                  (expand
                                                   "stable_ceb_filter")
                                                  (("4"
                                                    (assert)
                                                    nil
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil)
                       ("4" (use "propag_def_r")
                        (("4" (assert)
                          (("4" (hide -2)
                            (("4" (skeep -1 :preds? t)
                              (("4"
                                (skeep 1)
                                (("4"
                                  (replace -2 :hide? t)
                                  (("4"
                                    (rewrite
                                     "appears?_rform_int_def_and")
                                    (("4"
                                      (split -6)
                                      (("1"
                                        (rewrite
                                         "appears?_rform_int_def")
                                        (("1"
                                          (rewrite
                                           "appearsFree?_form_rform")
                                          nil
                                          nil))
                                        nil)
                                       ("2"
                                        (rewrite
                                         "then_else_unstable_ceb_def")
                                        (("2"
                                          (assert)
                                          (("2"
                                            (skeep -2 :preds? t)
                                            (("2"
                                              (inst
                                               -8
                                               "nargs"
                                               "env"
                                               "thenceb")
                                              (("2"
                                                (split -8)
                                                (("1"
                                                  (inst -1 "local")
                                                  (("1"
                                                    (split -1)
                                                    (("1"
                                                      (rewrite
                                                       "appearsFree?_stmt_locals_count_def")
                                                      nil
                                                      nil)
                                                     ("2"
                                                      (assert)
                                                      nil
                                                      nil))
                                                    nil))
                                                  nil)
                                                 ("2"
                                                  (use
                                                   "well_formed_ite_then")
                                                  (("2"
                                                    (assert)
                                                    nil
                                                    nil))
                                                  nil)
                                                 ("3" (propax) nil nil)
                                                 ("4"
                                                  (expand
                                                   "stable_ceb_filter")
                                                  (("4"
                                                    (assert)
                                                    nil
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("3" (skolem 1 "expr")
      (("3" (skeep :preds? t)
        (("3" (expand "sem" -6)
          (("3" (use "appears_free_rconds_expr")
            (("3" (assert)
              (("3" (use "well_formed_aexpr")
                (("3" (assert)
                  (("3" (expand "appearsFree?" 1)
                    (("3" (expand "appearsFree?" 1)
                      (("3" (expand "appears?" -2 2)
                        (("3" (skolem 1 "local")
                          (("3" (inst -2 "local")
                            (("3" (flatten)
                              (("3"
                                (assert)
                                (("3"
                                  (use
                                   "validEnvironmentForStmt_no_free_var")
                                  nil
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("4" (skolem 1 ("expr" "body"))
      (("4" (flatten)
        (("4" (skeep :preds? t)
          (("4" (expand "sem" -7)
            (("4" (use "unreplaced_var_ceb_in_dom")
              (("4" (assert)
                (("4" (skolem -1 "ceb_body")
                  (("4" (flatten)
                    (("4" (skeep 1 :preds? t)
                      (("4" (case "appears?(expr)(local)")
                        (("1"
                          (rewrite
                           "appearsFree?_stmt_locals_count_def")
                          (("1"
                            (rewrite "appearsFree?_stmt_int_def_letin")
                            (("1" (flatten)
                              (("1"
                                (expand "appears?" -1)
                                (("1" (propax) nil nil))
                                nil))
                              nil))
                            nil))
                          nil)
                         ("2" (assert)
                          (("2" (hide 1)
                            (("2"
                              (lemma
                               "var_appears_in_replaced_rconds_dec_var_appears_in_orig_rconds")
                              (("2"
                                (inst
                                 -1
                                 "ceb_body"
                                 "expr"
                                 "index(local)")
                                (("2"
                                  (split -1)
                                  (("1"
                                    (use "well_formed_letin_body")
                                    (("1"
                                      (assert)
                                      (("1"
                                        (inst
                                         -9
                                         "nargs"
                                         "cons(sem(expr,nargs,env),env)"
                                         "ceb_body")
                                        (("1"
                                          (split -9)
                                          (("1"
                                            (expand "appearsFree?" 1)
                                            (("1"
                                              (expand "appearsFree?" 1)
                                              (("1"
                                                (inst
                                                 -1
                                                 "FPVariable(index(local)+1)")
                                                (("1"
                                                  (split -1)
                                                  (("1"
                                                    (lemma
                                                     "appearsFree?_inc_var")
                                                    (("1"
                                                      (inst?
                                                       -1
                                                       :where
                                                       1)
                                                      (("1"
                                                        (case
                                                         "FPVariable(index(local)) = local")
                                                        (("1"
                                                          (assert)
                                                          (("1"
                                                            (inst
                                                             -2
                                                             "0"
                                                             "index(local)")
                                                            (("1"
                                                              (assert)
                                                              (("1"
                                                                (split
                                                                 -2)
                                                                (("1"
                                                                  (assert)
                                                                  nil
                                                                  nil)
                                                                 ("2"
                                                                  (grind)
                                                                  nil
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil)
                                                         ("2"
                                                          (apply-extensionality)
                                                          nil
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil)
                                                   ("2"
                                                    (assert)
                                                    nil
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil)
                                           ("2"
                                            (expand "length" 1)
                                            (("2" (propax) nil nil))
                                            nil)
                                           ("3"
                                            (lemma
                                             "wellFormed?_env_monotonocity")
                                            (("3"
                                              (inst
                                               -1
                                               "cons(sem(expr,nargs,env),env)"
                                               "nargs"
                                               "length(env)")
                                              (("3"
                                                (split -1)
                                                (("1"
                                                  (inst? -1 :where 1)
                                                  (("1"
                                                    (expand
                                                     "length"
                                                     1
                                                     1)
                                                    (("1"
                                                      (assert)
                                                      nil
                                                      nil))
                                                    nil))
                                                  nil)
                                                 ("2"
                                                  (hide 2)
                                                  (("2"
                                                    (use
                                                     "wellFormed?_env_ext")
                                                    (("2"
                                                      (assert)
                                                      (("2"
                                                        (hide 2)
                                                        (("2"
                                                          (use
                                                           "well_formed_env_implies_well_formed_sem_aexpr")
                                                          (("2"
                                                            (assert)
                                                            (("2"
                                                              (use
                                                               "well_formed_letin_expr")
                                                              (("2"
                                                                (assert)
                                                                nil
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil)
                                           ("4" (propax) nil nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil)
                                   ("2"
                                    (case
                                     "FPVariable(index(local)) = local")
                                    (("1" (assert) nil nil)
                                     ("2"
                                      (apply-extensionality)
                                      nil
                                      nil))
                                    nil)
                                   ("3"
                                    (case
                                     "local = FPVariable(index(local))")
                                    (("1" (assert) nil nil)
                                     ("2"
                                      (apply-extensionality)
                                      nil
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("5" (hide 2)
      (("5" (skeep*)
        (("5" (expand "FtoR") (("5" (propax) nil nil)) nil)) nil))
      nil))
    nil)
   ((unreplaced_var_ceb_in_dom formula-decl nil semantics nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (wellFormed? inductive-decl "bool" expressions nil)
    (validDomain const-decl "bool" semantics nil)
    (sem def-decl "(validDomain)" semantics nil)
    (var_appears_in_replaced_rconds_dec_var_appears_in_orig_rconds
     formula-decl nil semantics nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (odd_minus_odd_is_even application-judgement "even_int" integers
     nil)
    (FPAExpr_FPVariable_extensionality formula-decl nil expressions
     nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (appearsFree?_inc_var formula-decl nil program nil)
    (FPVariable adt-constructor-decl "[DeBruijnIndex -> (FPVariable?)]"
     expressions nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (well_formed_env_implies_well_formed_sem_aexpr formula-decl nil
     semantics nil)
    (well_formed_letin_expr formula-decl nil program nil)
    (wellFormed?_env_ext formula-decl nil semantics nil)
    (upfrom nonempty-type-eq-decl nil integers nil)
    (expr skolem-const-decl
          "FPAExpr[Operator, RealNumber, FloatingPointNumber, FtoR]"
          semantics nil)
    (nargs skolem-const-decl "nat" semantics nil)
    (env skolem-const-decl "(validEnvironmentForStmt)" semantics nil)
    (wellFormed?_env_monotonocity formula-decl nil semantics nil)
    (well_formed_letin_body formula-decl nil program nil)
    (DeBruijnIndex nonempty-type-eq-decl nil expressions nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (FPParameter? adt-recognizer-decl "[FPAExpr -> boolean]"
     expressions nil)
    (index shared-adt-accessor-decl
           "[{x: FPAExpr | FPVariable?(x) OR FPParameter?(x)} -> DeBruijnIndex]"
           expressions nil)
    (LETIN adt-constructor-decl
     "[[FPAExpr[Operator, RealNumber, FloatingPointNumber, FtoR], FPStmt] ->
   (LetIn?)]" program nil)
    (LetIn? adt-recognizer-decl "[FPStmt -> boolean]" program nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (odd_plus_even_is_odd application-judgement "odd_int" integers nil)
    (appearsFree?_stmt_int_def_letin formula-decl nil program nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (validEnvironmentForStmt_no_free_var formula-decl nil semantics
     nil)
    (appears? const-decl "bool" expressions nil)
    (well_formed_aexpr formula-decl nil program nil)
    (appears_free_rconds_expr formula-decl nil semantics nil)
    (appearsFree? def-decl "bool" program nil)
    (union const-decl "set" sets nil)
    (appearsFree?_form_rform formula-decl nil expressions nil)
    (appearsFree?_stmt_locals_count_def formula-decl nil program nil)
    (appears?_rform_int_def formula-decl nil expressions nil)
    (well_formed_ite_then formula-decl nil program nil)
    (FtoR def-decl "RBExpr" expressions nil)
    (propag_def_r formula-decl nil domain nil)
    (appears?_rform_int_def_and formula-decl nil expressions nil)
    (well_formed_ite_else formula-decl nil program nil)
    (appears?_rform_int_def_not formula-decl nil expressions nil)
    (RNot adt-constructor-decl "[RBExpr -> (RNot?)]" expressions nil)
    (RNot? adt-recognizer-decl "[RBExpr -> boolean]" expressions nil)
    (FPNot adt-constructor-decl "[FPBExpr -> (FPNot?)]" expressions
     nil)
    (FPNot? adt-recognizer-decl "[FPBExpr -> boolean]" expressions nil)
    (stable_ceb_filter const-decl
     "{result: Domain | FORALL (ceb: (result)): stable?(ceb)}" domain
     nil)
    (else_then_unstable_ceb_def formula-decl nil semantics nil)
    (else_then_unstable_ceb const-decl "Domain" semantics nil)
    (then_else_unstable_ceb_def formula-decl nil semantics nil)
    (then_else_unstable_ceb const-decl "Domain" semantics nil)
    (member const-decl "bool" sets nil)
    (singleton const-decl "(singleton?)" sets nil)
    (make_ceb const-decl "CEB" domain nil)
    (appearsFree? def-decl "bool" expressions nil)
    (FPStmt_induction formula-decl nil program nil)
    (Operator formal-nonempty-type-decl nil semantics nil)
    (RealNumber formal-nonempty-type-decl nil semantics nil)
    (FloatingPointNumber formal-nonempty-type-decl nil semantics nil)
    (FtoR formal-const-decl "[FloatingPointNumber -> RealNumber]"
     semantics nil)
    (appearsFree? const-decl "bool" program nil)
    (FtoR def-decl "RAExpr" expressions nil)
    (appears? const-decl "bool" expressions nil)
    (RVariable? adt-recognizer-decl "[RAExpr -> boolean]" expressions
     nil)
    (RAExpr type-decl nil expressions nil)
    (FPVariable? adt-recognizer-decl "[FPAExpr -> boolean]" expressions
     nil)
    (FPAExpr type-decl nil expressions nil)
    (sem def-decl
     "{d: Domain | EXISTS (ceb: CEB): d(ceb) AND stable?(ceb)}"
     semantics nil)
    (wellFormed? def-decl "bool" semantics nil)
    (length def-decl "nat" list_props nil)
    (Domain type-eq-decl nil domain nil)
    (wellFormed? inductive-decl "bool" program nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (validEnvironmentForStmt const-decl "bool" semantics nil)
    (Environment nonempty-type-eq-decl nil semantics nil)
    (finite_nonempty? const-decl "bool" more_set_defs "sets_aux/")
    (every adt-def-decl "boolean" list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil) (set type-eq-decl nil sets nil)
    (CEB type-eq-decl nil domain nil)
    (RAExprDomain type-decl nil domain nil)
    (RBExpr type-decl nil expressions nil)
    (FPAExprDomain type-decl nil domain nil)
    (applyFun_fp formal-const-decl
     "[[Operator, FloatingPointNumber, FloatingPointNumber] ->
   FloatingPointNumber]" semantics nil)
    (lt_fp formal-const-decl
     "(strict_total_order?[FloatingPointNumber])" semantics nil)
    (applyFun_r formal-const-decl
     "[[Operator, RealNumber, RealNumber] -> RealNumber]" semantics
     nil)
    (lt_r formal-const-decl "(strict_total_order?[RealNumber])"
     semantics nil)
    (strict_total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (FPBExpr type-decl nil expressions nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (FPStmt type-decl nil program nil)
    (ftor_fpvar_rvar_j application-judgement "(RVariable?)" semantics
     nil))
   nil))
 (mli_af_stmt_form 0
  (mli_af_stmt_form-1 nil 3754480703
   ("" (skeep)
    (("" (use "max_local_index_fpform_def")
      (("" (split -1)
        (("1" (flatten)
          (("1" (use "max_local_index_def")
            (("1" (split -1)
              (("1" (flatten)
                (("1" (hide -1 -4)
                  (("1" (skeep -1 :but (("local" "v_stmt")) :preds? t)
                    (("1"
                      (skeep -5 :but (("local" "v_form")) :preds? t)
                      (("1" (inst -6 "v_form")
                        (("1" (inst -8 "v_stmt")
                          (("1" (assert) nil nil)
                           ("2" (inst -8 "v_stmt")
                            (("2" (assert) nil nil)) nil))
                          nil)
                         ("2" (inst -8 "v_form")
                          (("2" (assert) nil nil)) nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("2" (grind) nil nil))
              nil))
            nil))
          nil)
         ("2" (flatten)
          (("2" (use "max_local_index_def")
            (("2" (split -1)
              (("1" (flatten) (("1" (grind) nil nil)) nil)
               ("2" (grind) nil nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((max_local_index_fpform_def formula-decl nil expressions nil)
    (Operator formal-nonempty-type-decl nil semantics nil)
    (RealNumber formal-nonempty-type-decl nil semantics nil)
    (FloatingPointNumber formal-nonempty-type-decl nil semantics nil)
    (FtoR formal-const-decl "[FloatingPointNumber -> RealNumber]"
     semantics nil)
    (FPBExpr type-decl nil expressions nil)
    (v_stmt skolem-const-decl
     "{local: (FPVariable?) | appearsFree?(stmt)(local)}" semantics
     nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (FPAExpr type-decl nil expressions nil)
    (boolean nonempty-type-decl nil booleans nil)
    (FPVariable? adt-recognizer-decl "[FPAExpr -> boolean]" expressions
     nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (appearsFree? const-decl "bool" program nil)
    (stmt skolem-const-decl
     "FPStmt[Operator, RealNumber, FloatingPointNumber, FtoR]"
     semantics nil)
    (appears? const-decl "bool" expressions nil)
    (form skolem-const-decl
     "FPBExpr[Operator, RealNumber, FloatingPointNumber, FtoR]"
     semantics nil)
    (v_form skolem-const-decl
     "{local: (FPVariable?[Operator, RealNumber, FloatingPointNumber, FtoR]) |
         appears?(form)(local)}" semantics nil)
    (minus_odd_is_odd application-judgement "odd_int" integers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (FPStmt type-decl nil program nil)
    (max_local_index_def formula-decl nil program nil))
   shostak))
 (mli_af_form_stmt_inclusion 0
  (mli_af_form_stmt_inclusion-2 nil 3754482047
   ("" (skeep)
    (("" (use "max_local_index_fpform_def")
      (("" (split -1)
        (("1" (flatten)
          (("1" (use "max_local_index_def")
            (("1" (split -1)
              (("1" (flatten)
                (("1" (hide -1 -4)
                  (("1" (skeep -1 :but (("local" "v_stmt")) :preds? t)
                    (("1"
                      (skeep -5 :but (("local" "v_form")) :preds? t)
                      (("1" (inst -6 "v_form")
                        (("1" (assert) nil nil)
                         ("2" (inst -8 "v_form")
                          (("2" (assert) nil nil)) nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("2" (grind) nil nil))
              nil))
            nil))
          nil)
         ("2" (flatten)
          (("2" (use "max_local_index_def") (("2" (grind) nil nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((max_local_index_fpform_def formula-decl nil expressions nil)
    (Operator formal-nonempty-type-decl nil semantics nil)
    (RealNumber formal-nonempty-type-decl nil semantics nil)
    (FloatingPointNumber formal-nonempty-type-decl nil semantics nil)
    (FtoR formal-const-decl "[FloatingPointNumber -> RealNumber]"
     semantics nil)
    (FPBExpr type-decl nil expressions nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (FPAExpr type-decl nil expressions nil)
    (boolean nonempty-type-decl nil booleans nil)
    (FPVariable? adt-recognizer-decl "[FPAExpr -> boolean]" expressions
     nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (appearsFree? const-decl "bool" program nil)
    (stmt skolem-const-decl
     "FPStmt[Operator, RealNumber, FloatingPointNumber, FtoR]"
     semantics nil)
    (appears? const-decl "bool" expressions nil)
    (form skolem-const-decl
     "FPBExpr[Operator, RealNumber, FloatingPointNumber, FtoR]"
     semantics nil)
    (v_form skolem-const-decl
     "{local: (FPVariable?[Operator, RealNumber, FloatingPointNumber, FtoR]) |
         appears?(form)(local)}" semantics nil)
    (minus_odd_is_odd application-judgement "odd_int" integers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (FPStmt type-decl nil program nil)
    (max_local_index_def formula-decl nil program nil))
   nil)
  (mli_af_form_stmt_inclusion-1 nil 3754482029 ("" (postpone) nil nil)
   nil shostak))
 (mli_af_rform_stmt_inclusion 0
  (mli_af_rform_stmt_inclusion-1 nil 3755253442
   ("" (skeep)
    (("" (use "max_local_index_rform_def")
      (("" (split -1)
        (("1" (flatten)
          (("1" (use "max_local_index_def")
            (("1" (split -1)
              (("1" (flatten)
                (("1" (hide -1 -4)
                  (("1" (skeep -1 :but (("local" "v_stmt")) :preds? t)
                    (("1"
                      (skeep -5 :but (("local" "v_form")) :preds? t)
                      (("1"
                        (case "EXISTS(fpv: (FPVariable?)): FtoR(fpv) = v_form")
                        (("1" (skeep -1)
                          (("1" (inst -7 "fpv")
                            (("1" (replace -8 :dir rl)
                              (("1"
                                (expand "FtoR" -1)
                                (("1"
                                  (replace -1 :hide? t :dir rl)
                                  (("1" (assert) nil nil))
                                  nil))
                                nil))
                              nil)
                             ("2" (inst -9 "fpv")
                              (("2" (assert) nil nil)) nil))
                            nil))
                          nil)
                         ("2" (inst 1 "FPVariable(index(v_form))")
                          (("2" (expand "FtoR")
                            (("2" (apply-extensionality) nil nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("2" (flatten)
                (("2" (skeep -2 :but (("local" "v_form")) :preds? t)
                  (("2" (inst -6 "FPVariable(index(v_form))")
                    (("2" (expand "FtoR")
                      (("2" (split -6)
                        (("1" (inst? 1) nil nil)
                         ("2"
                          (case "RVariable(index(v_form)) = v_form")
                          (("1" (assert) nil nil)
                           ("2" (apply-extensionality) nil nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (flatten)
          (("2" (use "max_local_index_def") (("2" (grind) nil nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((max_local_index_rform_def formula-decl nil expressions nil)
    (Operator formal-nonempty-type-decl nil semantics nil)
    (RealNumber formal-nonempty-type-decl nil semantics nil)
    (FloatingPointNumber formal-nonempty-type-decl nil semantics nil)
    (FtoR formal-const-decl "[FloatingPointNumber -> RealNumber]"
     semantics nil)
    (RBExpr type-decl nil expressions nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (DeBruijnIndex nonempty-type-eq-decl nil expressions nil)
    (FPVariable adt-constructor-decl "[DeBruijnIndex -> (FPVariable?)]"
     expressions nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (RParameter? adt-recognizer-decl "[RAExpr -> boolean]" expressions
     nil)
    (index shared-adt-accessor-decl
           "[{x: RAExpr | RVariable?(x) OR RParameter?(x)} -> DeBruijnIndex]"
           expressions nil)
    (RVariable adt-constructor-decl "[DeBruijnIndex -> (RVariable?)]"
     expressions nil)
    (RAExpr_RVariable_extensionality formula-decl nil expressions nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (fpv skolem-const-decl "(FPVariable?)" semantics nil)
    (stmt skolem-const-decl
     "FPStmt[Operator, RealNumber, FloatingPointNumber, FtoR]"
     semantics nil)
    (appearsFree? const-decl "bool" program nil)
    (ftor_fpvar_rvar_j application-judgement "(RVariable?)" semantics
     nil)
    (FPAExpr type-decl nil expressions nil)
    (boolean nonempty-type-decl nil booleans nil)
    (FPVariable? adt-recognizer-decl "[FPAExpr -> boolean]" expressions
     nil)
    (RAExpr type-decl nil expressions nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (FtoR def-decl "RAExpr" expressions nil)
    (RVariable? adt-recognizer-decl "[RAExpr -> boolean]" expressions
     nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (appears? const-decl "bool" expressions nil)
    (minus_odd_is_odd application-judgement "odd_int" integers nil)
    (FPStmt type-decl nil program nil)
    (max_local_index_def formula-decl nil program nil))
   nil))
 (max_local_index_ceb_cond 0
  (max_local_index_ceb_cond-5 "" 3754480188
   ("" (skeep)
    (("" (use "appears_free_fpconds")
      (("" (assert)
        (("" (use "mli_af_form_stmt_inclusion") (("" (assert) nil nil))
          nil))
        nil))
      nil))
    nil)
   ((appears_free_fpconds formula-decl nil semantics nil)
    (validEnvironmentForStmt const-decl "bool" semantics nil)
    (Environment nonempty-type-eq-decl nil semantics nil)
    (finite_nonempty? const-decl "bool" more_set_defs "sets_aux/")
    (every adt-def-decl "boolean" list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil) (set type-eq-decl nil sets nil)
    (CEB type-eq-decl nil domain nil)
    (RAExprDomain type-decl nil domain nil)
    (RBExpr type-decl nil expressions nil)
    (FPAExprDomain type-decl nil domain nil)
    (applyFun_fp formal-const-decl
     "[[Operator, FloatingPointNumber, FloatingPointNumber] ->
   FloatingPointNumber]" semantics nil)
    (lt_fp formal-const-decl
     "(strict_total_order?[FloatingPointNumber])" semantics nil)
    (applyFun_r formal-const-decl
     "[[Operator, RealNumber, RealNumber] -> RealNumber]" semantics
     nil)
    (lt_r formal-const-decl "(strict_total_order?[RealNumber])"
     semantics nil)
    (strict_total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (FPBExpr type-decl nil expressions nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (FPStmt type-decl nil program nil)
    (FtoR formal-const-decl "[FloatingPointNumber -> RealNumber]"
     semantics nil)
    (FloatingPointNumber formal-nonempty-type-decl nil semantics nil)
    (RealNumber formal-nonempty-type-decl nil semantics nil)
    (Operator formal-nonempty-type-decl nil semantics nil)
    (mli_af_form_stmt_inclusion formula-decl nil semantics nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (minus_odd_is_odd application-judgement "odd_int" integers nil)
    (int_max application-judgement "{k: int | i <= k AND j <= k}"
     real_defs nil)
    (rat_max application-judgement "{s: rat | s >= q AND s >= r}"
     real_defs nil))
   shostak)
  (max_local_index_ceb_cond-4 "" 3754309632
   ("" (induct "stmt")
    (("1" (skeep :preds? t)
      (("1" (expand "sem" -6)
        (("1" (expand "singleton" -6)
          (("1" (replace -6 :hide? t)
            (("1" (expand "make_ceb")
              (("1" (expand "maxFreeLocalIndex" 1 1)
                (("1" (assert) nil nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("2" (skolem 1 ("guard" "thenb" "elseb"))
      (("2" (flatten)
        (("2" (skeep)
          (("2" (rewrite "max_local_index_stmt__ite")
            (("2" (expand "sem" -5)
              (("2" (expand "union")
                (("2" (expand "member")
                  (("2" (split -5)
                    (("1" (use "propag_def")
                      (("1" (assert)
                        (("1" (skeep :preds? t)
                          (("1" (replace -2 :hide? t)
                            (("1"
                              (rewrite "max_local_index_stmt_and_def")
                              (("1"
                                (expand "max" 1 1)
                                (("1"
                                  (lift-if 1)
                                  (("1"
                                    (split 1)
                                    (("1"
                                      (flatten)
                                      (("1"
                                        (inst -4 "nargs" "env" "ceb_0")
                                        (("1"
                                          (split -4)
                                          (("1"
                                            (hide-all-but (-1 -2 1))
                                            (("1" (grind) nil nil))
                                            nil)
                                           ("2"
                                            (use
                                             "well_formed_ite_then")
                                            (("2" (assert) nil nil))
                                            nil)
                                           ("3" (propax) nil nil)
                                           ("4" (propax) nil nil))
                                          nil))
                                        nil))
                                      nil)
                                     ("2"
                                      (flatten)
                                      (("2"
                                        (hide-all-but 2)
                                        (("2" (grind) nil nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil)
                     ("2" (use "propag_def")
                      (("2" (assert)
                        (("2"
                          (skolem -1 "ceb_else" :skolem-typepreds? t)
                          (("2" (replace -2 :hide? t)
                            (("2"
                              (rewrite "max_local_index_stmt_and_def")
                              (("2"
                                (expand "max" 1 1)
                                (("2"
                                  (lift-if 1)
                                  (("2"
                                    (split 1)
                                    (("1"
                                      (flatten)
                                      (("1"
                                        (inst
                                         -5
                                         "nargs"
                                         "env"
                                         "ceb_else")
                                        (("1"
                                          (split -5)
                                          (("1"
                                            (hide-all-but (-1 -2 1))
                                            (("1" (grind) nil nil))
                                            nil)
                                           ("2"
                                            (use
                                             "well_formed_ite_else")
                                            (("2" (assert) nil nil))
                                            nil)
                                           ("3" (propax) nil nil)
                                           ("4" (propax) nil nil))
                                          nil))
                                        nil))
                                      nil)
                                     ("2"
                                      (flatten)
                                      (("2"
                                        (hide-all-but 2)
                                        (("2" (grind) nil nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil)
                     ("3" (use "propag_def")
                      (("3" (assert)
                        (("3" (skeep :preds? t)
                          (("3" (replace -2 :hide? t)
                            (("3"
                              (rewrite "max_local_index_stmt_and_def")
                              (("3"
                                (expand "max" 1 1)
                                (("3"
                                  (lift-if 1)
                                  (("3"
                                    (split 1)
                                    (("1"
                                      (flatten)
                                      (("1"
                                        (rewrite
                                         "else_then_unstable_ceb_def"
                                         -2)
                                        (("1"
                                          (assert)
                                          (("1"
                                            (skeep -2 :preds? t)
                                            (("1"
                                              (replace -5 :hide? t)
                                              (("1"
                                                (inst
                                                 -8
                                                 "nargs"
                                                 "env"
                                                 "thenceb")
                                                (("1"
                                                  (split -8)
                                                  (("1"
                                                    (hide-all-but
                                                     (-1 1))
                                                    (("1"
                                                      (grind)
                                                      nil
                                                      nil))
                                                    nil)
                                                   ("2"
                                                    (use
                                                     "well_formed_ite_then")
                                                    (("2"
                                                      (assert)
                                                      nil
                                                      nil))
                                                    nil)
                                                   ("3"
                                                    (propax)
                                                    nil
                                                    nil)
                                                   ("4"
                                                    (expand
                                                     "stable_ceb_filter")
                                                    (("4"
                                                      (flatten)
                                                      nil
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil)
                                     ("2"
                                      (use "propag_def")
                                      (("2" (assert) nil nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil)
                     ("4" (use "propag_def")
                      (("4" (assert)
                        (("4" (skeep :preds? t)
                          (("4" (replace -2 :hide? t)
                            (("4"
                              (rewrite "max_local_index_stmt_and_def")
                              (("4"
                                (expand "max" 1 1)
                                (("4"
                                  (lift-if 1)
                                  (("4"
                                    (split 1)
                                    (("1"
                                      (flatten)
                                      (("1"
                                        (rewrite
                                         "then_else_unstable_ceb_def")
                                        (("1"
                                          (assert)
                                          (("1"
                                            (skeep :preds? t)
                                            (("1"
                                              (replace -5 :hide? t)
                                              (("1"
                                                (inst
                                                 -9
                                                 "nargs"
                                                 "env"
                                                 "elseceb")
                                                (("1"
                                                  (split -9)
                                                  (("1"
                                                    (hide-all-but
                                                     (-1 1))
                                                    (("1"
                                                      (grind)
                                                      nil
                                                      nil))
                                                    nil)
                                                   ("2"
                                                    (use
                                                     "well_formed_ite_else")
                                                    (("2"
                                                      (assert)
                                                      nil
                                                      nil))
                                                    nil)
                                                   ("3"
                                                    (propax)
                                                    nil
                                                    nil)
                                                   ("4"
                                                    (expand
                                                     "stable_ceb_filter")
                                                    (("4"
                                                      (assert)
                                                      nil
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil)
                                     ("2"
                                      (flatten)
                                      (("2"
                                        (hide-all-but 2)
                                        (("2" (grind) nil nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("3" (skolem 1 "expr")
      (("3" (skeep)
        (("3" (rewrite "max_local_index_stmt__aexpr")
          (("3" (expand "sem" -3)
            (("3" (use "max_local_index_ceb_aexpr_cond")
              (("3" (assert) nil nil)) nil))
            nil))
          nil))
        nil))
      nil)
     ("4" (skolem 1 ("expr" "body"))
      (("4" (flatten)
        (("4" (skeep)
          (("4" (expand "sem" -4)
            (("4" (use "unreplaced_var_ceb_in_dom")
              (("4" (assert)
                (("4" (skolem -1 "ceb_body")
                  (("4" (flatten)
                    (("4"
                      (case "maxFreeLocalIndex(LETIN(expr, body)) = max(maxFreeLocalIndex(expr),maxFreeLocalIndex(body))  OR maxFreeLocalIndex(LETIN(expr, body)) = maxFreeLocalIndex(body) - 1")
                      (("1" (split -1)
                        (("1" (replace -1 :hide? t)
                          (("1" (replace -2 :hide? t :dir rl)
                            (("1"
                              (use "max_local_index_fpconds_replaced_var_ceb")
                              (("1"
                                (inst
                                 -3
                                 "nargs"
                                 "cons(sem(expr, nargs, env), env)"
                                 "ceb_body")
                                (("1"
                                  (split -3)
                                  (("1"
                                    (invoke
                                     (case "%1 <= max(%2,%3)")
                                     (! -2 1)
                                     (! -2 2 1)
                                     (! -1 2))
                                    (("1"
                                      (hide -2 -3)
                                      (("1"
                                        (invoke
                                         (case "%1 = %2")
                                         (! -1 2)
                                         (! 1 2))
                                        (("1" (assert) nil nil)
                                         ("2"
                                          (hide-all-but 1)
                                          (("2"
                                            (use
                                             "max_local_index_env_def")
                                            (("2"
                                              (replace -1 :hide? t)
                                              (("2"
                                                (use
                                                 "max_local_index_aexpr")
                                                (("2" (grind) nil nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil)
                                     ("2"
                                      (hide-all-but (-1 -2 1))
                                      (("2" (grind) nil nil))
                                      nil))
                                    nil)
                                   ("2"
                                    (expand "wellFormed?" -3)
                                    (("2" (grind) nil nil))
                                    nil)
                                   ("3"
                                    (expand "wellFormed?" 1)
                                    (("3"
                                      (split 1)
                                      (("1"
                                        (use
                                         "well_formed_LETIN_propagation")
                                        (("1"
                                          (assert)
                                          (("1"
                                            (flatten)
                                            (("1"
                                              (use
                                               "wellFormed?_fpaexpr_monotonocity")
                                              (("1"
                                                (assert)
                                                (("1"
                                                  (inst
                                                   -1
                                                   "nargs"
                                                   "length(env)+1")
                                                  (("1"
                                                    (use
                                                     "well_formed_env_implies_well_formed_sem_aexpr")
                                                    (("1"
                                                      (assert)
                                                      (("1"
                                                        (expand
                                                         "length"
                                                         1)
                                                        (("1"
                                                          (lemma
                                                           "wellFormed?_env_monotonocity")
                                                          (("1"
                                                            (inst?
                                                             -1
                                                             :where
                                                             -)
                                                            (("1"
                                                              (assert)
                                                              (("1"
                                                                (inst?
                                                                 -1
                                                                 :where
                                                                 1)
                                                                nil
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil)
                                       ("2"
                                        (lemma
                                         "wellFormed?_env_monotonocity")
                                        (("2"
                                          (inst? -1 :where -)
                                          (("2"
                                            (assert)
                                            (("2"
                                              (inst? -1 :where 1)
                                              (("2"
                                                (expand "length" 1 1)
                                                (("2"
                                                  (assert)
                                                  nil
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil)
                                   ("4" (propax) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil)
                         ("2" (postpone) nil nil))
                        nil)
                       ("2" (postpone) nil nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   nil shostak)
  (max_local_index_ceb_cond-3 "" 3753808664
   ("" (induct "stmt")
    (("1" (skeep :preds? t)
      (("1" (expand "sem" -6)
        (("1" (expand "singleton" -6)
          (("1" (replace -6 :hide? t)
            (("1" (expand "make_ceb")
              (("1" (expand "maxFreeLocalIndex" 1 1)
                (("1" (assert) nil nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("2" (skolem 1 ("guard" "thenb" "elseb"))
      (("2" (flatten)
        (("2" (skeep)
          (("2" (rewrite "max_local_index_stmt__ite")
            (("2" (expand "sem" -5)
              (("2" (expand "union")
                (("2" (expand "member")
                  (("2" (split -5)
                    (("1" (use "propag_def")
                      (("1" (assert)
                        (("1" (skeep :preds? t)
                          (("1" (replace -2 :hide? t)
                            (("1"
                              (rewrite "max_local_index_stmt_and_def")
                              (("1"
                                (expand "max" 1 1)
                                (("1"
                                  (lift-if 1)
                                  (("1"
                                    (split 1)
                                    (("1"
                                      (flatten)
                                      (("1"
                                        (inst -4 "nargs" "env" "ceb_0")
                                        (("1"
                                          (split -4)
                                          (("1"
                                            (hide-all-but (-1 -2 1))
                                            (("1" (grind) nil nil))
                                            nil)
                                           ("2"
                                            (use
                                             "well_formed_ite_then")
                                            (("2" (assert) nil nil))
                                            nil)
                                           ("3" (propax) nil nil)
                                           ("4" (propax) nil nil))
                                          nil))
                                        nil))
                                      nil)
                                     ("2"
                                      (flatten)
                                      (("2"
                                        (hide-all-but 2)
                                        (("2" (grind) nil nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil)
                     ("2" (use "propag_def")
                      (("2" (assert)
                        (("2"
                          (skolem -1 "ceb_else" :skolem-typepreds? t)
                          (("2" (replace -2 :hide? t)
                            (("2"
                              (rewrite "max_local_index_stmt_and_def")
                              (("2"
                                (expand "max" 1 1)
                                (("2"
                                  (lift-if 1)
                                  (("2"
                                    (split 1)
                                    (("1"
                                      (flatten)
                                      (("1"
                                        (inst
                                         -5
                                         "nargs"
                                         "env"
                                         "ceb_else")
                                        (("1"
                                          (split -5)
                                          (("1"
                                            (hide-all-but (-1 -2 1))
                                            (("1" (grind) nil nil))
                                            nil)
                                           ("2"
                                            (use
                                             "well_formed_ite_else")
                                            (("2" (assert) nil nil))
                                            nil)
                                           ("3" (propax) nil nil)
                                           ("4" (propax) nil nil))
                                          nil))
                                        nil))
                                      nil)
                                     ("2"
                                      (flatten)
                                      (("2"
                                        (hide-all-but 2)
                                        (("2" (grind) nil nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil)
                     ("3" (use "propag_def")
                      (("3" (assert)
                        (("3" (skeep :preds? t)
                          (("3" (replace -2 :hide? t)
                            (("3"
                              (rewrite "max_local_index_stmt_and_def")
                              (("3"
                                (expand "max" 1 1)
                                (("3"
                                  (lift-if 1)
                                  (("3"
                                    (split 1)
                                    (("1"
                                      (flatten)
                                      (("1"
                                        (rewrite
                                         "else_then_unstable_ceb_def"
                                         -2)
                                        (("1"
                                          (assert)
                                          (("1"
                                            (skeep -2 :preds? t)
                                            (("1"
                                              (replace -5 :hide? t)
                                              (("1"
                                                (inst
                                                 -8
                                                 "nargs"
                                                 "env"
                                                 "thenceb")
                                                (("1"
                                                  (split -8)
                                                  (("1"
                                                    (hide-all-but
                                                     (-1 1))
                                                    (("1"
                                                      (grind)
                                                      nil
                                                      nil))
                                                    nil)
                                                   ("2"
                                                    (use
                                                     "well_formed_ite_then")
                                                    (("2"
                                                      (assert)
                                                      nil
                                                      nil))
                                                    nil)
                                                   ("3"
                                                    (propax)
                                                    nil
                                                    nil)
                                                   ("4"
                                                    (expand
                                                     "stable_ceb_filter")
                                                    (("4"
                                                      (flatten)
                                                      nil
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil)
                                     ("2"
                                      (use "propag_def")
                                      (("2" (assert) nil nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil)
                     ("4" (use "propag_def")
                      (("4" (assert)
                        (("4" (skeep :preds? t)
                          (("4" (replace -2 :hide? t)
                            (("4"
                              (rewrite "max_local_index_stmt_and_def")
                              (("4"
                                (expand "max" 1 1)
                                (("4"
                                  (lift-if 1)
                                  (("4"
                                    (split 1)
                                    (("1"
                                      (flatten)
                                      (("1"
                                        (rewrite
                                         "then_else_unstable_ceb_def")
                                        (("1"
                                          (assert)
                                          (("1"
                                            (skeep :preds? t)
                                            (("1"
                                              (replace -5 :hide? t)
                                              (("1"
                                                (inst
                                                 -9
                                                 "nargs"
                                                 "env"
                                                 "elseceb")
                                                (("1"
                                                  (split -9)
                                                  (("1"
                                                    (hide-all-but
                                                     (-1 1))
                                                    (("1"
                                                      (grind)
                                                      nil
                                                      nil))
                                                    nil)
                                                   ("2"
                                                    (use
                                                     "well_formed_ite_else")
                                                    (("2"
                                                      (assert)
                                                      nil
                                                      nil))
                                                    nil)
                                                   ("3"
                                                    (propax)
                                                    nil
                                                    nil)
                                                   ("4"
                                                    (expand
                                                     "stable_ceb_filter")
                                                    (("4"
                                                      (assert)
                                                      nil
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil)
                                     ("2"
                                      (flatten)
                                      (("2"
                                        (hide-all-but 2)
                                        (("2" (grind) nil nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("3" (skolem 1 "expr")
      (("3" (skeep)
        (("3" (rewrite "max_local_index_stmt__aexpr")
          (("3" (expand "sem" -3)
            (("3" (use "max_local_index_ceb_aexpr_cond")
              (("3" (assert) nil nil)) nil))
            nil))
          nil))
        nil))
      nil)
     ("4" (skolem 1 ("expr" "body"))
      (("4" (flatten)
        (("4" (skeep)
          (("4" (expand "sem" -4)
            (("4" (use "unreplaced_var_ceb_in_dom")
              (("4" (assert)
                (("4" (skolem -1 "ceb_body")
                  (("4" (flatten)
                    (("4" (replace -2 :hide? t :dir rl)
                      (("4"
                        (use "max_local_index_fpconds_replaced_var_ceb")
                        (("4"
                          (inst -3 "nargs"
                           "cons(sem(expr, nargs, env), env)"
                           "ceb_body")
                          (("4" (split -3)
                            (("1"
                              (invoke (case "%1 <= max(%2,%3)")
                               (! -2 1) (! -2 2 1) (! -1 2))
                              (("1"
                                (hide -2 -3)
                                (("1"
                                  (expand "maxFreeLocalIndex" 1 2)
                                  (("1"
                                    (invoke
                                     (case "%1 = %2")
                                     (! -1 2)
                                     (! 1 2))
                                    (("1" (assert) nil nil)
                                     ("2"
                                      (hide-all-but 1)
                                      (("2"
                                        (use "max_local_index_env_def")
                                        (("2"
                                          (replace -1 :hide? t)
                                          (("2"
                                            (use
                                             "max_local_index_aexpr")
                                            (("2" (grind) nil nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil)
                               ("2"
                                (hide-all-but (-1 -2 1))
                                (("2" (grind) nil nil))
                                nil))
                              nil)
                             ("2" (expand "wellFormed?" -3)
                              (("2" (grind) nil nil)) nil)
                             ("3" (expand "wellFormed?" 1)
                              (("3"
                                (split 1)
                                (("1"
                                  (use "well_formed_LETIN_propagation")
                                  (("1"
                                    (assert)
                                    (("1"
                                      (flatten)
                                      (("1"
                                        (use
                                         "wellFormed?_fpaexpr_monotonocity")
                                        (("1"
                                          (assert)
                                          (("1"
                                            (inst
                                             -1
                                             "nargs"
                                             "length(env)+1")
                                            (("1"
                                              (use
                                               "well_formed_env_implies_well_formed_sem_aexpr")
                                              (("1"
                                                (assert)
                                                (("1"
                                                  (expand "length" 1)
                                                  (("1"
                                                    (lemma
                                                     "wellFormed?_env_monotonocity")
                                                    (("1"
                                                      (inst?
                                                       -1
                                                       :where
                                                       -)
                                                      (("1"
                                                        (assert)
                                                        (("1"
                                                          (inst?
                                                           -1
                                                           :where
                                                           1)
                                                          nil
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil)
                                 ("2"
                                  (lemma
                                   "wellFormed?_env_monotonocity")
                                  (("2"
                                    (inst? -1 :where -)
                                    (("2"
                                      (assert)
                                      (("2"
                                        (inst? -1 :where 1)
                                        (("2"
                                          (expand "length" 1 1)
                                          (("2" (assert) nil nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil)
                             ("4" (propax) nil nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((finite_nonempty? const-decl "bool" more_set_defs "sets_aux/")
    (CEB type-eq-decl nil domain nil)
    (RAExprDomain type-decl nil domain nil)
    (RBExpr type-decl nil expressions nil)
    (FPAExprDomain type-decl nil domain nil)
    (FPBExpr type-decl nil expressions nil)
    (FPStmt type-decl nil program nil))
   nil)
  (max_local_index_ceb_cond-2 "" 3753390642
   ("" (induct "stmt")
    (("1" (skeep :preds? t)
      (("1" (expand "sem" -6)
        (("1" (expand "singleton" -6)
          (("1" (replace -6 :hide? t)
            (("1" (expand "make_ceb")
              (("1" (expand "maxFreeLocalIndex" 1 1)
                (("1" (assert) nil nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("2" (skolem 1 ("guard" "thenb" "elseb"))
      (("2" (flatten)
        (("2" (skeep)
          (("2" (rewrite "max_local_index_stmt__ite")
            (("2" (expand "sem" -5)
              (("2" (expand "union")
                (("2" (expand "member")
                  (("2" (split -5)
                    (("1" (use "propag_def")
                      (("1" (assert)
                        (("1" (skeep :preds? t)
                          (("1" (replace -2 :hide? t)
                            (("1"
                              (rewrite "max_local_index_stmt_and_def")
                              (("1"
                                (expand "max" 1 1)
                                (("1"
                                  (lift-if 1)
                                  (("1"
                                    (split 1)
                                    (("1"
                                      (flatten)
                                      (("1"
                                        (inst -4 "nargs" "env" "ceb_0")
                                        (("1"
                                          (split -4)
                                          (("1"
                                            (hide-all-but (-1 -2 1))
                                            (("1" (grind) nil nil))
                                            nil)
                                           ("2"
                                            (use
                                             "well_formed_ite_then")
                                            (("2" (assert) nil nil))
                                            nil)
                                           ("3" (propax) nil nil)
                                           ("4" (propax) nil nil))
                                          nil))
                                        nil))
                                      nil)
                                     ("2"
                                      (flatten)
                                      (("2"
                                        (hide-all-but 2)
                                        (("2" (grind) nil nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil)
                     ("2" (use "propag_def")
                      (("2" (assert)
                        (("2"
                          (skolem -1 "ceb_else" :skolem-typepreds? t)
                          (("2" (replace -2 :hide? t)
                            (("2"
                              (rewrite "max_local_index_stmt_and_def")
                              (("2"
                                (expand "max" 1 1)
                                (("2"
                                  (lift-if 1)
                                  (("2"
                                    (split 1)
                                    (("1"
                                      (flatten)
                                      (("1"
                                        (inst
                                         -5
                                         "nargs"
                                         "env"
                                         "ceb_else")
                                        (("1"
                                          (split -5)
                                          (("1"
                                            (hide-all-but (-1 -2 1))
                                            (("1" (grind) nil nil))
                                            nil)
                                           ("2"
                                            (use
                                             "well_formed_ite_else")
                                            (("2" (assert) nil nil))
                                            nil)
                                           ("3" (propax) nil nil)
                                           ("4" (propax) nil nil))
                                          nil))
                                        nil))
                                      nil)
                                     ("2"
                                      (flatten)
                                      (("2"
                                        (hide-all-but 2)
                                        (("2" (grind) nil nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil)
                     ("3" (use "propag_def")
                      (("3" (assert)
                        (("3" (skeep :preds? t)
                          (("3" (replace -2 :hide? t)
                            (("3"
                              (rewrite "max_local_index_stmt_and_def")
                              (("3"
                                (expand "max" 1 1)
                                (("3"
                                  (lift-if 1)
                                  (("3"
                                    (split 1)
                                    (("1"
                                      (flatten)
                                      (("1"
                                        (expand
                                         "else_then_unstable_ceb")
                                        (("1"
                                          (skeep -2 :preds? t)
                                          (("1"
                                            (replace -7 :hide? t)
                                            (("1"
                                              (inst
                                               -10
                                               "nargs"
                                               "env"
                                               "thenceb")
                                              (("1"
                                                (split -10)
                                                (("1"
                                                  (hide-all-but (-1 1))
                                                  (("1"
                                                    (grind)
                                                    nil
                                                    nil))
                                                  nil)
                                                 ("2"
                                                  (use
                                                   "well_formed_ite_then")
                                                  (("2"
                                                    (assert)
                                                    nil
                                                    nil))
                                                  nil)
                                                 ("3" (propax) nil nil)
                                                 ("4"
                                                  (propax)
                                                  nil
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil)
                                     ("2"
                                      (use "propag_def")
                                      (("2" (assert) nil nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil)
                     ("4" (use "propag_def")
                      (("4" (assert)
                        (("4" (skeep :preds? t)
                          (("4" (replace -2 :hide? t)
                            (("4"
                              (rewrite "max_local_index_stmt_and_def")
                              (("4"
                                (expand "max" 1 1)
                                (("4"
                                  (lift-if 1)
                                  (("4"
                                    (split 1)
                                    (("1"
                                      (flatten)
                                      (("1"
                                        (expand
                                         "then_else_unstable_ceb")
                                        (("1"
                                          (skeep :preds? t)
                                          (("1"
                                            (replace -7 :hide? t)
                                            (("1"
                                              (inst
                                               -11
                                               "nargs"
                                               "env"
                                               "elseceb")
                                              (("1"
                                                (split -11)
                                                (("1"
                                                  (hide-all-but (-1 1))
                                                  (("1"
                                                    (grind)
                                                    nil
                                                    nil))
                                                  nil)
                                                 ("2"
                                                  (use
                                                   "well_formed_ite_else")
                                                  (("2"
                                                    (assert)
                                                    nil
                                                    nil))
                                                  nil)
                                                 ("3" (propax) nil nil)
                                                 ("4"
                                                  (propax)
                                                  nil
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil)
                                     ("2"
                                      (flatten)
                                      (("2"
                                        (hide-all-but 2)
                                        (("2" (grind) nil nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("3" (skolem 1 "expr")
      (("3" (skeep)
        (("3" (rewrite "max_local_index_stmt__aexpr")
          (("3" (expand "sem" -3)
            (("3" (use "max_local_index_ceb_aexpr_cond")
              (("3" (assert) nil nil)) nil))
            nil))
          nil))
        nil))
      nil)
     ("4" (skolem 1 ("expr" "body"))
      (("4" (flatten)
        (("4" (skeep)
          (("4" (expand "sem" -4)
            (("4" (use "unreplaced_var_ceb_in_dom")
              (("4" (assert)
                (("4" (skolem -1 "ceb_body")
                  (("4" (flatten)
                    (("4" (replace -2 :hide? t :dir rl)
                      (("4"
                        (use "max_local_index_fpconds_replaced_var_ceb")
                        (("4"
                          (inst -3 "nargs"
                           "cons(sem(expr, nargs, env), env)"
                           "ceb_body")
                          (("4" (split -3)
                            (("1"
                              (invoke (case "%1 <= max(%2,%3)")
                               (! -2 1) (! -2 2 1) (! -1 2))
                              (("1"
                                (hide -2 -3)
                                (("1"
                                  (expand "maxFreeLocalIndex" 1 2)
                                  (("1"
                                    (invoke
                                     (case "%1 = %2")
                                     (! -1 2)
                                     (! 1 2))
                                    (("1" (assert) nil nil)
                                     ("2"
                                      (hide-all-but 1)
                                      (("2"
                                        (use "max_local_index_env_def")
                                        (("2"
                                          (replace -1 :hide? t)
                                          (("2"
                                            (use
                                             "max_local_index_aexpr")
                                            (("2" (grind) nil nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil)
                               ("2"
                                (hide-all-but (-1 -2 1))
                                (("2" (grind) nil nil))
                                nil))
                              nil)
                             ("2" (expand "wellFormed?" -3)
                              (("2" (grind) nil nil)) nil)
                             ("3" (expand "wellFormed?" 1)
                              (("3"
                                (split 1)
                                (("1"
                                  (use "well_formed_LETIN_propagation")
                                  (("1"
                                    (assert)
                                    (("1"
                                      (flatten)
                                      (("1"
                                        (use
                                         "wellFormed?_fpaexpr_monotonocity")
                                        (("1"
                                          (assert)
                                          (("1"
                                            (inst
                                             -1
                                             "nargs"
                                             "length(env)+1")
                                            (("1"
                                              (use
                                               "well_formed_env_implies_well_formed_sem_aexpr")
                                              (("1"
                                                (assert)
                                                (("1"
                                                  (expand "length" 1)
                                                  (("1"
                                                    (lemma
                                                     "wellFormed?_env_monotonocity")
                                                    (("1"
                                                      (inst?
                                                       -1
                                                       :where
                                                       -)
                                                      (("1"
                                                        (assert)
                                                        (("1"
                                                          (inst?
                                                           -1
                                                           :where
                                                           1)
                                                          nil
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil)
                                 ("2"
                                  (lemma
                                   "wellFormed?_env_monotonocity")
                                  (("2"
                                    (inst? -1 :where -)
                                    (("2"
                                      (assert)
                                      (("2"
                                        (inst? -1 :where 1)
                                        (("2"
                                          (expand "length" 1 1)
                                          (("2" (assert) nil nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil)
                             ("4" (propax) nil nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((well_formed_LETIN_propagation formula-decl nil expressions_props
     nil)
    (wellFormed?_fpaexpr_monotonocity formula-decl nil expressions nil)
    (index shared-adt-accessor-decl
           "[{x: FPAExpr | FPVariable?(x) OR FPParameter?(x)} -> DeBruijnIndex]"
           expressions nil)
    (DeBruijnIndex nonempty-type-eq-decl nil expressions nil)
    (FPParameter? adt-recognizer-decl "[FPAExpr -> boolean]"
     expressions nil)
    (FPVariable? adt-recognizer-decl "[FPAExpr -> boolean]" expressions
     nil)
    (FPAExpr type-decl nil expressions nil)
    (max_local_index_stmt__aexpr formula-decl nil program nil)
    (wellFormed? inductive-decl "bool" expressions nil)
    (FPNot? adt-recognizer-decl "[FPBExpr -> boolean]" expressions nil)
    (FPNot adt-constructor-decl "[FPBExpr -> (FPNot?)]" expressions
     nil)
    (RNot? adt-recognizer-decl "[RBExpr -> boolean]" expressions nil)
    (RNot adt-constructor-decl "[RBExpr -> (RNot?)]" expressions nil)
    (well_formed_ite_else formula-decl nil program nil)
    (propag_def formula-decl nil domain nil)
    (FtoR def-decl "RBExpr" expressions nil)
    (max_local_index_stmt_and_def formula-decl nil expressions nil)
    (well_formed_ite_then formula-decl nil program nil)
    (max_local_index_stmt__ite formula-decl nil program nil)
    (make_ceb const-decl "CEB" domain nil)
    (FPStmt_induction formula-decl nil program nil)
    (Domain type-eq-decl nil domain nil)
    (wellFormed? inductive-decl "bool" program nil)
    (finite_nonempty? const-decl "bool" more_set_defs "sets_aux/")
    (CEB type-eq-decl nil domain nil)
    (RAExprDomain type-decl nil domain nil)
    (RBExpr type-decl nil expressions nil)
    (FPAExprDomain type-decl nil domain nil)
    (FPBExpr type-decl nil expressions nil)
    (FPStmt type-decl nil program nil))
   shostak)
  (max_local_index_ceb_cond-1 nil 3753261533
   ("" (induct "stmt")
    (("1" (postpone) nil nil) ("2" (postpone) nil nil)
     ("3" (postpone) nil nil)
     ("4" (skolem 1 ("expr" "body"))
      (("4" (flatten)
        (("4" (skeep)
          (("4" (expand "sem" -4)
            (("4" (use "unreplaced_var_ceb_in_dom")
              (("4" (assert)
                (("4" (skolem -1 "ceb_body")
                  (("4" (flatten)
                    (("4" (replace -2 :hide? t :dir rl)
                      (("4"
                        (use "max_local_index_fpconds_replaced_var_ceb")
                        (("4"
                          (inst -3 "nargs"
                           "cons(sem(expr, nargs, env), env)"
                           "ceb_body")
                          (("4" (split -3)
                            (("1" (postpone) nil nil)
                             ("2" (expand "wellFormed?" -3)
                              (("2" (grind) nil nil)) nil)
                             ("3" (postpone) nil nil)
                             ("4" (propax) nil nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   nil shostak))
 (max_local_index_ceb_rcond 0
  (max_local_index_ceb_rcond-2 nil 3755253117
   ("" (skeep)
    (("" (use "appears_free_rconds")
      (("" (assert)
        (("" (use "mli_af_rform_stmt_inclusion")
          (("" (assert) nil nil)) nil))
        nil))
      nil))
    nil)
   ((appears_free_rconds formula-decl nil semantics nil)
    (validEnvironmentForStmt const-decl "bool" semantics nil)
    (Environment nonempty-type-eq-decl nil semantics nil)
    (finite_nonempty? const-decl "bool" more_set_defs "sets_aux/")
    (every adt-def-decl "boolean" list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil) (set type-eq-decl nil sets nil)
    (CEB type-eq-decl nil domain nil)
    (RAExprDomain type-decl nil domain nil)
    (RBExpr type-decl nil expressions nil)
    (FPAExprDomain type-decl nil domain nil)
    (applyFun_fp formal-const-decl
     "[[Operator, FloatingPointNumber, FloatingPointNumber] ->
   FloatingPointNumber]" semantics nil)
    (lt_fp formal-const-decl
     "(strict_total_order?[FloatingPointNumber])" semantics nil)
    (applyFun_r formal-const-decl
     "[[Operator, RealNumber, RealNumber] -> RealNumber]" semantics
     nil)
    (lt_r formal-const-decl "(strict_total_order?[RealNumber])"
     semantics nil)
    (strict_total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (FPBExpr type-decl nil expressions nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (FPStmt type-decl nil program nil)
    (FtoR formal-const-decl "[FloatingPointNumber -> RealNumber]"
     semantics nil)
    (FloatingPointNumber formal-nonempty-type-decl nil semantics nil)
    (RealNumber formal-nonempty-type-decl nil semantics nil)
    (Operator formal-nonempty-type-decl nil semantics nil)
    (mli_af_rform_stmt_inclusion formula-decl nil semantics nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (minus_odd_is_odd application-judgement "odd_int" integers nil)
    (int_max application-judgement "{k: int | i <= k AND j <= k}"
     real_defs nil)
    (rat_max application-judgement "{s: rat | s >= q AND s >= r}"
     real_defs nil)
    (ftor_fpvar_rvar_j application-judgement "(RVariable?)" semantics
     nil))
   nil)
  (max_local_index_ceb_rcond-1 nil 3755253103
   ("" (skeep)
    (("" (use "appears_free_fpconds")
      (("" (assert)
        (("" (use "mli_af_form_stmt_inclusion")
          (("" (assert) nil))))))))
    nil)
   nil nil))
 (fp_evaluable_in_stmt_evaluable_ceb 0
  (fp_evaluable_in_stmt_evaluable_ceb-4 "using maxFreeLocalIndex"
   3753261516
   ("" (skeep* :preds? t)
    (("" (use "evaluable_in_max_local_index__stmt")
      (("" (assert)
        (("" (use "max_local_index_evaluable_in__form")
          (("" (assert)
            (("" (hide 2)
              (("" (use "max_local_index_ceb_cond")
                (("" (assert)
                  (("" (expand "semanticallyConsistent?")
                    (("" (flatten)
                      (("" (replace -7 :hide? t :dir rl)
                        ((""
                          (case "maxFreeLocalIndex(env) < length(env)")
                          (("1" (hide-all-but (-1 -2 -3 1))
                            (("1" (grind) nil nil)) nil)
                           ("2"
                            (use "max_local_index_env_well_formed_eq")
                            (("2" (assert) nil nil)) nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((evaluable_in_max_local_index__stmt formula-decl nil semantics nil)
    (FPStmt type-decl nil program nil)
    (FPLocalEnvironment type-eq-decl nil expressions_semantics nil)
    (LocalEnvironment nonempty-type-decl nil u_local_environment nil)
    (<< adt-def-decl "(strict_well_founded?[FPAExpr])" expressions nil)
    (strict_well_founded? const-decl "bool" orders nil)
    (fpVarIndex const-decl "nat" expressions_semantics nil)
    (applyFun_fp formal-const-decl
     "[[Operator, FloatingPointNumber, FloatingPointNumber] ->
   FloatingPointNumber]" semantics nil)
    (lt_fp formal-const-decl
     "(strict_total_order?[FloatingPointNumber])" semantics nil)
    (applyFun_r formal-const-decl
     "[[Operator, RealNumber, RealNumber] -> RealNumber]" semantics
     nil)
    (lt_r formal-const-decl "(strict_total_order?[RealNumber])"
     semantics nil)
    (strict_total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (FPVariable? adt-recognizer-decl "[FPAExpr -> boolean]" expressions
     nil)
    (FPAExpr type-decl nil expressions nil)
    (FtoR formal-const-decl "[FloatingPointNumber -> RealNumber]"
     semantics nil)
    (FloatingPointNumber formal-nonempty-type-decl nil semantics nil)
    (RealNumber formal-nonempty-type-decl nil semantics nil)
    (Operator formal-nonempty-type-decl nil semantics nil)
    (max_local_index_evaluable_in__form formula-decl nil semantics nil)
    (wellFormed? def-decl "bool" semantics nil)
    (semanticallyConsistent? const-decl "bool" semantics nil)
    (sem def-decl
     "{d: Domain | EXISTS (ceb: CEB): d(ceb) AND stable?(ceb)}"
     semantics nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (length def-decl "nat" list_props nil)
    (Domain type-eq-decl nil domain nil)
    (wellFormed? inductive-decl "bool" program nil)
    (validEnvironmentForStmt const-decl "bool" semantics nil)
    (Environment nonempty-type-eq-decl nil semantics nil)
    (finite_nonempty? const-decl "bool" more_set_defs "sets_aux/")
    (every adt-def-decl "boolean" list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil) (set type-eq-decl nil sets nil)
    (CEB type-eq-decl nil domain nil)
    (RAExprDomain type-decl nil domain nil)
    (RBExpr type-decl nil expressions nil)
    (FPAExprDomain type-decl nil domain nil)
    (FPBExpr type-decl nil expressions nil)
    (< const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (upfrom nonempty-type-eq-decl nil integers nil)
    (maxFreeLocalIndex def-decl "upfrom(-1)" semantics nil)
    (rat_max application-judgement "{s: rat | s >= q AND s >= r}"
     real_defs nil)
    (int_max application-judgement "{k: int | i <= k AND j <= k}"
     real_defs nil)
    (minus_odd_is_odd application-judgement "odd_int" integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (max const-decl "{p: real | p >= m AND p >= n}" real_defs nil)
    (max_local_index_env_well_formed_eq formula-decl nil semantics nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (max_local_index_ceb_cond formula-decl nil semantics nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   shostak)
  (fp_evaluable_in_stmt_evaluable_ceb-3 "" 3753220340
   ("" (induct "stmt")
    (("1" (skeep* :preds? t)
      (("1" (expand "subterm" -)
        (("1" (replace -1 :hide? t)
          (("1" (expand "sem" -7)
            (("1" (expand "singleton")
              (("1" (expand "make_ceb")
                (("1" (replace -7 :hide? t)
                  (("1" (assert)
                    (("1" (expand "bounded_by?" 1)
                      (("1" (propax) nil nil)) nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("2" (skolem 1 ("guard_form" "then_stmt" "else_stmt"))
      (("2" (with-labels (flatten) (("IH then" "IH else" "IT")))
        (("2"
          (with-labels (skeep* "IT" :preds? t)
           (("substmt is subterm of ITE" nil nil nil nil nil
             "env is well formed" "ceb in in the sem of the subterm"
             "evaluable ITE" "show that fpconds(ceb) is evaluable"
             "UNKNOWN")))
          (("2" (expand "subterm" "substmt is subterm of ITE")
            (("2"
              (with-labels (split "substmt is subterm of ITE")
               (("substmt is ITE")
                ("substmt is subterm of then branch")
                ("substmt is subterm of else branch")))
              (("1" (replace "substmt is ITE" :hide? t)
                (("1" (expand "sem" "ceb in in the sem of the subterm")
                  (("1"
                    (expand "union" "ceb in in the sem of the subterm")
                    (("1"
                      (expand "member"
                              "ceb in in the sem of the subterm")
                      (("1"
                        (with-labels
                         (split "ceb in in the sem of the subterm")
                         (("ceb is in propag(sem(then),guard)")
                          ("ceb is in propag(sem(else),NOT(guard))")
                          ("ceb is in unstable case 1")
                          ("ceb is in unstable case 2")))
                        (("1"
                          (with-labels
                           (let ((fnum
                                  (extra-get-fnum
                                   "ceb is in propag(sem(then),guard)")))
                             (invoke (typepred "%1") (! fnum 0)))
                           (("propag(sem(then),guard) is not empty"
                             "propag(sem(then),guard) ceb description, propag(sem(then),guard) side"
                             "propag(sem(then),guard) ceb description, sem(then) side")))
                          (("1"
                            (hide
                             "propag(sem(then),guard) is not empty"
                             "propag(sem(then),guard) ceb description, sem(then) side")
                            (("1"
                              (inst
                               "propag(sem(then),guard) ceb description, propag(sem(then),guard) side"
                               "ceb")
                              (("1"
                                (skolem
                                 "propag(sem(then),guard) ceb description, propag(sem(then),guard) side"
                                 "ceb_then"
                                 :skolem-typepreds?
                                 t)
                                (("1"
                                  (hide "IH else")
                                  (("1"
                                    (inst "IH then" "fpLocalEnv")
                                    (("1"
                                      (with-labels
                                       (split "IH then")
                                       (("substmt ceb is evaluable")
                                        ("then_stmt must be evaluable")))
                                      (("1"
                                        (inst
                                         "substmt ceb is evaluable"
                                         "then_stmt"
                                         "nargs"
                                         "env"
                                         "ceb_then")
                                        (("1"
                                          (replace
                                           "propag(sem(then),guard) ceb description, propag(sem(then),guard) side"
                                           :hide?
                                           t)
                                          (("1"
                                            (expand "make_ceb")
                                            (("1"
                                              (use "evaluable_in_and")
                                              (("1"
                                                (replace -1 :hide? t)
                                                (("1"
                                                  (split
                                                   "show that fpconds(ceb) is evaluable")
                                                  (("1"
                                                    (use
                                                     "fp_evaluable_in_stmt_evaluable_ite")
                                                    (("1"
                                                      (assert)
                                                      nil
                                                      nil))
                                                    nil)
                                                   ("2"
                                                    (propax)
                                                    nil
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil)
                                         ("2"
                                          (use "well_formed_ite_then")
                                          (("2" (assert) nil nil))
                                          nil))
                                        nil)
                                       ("2"
                                        (use
                                         "fp_evaluable_in_stmt_evaluable_ite_then")
                                        (("2" (assert) nil nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil)
                         ("2" (hide "IH then")
                          (("2" (inst "IH else" "fpLocalEnv")
                            (("2"
                              (with-labels
                               (let
                                ((fnum
                                  (extra-get-fnum
                                   "ceb is in propag(sem(else),NOT(guard))")))
                                (invoke (typepred "%1") (! fnum 0)))
                               (("propag(sem(else),NOT guard) is not empty"
                                 "propag(sem(else),NOT guard) ceb description, propag(sem(else),NOT guard) side"
                                 "propag(sem(else),guard) ceb description, sem(then) side")))
                              (("2"
                                (hide
                                 "propag(sem(else),NOT guard) is not empty"
                                 "propag(sem(else),NOT guard) ceb description, sem(then) side")
                                (("2"
                                  (inst
                                   "propag(sem(else),NOT guard) ceb description, propag(sem(else),NOT guard) side"
                                   "ceb")
                                  (("2"
                                    (skolem
                                     "propag(sem(else),NOT guard) ceb description, propag(sem(else),NOT guard) side"
                                     "ceb_else"
                                     :skolem-typepreds?
                                     t)
                                    (("2"
                                      (with-labels
                                       (split "IH else")
                                       (("substmt ceb is evaluable")
                                        ("else_stmt must be evaluable")))
                                      (("1"
                                        (inst
                                         "substmt ceb is evaluable"
                                         "else_stmt"
                                         "nargs"
                                         "env"
                                         "ceb_else")
                                        (("1"
                                          (replace
                                           "propag(sem(else),NOT guard) ceb description, propag(sem(else),NOT guard) side"
                                           :hide?
                                           t)
                                          (("1"
                                            (expand "make_ceb")
                                            (("1"
                                              (use "evaluable_in_and")
                                              (("1"
                                                (replace -1 :hide? t)
                                                (("1"
                                                  (split
                                                   "show that fpconds(ceb) is evaluable")
                                                  (("1"
                                                    (use
                                                     "evaluable_in_not")
                                                    (("1"
                                                      (replace
                                                       -1
                                                       :hide?
                                                       t)
                                                      (("1"
                                                        (use
                                                         "fp_evaluable_in_stmt_evaluable_ite")
                                                        (("1"
                                                          (assert)
                                                          nil
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil)
                                                   ("2"
                                                    (propax)
                                                    nil
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil)
                                         ("2"
                                          (use "well_formed_ite_else")
                                          (("2" (assert) nil nil))
                                          nil))
                                        nil)
                                       ("2"
                                        (use
                                         "fp_evaluable_in_stmt_evaluable_ite_else")
                                        (("2" (assert) nil nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil)
                         ("3"
                          (with-labels
                           (let ((fnum
                                  (extra-get-fnum
                                   "ceb is in unstable case 1")))
                             (invoke (typepred "%1") (! fnum 0)))
                           (("unstable case 1 is not empty"
                             "unstable case 1 ceb description, unstable case 1 side"
                             "unstable case 1 ceb description, sem(then) side")))
                          (("3"
                            (hide "unstable case 1 is not empty"
                             "unstable case 1 ceb description, sem(then) side")
                            (("3"
                              (inst
                               "unstable case 1 ceb description, unstable case 1 side"
                               "ceb")
                              (("3"
                                (with-labels
                                 (skolem
                                  "unstable case 1 ceb description, unstable case 1 side"
                                  "ceb_else_then_unst"
                                  :skolem-typepreds?
                                  t)
                                 (("else_then_unst definition"
                                   "ceb description")))
                                (("3"
                                  (expand
                                   "else_then_unstable_ceb"
                                   "else_then_unst definition")
                                  (("3"
                                    (skolem
                                     "else_then_unst definition"
                                     ("thenceb" "elseceb"))
                                    (("3"
                                      (replace
                                       "ceb description"
                                       "show that fpconds(ceb) is evaluable"
                                       :hide?
                                       t)
                                      (("3"
                                        (expand
                                         "make_ceb"
                                         "show that fpconds(ceb) is evaluable")
                                        (("3"
                                          (with-labels
                                           (flatten
                                            "else_then_unst definition")
                                           (("ceb_else_then_unst`rconds"
                                             "ceb_else_then_unst`fpconds"
                                             "ceb_else_then_unst`rresult"
                                             "ceb_else_then_unst`fpresult"
                                             "ceb_else_then_unst`stable?")))
                                          (("3"
                                            (replace
                                             "ceb_else_then_unst`fpconds"
                                             "show that fpconds(ceb) is evaluable")
                                            (("3"
                                              (use "evaluable_in_and")
                                              (("3"
                                                (replace -1 :hide? t)
                                                (("3"
                                                  (split
                                                   "show that fpconds(ceb) is evaluable")
                                                  (("1"
                                                    (use
                                                     "fp_evaluable_in_stmt_evaluable_ite")
                                                    (("1"
                                                      (assert)
                                                      nil
                                                      nil))
                                                    nil)
                                                   ("2"
                                                    (hide "IH else")
                                                    (("2"
                                                      (inst
                                                       "IH then"
                                                       "fpLocalEnv")
                                                      (("2"
                                                        (with-labels
                                                         (split
                                                          "IH then")
                                                         (("substmt ceb is evaluable")
                                                          ("then_stmt must be evaluable")))
                                                        (("1"
                                                          (inst
                                                           "substmt ceb is evaluable"
                                                           "then_stmt"
                                                           "nargs"
                                                           "env"
                                                           "thenceb")
                                                          (("1"
                                                            (use
                                                             "well_formed_ite_then")
                                                            (("1"
                                                              (assert)
                                                              nil
                                                              nil))
                                                            nil))
                                                          nil)
                                                         ("2"
                                                          (use
                                                           "fp_evaluable_in_stmt_evaluable_ite_then")
                                                          (("2"
                                                            (assert)
                                                            nil
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil)
                         ("4"
                          (with-labels
                           (let ((fnum
                                  (extra-get-fnum
                                   "ceb is in unstable case 2")))
                             (invoke (typepred "%1") (! fnum 0)))
                           (("unstable case 2 is not empty"
                             "unstable case 2 ceb description, unstable case 2 side"
                             "unstable case 2 ceb description, sem(then) side")))
                          (("4"
                            (hide "unstable case 2 is not empty"
                             "unstable case 2 ceb description, sem(then) side")
                            (("4"
                              (inst
                               "unstable case 2 ceb description, unstable case 2 side"
                               "ceb")
                              (("4"
                                (with-labels
                                 (skolem
                                  "unstable case 2 ceb description, unstable case 2 side"
                                  "ceb_then_else_unst"
                                  :skolem-typepreds?
                                  t)
                                 (("then_else_unst definition"
                                   "ceb description")))
                                (("4"
                                  (expand
                                   "then_else_unstable_ceb"
                                   "then_else_unst definition")
                                  (("4"
                                    (skolem
                                     "then_else_unst definition"
                                     ("thenceb" "elseceb"))
                                    (("4"
                                      (replace
                                       "ceb description"
                                       "show that fpconds(ceb) is evaluable"
                                       :hide?
                                       t)
                                      (("4"
                                        (expand
                                         "make_ceb"
                                         "show that fpconds(ceb) is evaluable")
                                        (("4"
                                          (with-labels
                                           (flatten
                                            "then_else_unst definition")
                                           (("ceb_then_else_unst`rconds"
                                             "ceb_then_else_unst`fpconds"
                                             "ceb_then_else_unst`rresult"
                                             "ceb_then_else_unst`fpresult"
                                             "ceb_then_else_unst`stable?")))
                                          (("4"
                                            (replace
                                             "ceb_then_else_unst`fpconds"
                                             "show that fpconds(ceb) is evaluable")
                                            (("4"
                                              (use "evaluable_in_and")
                                              (("4"
                                                (replace -1 :hide? t)
                                                (("4"
                                                  (split
                                                   "show that fpconds(ceb) is evaluable")
                                                  (("1"
                                                    (use
                                                     "evaluable_in_not")
                                                    (("1"
                                                      (replace
                                                       -1
                                                       :hide?
                                                       t)
                                                      (("1"
                                                        (use
                                                         "fp_evaluable_in_stmt_evaluable_ite")
                                                        (("1"
                                                          (assert)
                                                          nil
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil)
                                                   ("2"
                                                    (hide "IH then")
                                                    (("2"
                                                      (inst
                                                       "IH else"
                                                       "fpLocalEnv")
                                                      (("2"
                                                        (with-labels
                                                         (split
                                                          "IH else")
                                                         (("substmt ceb is evaluable")
                                                          ("then_stmt must be evaluable")))
                                                        (("1"
                                                          (inst
                                                           "substmt ceb is evaluable"
                                                           "else_stmt"
                                                           "nargs"
                                                           "env"
                                                           "elseceb")
                                                          (("1"
                                                            (use
                                                             "well_formed_ite_else")
                                                            (("1"
                                                              (assert)
                                                              nil
                                                              nil))
                                                            nil))
                                                          nil)
                                                         ("2"
                                                          (use
                                                           "fp_evaluable_in_stmt_evaluable_ite_else")
                                                          (("2"
                                                            (assert)
                                                            nil
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("2" (inst "IH then" "fpLocalEnv")
                (("2" (hide "IH else")
                  (("2"
                    (with-labels (split "IH then")
                     (("substmt ceb is evaluable")
                      ("then_stmt must be evaluable")))
                    (("1"
                      (inst "substmt ceb is evaluable" "substmt"
                       "nargs" "env" "ceb")
                      (("1" (use "well_formed_ite_then")
                        (("1" (assert) nil nil)) nil))
                      nil)
                     ("2"
                      (use "fp_evaluable_in_stmt_evaluable_ite_then")
                      (("2" (assert) nil nil)) nil))
                    nil))
                  nil))
                nil)
               ("3" (hide "IH then")
                (("3" (inst "IH else" "fpLocalEnv")
                  (("3"
                    (with-labels (split "IH else")
                     (("substmt ceb is evaluable")
                      ("else_stmt must be evaluable")))
                    (("1"
                      (inst "substmt ceb is evaluable" "substmt"
                       "nargs" "env" "ceb")
                      (("1" (use "well_formed_ite_else")
                        (("1" (assert) nil nil)) nil))
                      nil)
                     ("2"
                      (use "fp_evaluable_in_stmt_evaluable_ite_else")
                      (("2" (assert) nil nil)) nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("3" (skolem 1 "aexpr")
      (("3" (skolem 1 "fpLocalEnv")
        (("3" (flatten)
          (("3"
            (with-labels (skeep :preds? t)
             (("substmt is subterm of AEXPR" nil nil nil nil nil
               "env is well formed" "ceb is in the sem of substmt" nil
               "UNKNOWN")))
            (("3" (expand "subterm" "substmt is subterm of AEXPR")
              (("3" (replace "substmt is subterm of AEXPR" :hide? t)
                (("3" (use "fp_evaluable_in_aexpr_evaluable_ceb")
                  (("1" (expand "sem" "ceb is in the sem of substmt")
                    (("1" (propax) nil nil)) nil)
                   ("2" (use "well_formed_aexpr")
                    (("2" (assert) nil nil)) nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("4" (skolem 1 ("aexpr" "body"))
      (("4" (flatten)
        (("4" (skeep* :preds? t)
          (("4" (expand "subterm" -1)
            (("4" (split -1)
              (("1" (postpone) nil nil)
               ("2" (inst -9 "fpLocalEnv")
                (("2" (split -9)
                  (("1" (inst -1 "substmt" "nargs" "env" "ceb")
                    (("1" (postpone) nil nil)) nil)
                   ("2" (expand "bounded_by?" -9)
                    (("2" (postpone) nil nil)) nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((FPStmt type-decl nil program nil)
    (FPLocalEnvironment type-eq-decl nil expressions_semantics nil)
    (FPAExpr type-decl nil expressions nil)
    (Domain type-eq-decl nil domain nil)
    (wellFormed? inductive-decl "bool" program nil)
    (CEB type-eq-decl nil domain nil)
    (RAExprDomain type-decl nil domain nil)
    (RBExpr type-decl nil expressions nil)
    (FPAExprDomain type-decl nil domain nil)
    (FPBExpr type-decl nil expressions nil))
   shostak)
  (fp_evaluable_in_stmt_evaluable_ceb-2 "" 3753176888
   ("" (skeep :but "stmt")
    (("" (induct "stmt")
      (("1" (flatten)
        (("1" (skeep :preds? t)
          (("1" (expand "subterm" -)
            (("1" (replace -1 :hide? t)
              (("1" (expand "sem" -7)
                (("1" (expand "singleton")
                  (("1" (expand "make_ceb")
                    (("1" (replace -7 :hide? t)
                      (("1" (assert)
                        (("1" (expand "bounded_by?" 1)
                          (("1" (propax) nil nil)) nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("2" (skolem 1 ("guard_form" "then_stmt" "else_stmt"))
        (("2"
          (with-labels (flatten)
           (("IH then" "IH else" "evaluable ITE" "IT")))
          (("2"
            (with-labels (skeep "IT" :preds? t)
             (("substmt is subterm of ITE" nil nil nil nil nil
               "env is well formed" "ceb in in the sem of the subterm"
               "show that fpconds(ceb) is evaluable" "UNKNOWN")))
            (("2" (expand "subterm" "substmt is subterm of ITE")
              (("2"
                (with-labels (split "substmt is subterm of ITE")
                 (("substmt is ITE")
                  ("substmt is subterm of then branch")
                  ("substmt is subterm of else branch")))
                (("1" (replace "substmt is ITE" :hide? t)
                  (("1"
                    (expand "sem" "ceb in in the sem of the subterm")
                    (("1"
                      (expand "union"
                              "ceb in in the sem of the subterm")
                      (("1"
                        (expand "member"
                                "ceb in in the sem of the subterm")
                        (("1"
                          (with-labels
                           (split "ceb in in the sem of the subterm")
                           (("ceb is in propag(sem(then),guard)")
                            ("ceb is in propag(sem(else),NOT(guard))")
                            ("ceb is in unstable case 1")
                            ("ceb is in unstable case 2")))
                          (("1"
                            (with-labels
                             (let ((fnum
                                    (extra-get-fnum
                                     "ceb is in propag(sem(then),guard)")))
                               (invoke (typepred "%1") (! fnum 0)))
                             (("propag(sem(then),guard) is not empty"
                               "propag(sem(then),guard) ceb description, propag(sem(then),guard) side"
                               "propag(sem(then),guard) ceb description, sem(then) side")))
                            (("1"
                              (hide
                               "propag(sem(then),guard) is not empty"
                               "propag(sem(then),guard) ceb description, sem(then) side")
                              (("1"
                                (inst
                                 "propag(sem(then),guard) ceb description, propag(sem(then),guard) side"
                                 "ceb")
                                (("1"
                                  (skolem
                                   "propag(sem(then),guard) ceb description, propag(sem(then),guard) side"
                                   "ceb_then"
                                   :skolem-typepreds?
                                   t)
                                  (("1"
                                    (hide "IH else")
                                    (("1"
                                      (with-labels
                                       (split "IH then")
                                       (("substmt ceb is evaluable")
                                        ("then_stmt must be evaluable")))
                                      (("1"
                                        (inst
                                         "substmt ceb is evaluable"
                                         "then_stmt"
                                         "nargs"
                                         "env"
                                         "ceb_then")
                                        (("1"
                                          (replace
                                           "propag(sem(then),guard) ceb description, propag(sem(then),guard) side"
                                           :hide?
                                           t)
                                          (("1"
                                            (expand "make_ceb")
                                            (("1"
                                              (use "evaluable_in_and")
                                              (("1"
                                                (replace -1 :hide? t)
                                                (("1"
                                                  (split
                                                   "show that fpconds(ceb) is evaluable")
                                                  (("1"
                                                    (use
                                                     "fp_evaluable_in_stmt_evaluable_ite")
                                                    (("1"
                                                      (assert)
                                                      nil
                                                      nil))
                                                    nil)
                                                   ("2"
                                                    (propax)
                                                    nil
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil)
                                         ("2"
                                          (use "well_formed_ite_then")
                                          (("2" (assert) nil nil))
                                          nil))
                                        nil)
                                       ("2"
                                        (use
                                         "fp_evaluable_in_stmt_evaluable_ite_then")
                                        (("2" (assert) nil nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil)
                           ("2" (hide "IH then")
                            (("2"
                              (with-labels
                               (let
                                ((fnum
                                  (extra-get-fnum
                                   "ceb is in propag(sem(else),NOT(guard))")))
                                (invoke (typepred "%1") (! fnum 0)))
                               (("propag(sem(else),NOT guard) is not empty"
                                 "propag(sem(else),NOT guard) ceb description, propag(sem(else),NOT guard) side"
                                 "propag(sem(else),guard) ceb description, sem(then) side")))
                              (("2"
                                (hide
                                 "propag(sem(else),NOT guard) is not empty"
                                 "propag(sem(else),NOT guard) ceb description, sem(then) side")
                                (("2"
                                  (inst
                                   "propag(sem(else),NOT guard) ceb description, propag(sem(else),NOT guard) side"
                                   "ceb")
                                  (("2"
                                    (skolem
                                     "propag(sem(else),NOT guard) ceb description, propag(sem(else),NOT guard) side"
                                     "ceb_else"
                                     :skolem-typepreds?
                                     t)
                                    (("2"
                                      (with-labels
                                       (split "IH else")
                                       (("substmt ceb is evaluable")
                                        ("else_stmt must be evaluable")))
                                      (("1"
                                        (inst
                                         "substmt ceb is evaluable"
                                         "else_stmt"
                                         "nargs"
                                         "env"
                                         "ceb_else")
                                        (("1"
                                          (replace
                                           "propag(sem(else),NOT guard) ceb description, propag(sem(else),NOT guard) side"
                                           :hide?
                                           t)
                                          (("1"
                                            (expand "make_ceb")
                                            (("1"
                                              (use "evaluable_in_and")
                                              (("1"
                                                (replace -1 :hide? t)
                                                (("1"
                                                  (split
                                                   "show that fpconds(ceb) is evaluable")
                                                  (("1"
                                                    (use
                                                     "evaluable_in_not")
                                                    (("1"
                                                      (replace
                                                       -1
                                                       :hide?
                                                       t)
                                                      (("1"
                                                        (use
                                                         "fp_evaluable_in_stmt_evaluable_ite")
                                                        (("1"
                                                          (assert)
                                                          nil
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil)
                                                   ("2"
                                                    (propax)
                                                    nil
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil)
                                         ("2"
                                          (use "well_formed_ite_else")
                                          (("2" (assert) nil nil))
                                          nil))
                                        nil)
                                       ("2"
                                        (use
                                         "fp_evaluable_in_stmt_evaluable_ite_else")
                                        (("2" (assert) nil nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil)
                           ("3"
                            (with-labels
                             (let ((fnum
                                    (extra-get-fnum
                                     "ceb is in unstable case 1")))
                               (invoke (typepred "%1") (! fnum 0)))
                             (("unstable case 1 is not empty"
                               "unstable case 1 ceb description, unstable case 1 side"
                               "unstable case 1 ceb description, sem(then) side")))
                            (("3"
                              (hide "unstable case 1 is not empty"
                               "unstable case 1 ceb description, sem(then) side")
                              (("3"
                                (inst
                                 "unstable case 1 ceb description, unstable case 1 side"
                                 "ceb")
                                (("3"
                                  (with-labels
                                   (skolem
                                    "unstable case 1 ceb description, unstable case 1 side"
                                    "ceb_else_then_unst"
                                    :skolem-typepreds?
                                    t)
                                   (("else_then_unst definition"
                                     "ceb description")))
                                  (("3"
                                    (expand
                                     "else_then_unstable_ceb"
                                     "else_then_unst definition")
                                    (("3"
                                      (skolem
                                       "else_then_unst definition"
                                       ("thenceb" "elseceb"))
                                      (("3"
                                        (replace
                                         "ceb description"
                                         "show that fpconds(ceb) is evaluable"
                                         :hide?
                                         t)
                                        (("3"
                                          (expand
                                           "make_ceb"
                                           "show that fpconds(ceb) is evaluable")
                                          (("3"
                                            (with-labels
                                             (flatten
                                              "else_then_unst definition")
                                             (("ceb_else_then_unst`rconds"
                                               "ceb_else_then_unst`fpconds"
                                               "ceb_else_then_unst`rresult"
                                               "ceb_else_then_unst`fpresult"
                                               "ceb_else_then_unst`stable?")))
                                            (("3"
                                              (replace
                                               "ceb_else_then_unst`fpconds"
                                               "show that fpconds(ceb) is evaluable")
                                              (("3"
                                                (use
                                                 "evaluable_in_and")
                                                (("3"
                                                  (replace -1 :hide? t)
                                                  (("3"
                                                    (split
                                                     "show that fpconds(ceb) is evaluable")
                                                    (("1"
                                                      (use
                                                       "fp_evaluable_in_stmt_evaluable_ite")
                                                      (("1"
                                                        (assert)
                                                        nil
                                                        nil))
                                                      nil)
                                                     ("2"
                                                      (hide "IH else")
                                                      (("2"
                                                        (with-labels
                                                         (split
                                                          "IH then")
                                                         (("substmt ceb is evaluable")
                                                          ("then_stmt must be evaluable")))
                                                        (("1"
                                                          (inst
                                                           "substmt ceb is evaluable"
                                                           "then_stmt"
                                                           "nargs"
                                                           "env"
                                                           "thenceb")
                                                          (("1"
                                                            (use
                                                             "well_formed_ite_then")
                                                            (("1"
                                                              (assert)
                                                              nil
                                                              nil))
                                                            nil))
                                                          nil)
                                                         ("2"
                                                          (use
                                                           "fp_evaluable_in_stmt_evaluable_ite_then")
                                                          (("2"
                                                            (assert)
                                                            nil
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil)
                           ("4"
                            (with-labels
                             (let ((fnum
                                    (extra-get-fnum
                                     "ceb is in unstable case 2")))
                               (invoke (typepred "%1") (! fnum 0)))
                             (("unstable case 2 is not empty"
                               "unstable case 2 ceb description, unstable case 2 side"
                               "unstable case 2 ceb description, sem(then) side")))
                            (("4"
                              (hide "unstable case 2 is not empty"
                               "unstable case 2 ceb description, sem(then) side")
                              (("4"
                                (inst
                                 "unstable case 2 ceb description, unstable case 2 side"
                                 "ceb")
                                (("4"
                                  (with-labels
                                   (skolem
                                    "unstable case 2 ceb description, unstable case 2 side"
                                    "ceb_then_else_unst"
                                    :skolem-typepreds?
                                    t)
                                   (("then_else_unst definition"
                                     "ceb description")))
                                  (("4"
                                    (expand
                                     "then_else_unstable_ceb"
                                     "then_else_unst definition")
                                    (("4"
                                      (skolem
                                       "then_else_unst definition"
                                       ("thenceb" "elseceb"))
                                      (("4"
                                        (replace
                                         "ceb description"
                                         "show that fpconds(ceb) is evaluable"
                                         :hide?
                                         t)
                                        (("4"
                                          (expand
                                           "make_ceb"
                                           "show that fpconds(ceb) is evaluable")
                                          (("4"
                                            (with-labels
                                             (flatten
                                              "then_else_unst definition")
                                             (("ceb_then_else_unst`rconds"
                                               "ceb_then_else_unst`fpconds"
                                               "ceb_then_else_unst`rresult"
                                               "ceb_then_else_unst`fpresult"
                                               "ceb_then_else_unst`stable?")))
                                            (("4"
                                              (replace
                                               "ceb_then_else_unst`fpconds"
                                               "show that fpconds(ceb) is evaluable")
                                              (("4"
                                                (use
                                                 "evaluable_in_and")
                                                (("4"
                                                  (replace -1 :hide? t)
                                                  (("4"
                                                    (split
                                                     "show that fpconds(ceb) is evaluable")
                                                    (("1"
                                                      (use
                                                       "evaluable_in_not")
                                                      (("1"
                                                        (replace
                                                         -1
                                                         :hide?
                                                         t)
                                                        (("1"
                                                          (use
                                                           "fp_evaluable_in_stmt_evaluable_ite")
                                                          (("1"
                                                            (assert)
                                                            nil
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil)
                                                     ("2"
                                                      (hide "IH then")
                                                      (("2"
                                                        (with-labels
                                                         (split
                                                          "IH else")
                                                         (("substmt ceb is evaluable")
                                                          ("then_stmt must be evaluable")))
                                                        (("1"
                                                          (inst
                                                           "substmt ceb is evaluable"
                                                           "else_stmt"
                                                           "nargs"
                                                           "env"
                                                           "elseceb")
                                                          (("1"
                                                            (use
                                                             "well_formed_ite_else")
                                                            (("1"
                                                              (assert)
                                                              nil
                                                              nil))
                                                            nil))
                                                          nil)
                                                         ("2"
                                                          (use
                                                           "fp_evaluable_in_stmt_evaluable_ite_else")
                                                          (("2"
                                                            (assert)
                                                            nil
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (hide "IH else")
                  (("2"
                    (with-labels (split "IH then")
                     (("substmt ceb is evaluable")
                      ("then_stmt must be evaluable")))
                    (("1"
                      (inst "substmt ceb is evaluable" "substmt"
                       "nargs" "env" "ceb")
                      (("1" (use "well_formed_ite_then")
                        (("1" (assert) nil nil)) nil))
                      nil)
                     ("2"
                      (use "fp_evaluable_in_stmt_evaluable_ite_then")
                      (("2" (assert) nil nil)) nil))
                    nil))
                  nil)
                 ("3" (hide "IH then")
                  (("3"
                    (with-labels (split "IH else")
                     (("substmt ceb is evaluable")
                      ("else_stmt must be evaluable")))
                    (("1"
                      (inst "substmt ceb is evaluable" "substmt"
                       "nargs" "env" "ceb")
                      (("1" (use "well_formed_ite_else")
                        (("1" (assert) nil nil)) nil))
                      nil)
                     ("2"
                      (use "fp_evaluable_in_stmt_evaluable_ite_else")
                      (("2" (assert) nil nil)) nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("3" (skolem 1 "aexpr")
        (("3" (flatten)
          (("3"
            (with-labels (skeep :preds? t)
             (("substmt is subterm of AEXPR" nil nil nil nil nil
               "env is well formed" "ceb is in the sem of substmt" nil
               "UNKNOWN")))
            (("3" (expand "subterm" "substmt is subterm of AEXPR")
              (("3" (replace "substmt is subterm of AEXPR" :hide? t)
                (("3" (use "fp_evaluable_in_aexpr_evaluable_ceb")
                  (("1" (expand "sem" "ceb is in the sem of substmt")
                    (("1" (propax) nil nil)) nil)
                   ("2" (use "well_formed_aexpr")
                    (("2" (assert) nil nil)) nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("4" (skolem 1 ("aexpr" "body"))
        (("4" (flatten)
          (("4" (skeep :preds? t)
            (("4" (expand "subterm" -1)
              (("4" (split -1)
                (("1" (postpone) nil nil)
                 ("2" (split -9)
                  (("1" (inst -1 "substmt" "nargs" "env" "ceb")
                    (("1" (use "well_formed_letin_body")
                      (("1" (assert) nil nil)) nil))
                    nil)
                   ("2" (postpone) nil nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   nil shostak)
  (fp_evaluable_in_stmt_evaluable_ceb-1 nil 3752596523
   ("" (skeep :but "stmt")
    (("" (induct "stmt")
      (("1" (grind) nil nil)
       ("2" (skolem 1 ("guard_form" "then_stmt" "else_stmt"))
        (("2" (flatten)
          (("2" (skeep :preds? t)
            (("2" (expand "subterm" -1)
              (("2" (split -1)
                (("1" (replace -1 :hide? t)
                  (("1" (expand "sem" -6)
                    (("1" (expand "union" -6)
                      (("1" (expand "member" -6)
                        (("1" (split -6)
                          (("1" (invoke (typepred "%1") (! -1 0))
                            (("1" (hide -1 -3)
                              (("1"
                                (inst -1 "ceb")
                                (("1"
                                  (skolem
                                   -1
                                   "ceb_then"
                                   :skolem-typepreds?
                                   t)
                                  (("1"
                                    (split -9)
                                    (("1"
                                      (inst
                                       -1
                                       "then_stmt"
                                       "nargs"
                                       "env"
                                       "ceb_then")
                                      (("1"
                                        (replace -3 :hide? t)
                                        (("1"
                                          (expand "make_ceb")
                                          (("1"
                                            (use "evaluable_in_and")
                                            (("1"
                                              (replace -1 :hide? t)
                                              (("1"
                                                (split 1)
                                                (("1"
                                                  (use
                                                   "fp_evaluable_in_stmt_evaluable_ite")
                                                  (("1"
                                                    (assert)
                                                    nil
                                                    nil))
                                                  nil)
                                                 ("2"
                                                  (propax)
                                                  nil
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil)
                                       ("2"
                                        (split 1)
                                        (("1"
                                          (expand "wellFormed?" -7)
                                          (("1" (postpone) nil nil))
                                          nil)
                                         ("2" (postpone) nil nil))
                                        nil)
                                       ("3" (postpone) nil nil))
                                      nil)
                                     ("2" (postpone) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil)
                           ("2" (postpone) nil nil)
                           ("3" (postpone) nil nil)
                           ("4" (postpone) nil nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (postpone) nil nil) ("3" (postpone) nil nil))
                nil))
              nil))
            nil))
          nil))
        nil)
       ("3" (postpone) nil nil) ("4" (postpone) nil nil))
      nil))
    nil)
   ((FPLocalEnvironment type-eq-decl nil expressions_semantics nil)
    (FPAExpr type-decl nil expressions nil)
    (FPStmt type-decl nil program nil)
    (FPBExpr type-decl nil expressions nil)
    (subterm adt-def-decl "boolean" program nil)
    (FPAExprDomain type-decl nil domain nil)
    (RBExpr type-decl nil expressions nil)
    (RAExprDomain type-decl nil domain nil)
    (CEB type-eq-decl nil domain nil)
    (wellFormed? inductive-decl "bool" program nil)
    (Domain type-eq-decl nil domain nil))
   shostak))
 (r_evaluable_in_stmt_evaluable_ceb 0
  (r_evaluable_in_stmt_evaluable_ceb-1 nil 3755251523
   ("" (skeep* :preds? t)
    (("" (use "evaluable_in_max_local_index__stmt")
      (("" (assert)
        (("" (use "max_local_index_evaluable_in__rform")
          (("" (assert)
            (("" (hide 2)
              (("" (use "max_local_index_ceb_rcond")
                (("" (assert)
                  (("" (expand "semanticallyConsistent?")
                    (("" (flatten)
                      ((""
                        (case "maxFreeLocalIndex(env) < length(env)")
                        (("1" (expand "consistentLocalEnvironments?")
                          (("1" (flatten)
                            (("1" (hide-all-but (-1 -2 -3 -8 -12 1))
                              (("1" (grind) nil nil)) nil))
                            nil))
                          nil)
                         ("2"
                          (use "max_local_index_env_well_formed_eq")
                          (("2" (assert) nil nil)) nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((evaluable_in_max_local_index__stmt formula-decl nil semantics nil)
    (FPStmt type-decl nil program nil)
    (FPLocalEnvironment type-eq-decl nil expressions_semantics nil)
    (LocalEnvironment nonempty-type-decl nil u_local_environment nil)
    (<< adt-def-decl "(strict_well_founded?[FPAExpr])" expressions nil)
    (strict_well_founded? const-decl "bool" orders nil)
    (fpVarIndex const-decl "nat" expressions_semantics nil)
    (applyFun_fp formal-const-decl
     "[[Operator, FloatingPointNumber, FloatingPointNumber] ->
   FloatingPointNumber]" semantics nil)
    (lt_fp formal-const-decl
     "(strict_total_order?[FloatingPointNumber])" semantics nil)
    (applyFun_r formal-const-decl
     "[[Operator, RealNumber, RealNumber] -> RealNumber]" semantics
     nil)
    (lt_r formal-const-decl "(strict_total_order?[RealNumber])"
     semantics nil)
    (strict_total_order? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (FPVariable? adt-recognizer-decl "[FPAExpr -> boolean]" expressions
     nil)
    (FPAExpr type-decl nil expressions nil)
    (FtoR formal-const-decl "[FloatingPointNumber -> RealNumber]"
     semantics nil)
    (FloatingPointNumber formal-nonempty-type-decl nil semantics nil)
    (RealNumber formal-nonempty-type-decl nil semantics nil)
    (Operator formal-nonempty-type-decl nil semantics nil)
    (max_local_index_evaluable_in__rform formula-decl nil semantics
     nil)
    (wellFormed? def-decl "bool" semantics nil)
    (semanticallyConsistent? const-decl "bool" semantics nil)
    (sem def-decl
     "{d: Domain | EXISTS (ceb: CEB): d(ceb) AND stable?(ceb)}"
     semantics nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (length def-decl "nat" list_props nil)
    (Domain type-eq-decl nil domain nil)
    (wellFormed? inductive-decl "bool" program nil)
    (validEnvironmentForStmt const-decl "bool" semantics nil)
    (Environment nonempty-type-eq-decl nil semantics nil)
    (finite_nonempty? const-decl "bool" more_set_defs "sets_aux/")
    (every adt-def-decl "boolean" list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil) (set type-eq-decl nil sets nil)
    (CEB type-eq-decl nil domain nil)
    (RAExprDomain type-decl nil domain nil)
    (FPAExprDomain type-decl nil domain nil)
    (FPBExpr type-decl nil expressions nil)
    (RBExpr type-decl nil expressions nil)
    (consistentLocalEnvironments? const-decl "bool"
     expressions_semantics nil)
    (RLocalEnvironment type-eq-decl nil expressions_semantics nil)
    (<< adt-def-decl "(strict_well_founded?[RAExpr])" expressions nil)
    (rVarIndex const-decl "nat" expressions_semantics nil)
    (RVariable? adt-recognizer-decl "[RAExpr -> boolean]" expressions
     nil)
    (RAExpr type-decl nil expressions nil)
    (max_local_index_env_well_formed_eq formula-decl nil semantics nil)
    (max const-decl "{p: real | p >= m AND p >= n}" real_defs nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (minus_odd_is_odd application-judgement "odd_int" integers nil)
    (int_max application-judgement "{k: int | i <= k AND j <= k}"
     real_defs nil)
    (rat_max application-judgement "{s: rat | s >= q AND s >= r}"
     real_defs nil)
    (maxFreeLocalIndex def-decl "upfrom(-1)" semantics nil)
    (upfrom nonempty-type-eq-decl nil integers nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (max_local_index_ceb_rcond formula-decl nil semantics nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil))
 (sem_TCC24 0
  (sem_TCC24-1 nil 3754571630 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (Operator formal-nonempty-type-decl nil semantics nil)
    (RealNumber formal-nonempty-type-decl nil semantics nil)
    (FloatingPointNumber formal-nonempty-type-decl nil semantics nil)
    (FtoR formal-const-decl "[FloatingPointNumber -> RealNumber]"
     semantics nil)
    (FPStmt type-decl nil program nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (FPProgram type-eq-decl nil program nil)
    (wellFormedProgram? const-decl "bool" program nil)
    (emptyEnv const-decl "Environment" semantics nil)
    (length_null formula-decl nil more_list_props "structures/"))
   nil)))

