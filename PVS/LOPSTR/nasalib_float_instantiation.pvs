nasalib_float_instantiation[ 
  radix : above(1),
  (IMPORTING float@float[radix])
  b     : Format,
  round : ClosestRoundingPred(b),
  RtoF  : CanonicRoundingFun(b,round)
] : THEORY BEGIN
  ASSUMING
    % Assumings needed to fulfill accum_err_add assumptions.
    % These properties hold for single and double precision numbers (see
    % float@ieee754sp.pvs and float@ieee754dp.pvs)

    round_even_closest: ASSUMPTION
      FORALL(x:real,f:(Fbounded?(b))): round(x,f) IMPLIES EvenClosest?(b)(x,f)

    round_rounded_mode: ASSUMPTION
      rounded_mode?(b)(round)

  ENDASSUMING

  RealNumber: TYPE = real
  FloatingPointNumber: TYPE = (Fcanonic?(b))

  X,Y,Z: VAR FloatingPointNumber

  lt_fp: (strict_total_order?[FloatingPointNumber])
  = LAMBDA(X,Y): Flt?(X,Y)

  Operator: TYPE = { add, AddUlp2, AbsAdd } 

  op : VAR Operator

  operatorUnderAnalysis?(op): bool
  = ( op = add )

  applyFun_r(op: Operator, arg1,arg2: real): real =
    CASES op OF
      % input
      add: arg1 + arg2,
      % analysis
      AddUlp2: arg1+(ulp(b,round,RtoF)(arg2)/2),
      AbsAdd: abs(arg1 + arg2)
    ENDCASES

  IMPORTING float@accum_err_add[radix,b,round,RtoF], float@cr_div[radix,b,round,RtoF]

  applyFun_fp(op: Operator, arg1,arg2: FloatingPointNumber): FloatingPointNumber =
    CASES op OF
      % input
      add: Fadd(arg1,arg2),
      % analysis
      AddUlp2: Fadd(arg1,Fdiv(arg2,RtoF(2))),
      AbsAdd: Fabs(Fadd(arg1,arg2))
    ENDCASES

  zero_fp: FloatingPointNumber = float_pair(0,-dExp(b))

  IMPORTING linear_ineq_zero_beta
  	    [ Operator,real,<,applyFun_r,FloatingPointNumber,lt_fp,applyFun_fp,FtoR,
	      0,abs,-,-,zero_fp,Fopp ]

  IMPORTING two_level_expressions
  	    [ Operator,(operatorUnderAnalysis?),
	      RealNumber,<,applyFun_r,
	      FloatingPointNumber,lt_fp,applyFun_fp,FtoR ]

  aerrByOp
  (op: (operatorUnderAnalysis?))
  ( arg1: IRExpr,
    err1: ARExpr,
    arg2: IRExpr,
    err2: ARExpr)
  : ARExpr
  = CASES op OF
      add: make_application_arexpr(AddUlp2,
      	    make_application_arexpr(add,err1,err2),
  	     make_application_arexpr(add,
    		       make_application_arexpr(AbsAdd,iRToAR(arg1),iRToAR(arg2)),
		       make_application_arexpr(add,err1,err2) ) )
    ENDCASES 

  ifpParamEnv : VAR IFPEnvironment
  ifpLocalEnv : VAR IFPLocalEnv
  irLocalEnv  : VAR IRLocalEnv
  ife1,ife2  : VAR IFExpr
  ire1,ire2   : VAR IRExpr
  are1,are2   : VAR ARExpr
  
  addErrExpr ( ire1,ire2,are1,are2 )
  : ARExpr
  = aerrByOp(add)(ire1,are1,ire2,are2)

  addErrExpr_j
  : JUDGEMENT
    addErrExpr(ire1,ire2,are1,are2)
    HAS_TYPE { res: ARExpr | FORALL(irLocalEnv)
    	     	  	     : bounded_by?(irLocalEnv)(ire1) AND
    			       bounded_by?(iRToAR_env(irLocalEnv))(are1) AND
    			       bounded_by?(irLocalEnv)(ire2) AND
    			       bounded_by?(iRToAR_env(irLocalEnv))(are2)
    			       IMPLIES bounded_by?(iRToAR_env(irLocalEnv))(res) }

  addErrVal
  (ifpParamEnv,ifpLocalEnv)
  ( ife1|bounded_by?(ifpLocalEnv)(ife1),
    ife2|bounded_by?(ifpLocalEnv)(ife2) )
  ( are1|bounded_by?(iRToAR_env(FtoR(ifpLocalEnv)))(are1),
    are2|bounded_by?(iRToAR_env(FtoR(ifpLocalEnv)))(are2) )
  : { result: real |
        LET irParamEnv = input_esem_th.FtoR(ifpParamEnv),
	    arParamEnv = iRToAR_par(irParamEnv),
	    irLocalEnv = input_esem_th.FtoR(ifpLocalEnv),
	    arLocalEnv = iRToAR_env(irLocalEnv)
	IN le_r( abs(FtoR(input_esem_th.eval(ifpParamEnv,ifpLocalEnv)(ife1))
	           - input_esem_th.eval(irParamEnv,irLocalEnv)(FtoR(ife1)))
	       , eval(arParamEnv,arLocalEnv)(are1) ) AND
	   le_r( abs(FtoR(input_esem_th.eval(ifpParamEnv,ifpLocalEnv)(ife2))
	           - input_esem_th.eval(irParamEnv,irLocalEnv)(FtoR(ife2)))
	       , eval(arParamEnv,arLocalEnv)(are2) )
	   IMPLIES LET diff: real = FtoR(input_esem_th.eval(ifpParamEnv,ifpLocalEnv)(FPOperator(add,ife1,ife2)))
	           - input_esem_th.eval(irParamEnv,irLocalEnv)(input_expr_th.FtoR(FPOperator(add,ife1,ife2)))
		   IN le_r( abs( diff ), result ) }
  = eval( iRToAR_par(input_esem_th.FtoR(ifpParamEnv)),
          iRToAR_env(input_esem_th.FtoR(ifpLocalEnv)) )
        ( addErrExpr(FtoR(ife1),FtoR(ife2),are1,are2) )

  IMPORTING accumulated_roundoff_error
  	    [ Operator,operatorUnderAnalysis?,
	      real,<,applyFun_r,FloatingPointNumber,lt_fp,applyFun_fp,FtoR,
	      aerrByOp,
	      0,abs,-,zero_fp ]

END nasalib_float_instantiation
